// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockPipeliner is an autogenerated mock type for the Pipeliner type
type MockPipeliner struct {
	mock.Mock
}

type MockPipeliner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPipeliner) EXPECT() *MockPipeliner_Expecter {
	return &MockPipeliner_Expecter{mock: &_m.Mock}
}

// ACLCat provides a mock function with given fields: ctx
func (_m *MockPipeliner) ACLCat(ctx context.Context) *StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLCat")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLCat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLCat'
type MockPipeliner_ACLCat_Call struct {
	*mock.Call
}

// ACLCat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ACLCat(ctx interface{}) *MockPipeliner_ACLCat_Call {
	return &MockPipeliner_ACLCat_Call{Call: _e.mock.On("ACLCat", ctx)}
}

func (_c *MockPipeliner_ACLCat_Call) Run(run func(ctx context.Context)) *MockPipeliner_ACLCat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ACLCat_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ACLCat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLCat_Call) RunAndReturn(run func(context.Context) *StringSliceCmd) *MockPipeliner_ACLCat_Call {
	_c.Call.Return(run)
	return _c
}

// ACLCatArgs provides a mock function with given fields: ctx, options
func (_m *MockPipeliner) ACLCatArgs(ctx context.Context, options *ACLCatArgs) *StringSliceCmd {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for ACLCatArgs")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *ACLCatArgs) *StringSliceCmd); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLCatArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLCatArgs'
type MockPipeliner_ACLCatArgs_Call struct {
	*mock.Call
}

// ACLCatArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - options *ACLCatArgs
func (_e *MockPipeliner_Expecter) ACLCatArgs(ctx interface{}, options interface{}) *MockPipeliner_ACLCatArgs_Call {
	return &MockPipeliner_ACLCatArgs_Call{Call: _e.mock.On("ACLCatArgs", ctx, options)}
}

func (_c *MockPipeliner_ACLCatArgs_Call) Run(run func(ctx context.Context, options *ACLCatArgs)) *MockPipeliner_ACLCatArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ACLCatArgs))
	})
	return _c
}

func (_c *MockPipeliner_ACLCatArgs_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ACLCatArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLCatArgs_Call) RunAndReturn(run func(context.Context, *ACLCatArgs) *StringSliceCmd) *MockPipeliner_ACLCatArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ACLDelUser provides a mock function with given fields: ctx, username
func (_m *MockPipeliner) ACLDelUser(ctx context.Context, username string) *IntCmd {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for ACLDelUser")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLDelUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLDelUser'
type MockPipeliner_ACLDelUser_Call struct {
	*mock.Call
}

// ACLDelUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockPipeliner_Expecter) ACLDelUser(ctx interface{}, username interface{}) *MockPipeliner_ACLDelUser_Call {
	return &MockPipeliner_ACLDelUser_Call{Call: _e.mock.On("ACLDelUser", ctx, username)}
}

func (_c *MockPipeliner_ACLDelUser_Call) Run(run func(ctx context.Context, username string)) *MockPipeliner_ACLDelUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ACLDelUser_Call) Return(_a0 *IntCmd) *MockPipeliner_ACLDelUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLDelUser_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ACLDelUser_Call {
	_c.Call.Return(run)
	return _c
}

// ACLDryRun provides a mock function with given fields: ctx, username, command
func (_m *MockPipeliner) ACLDryRun(ctx context.Context, username string, command ...interface{}) *StringCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, command...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLDryRun")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *StringCmd); ok {
		r0 = rf(ctx, username, command...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLDryRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLDryRun'
type MockPipeliner_ACLDryRun_Call struct {
	*mock.Call
}

// ACLDryRun is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - command ...interface{}
func (_e *MockPipeliner_Expecter) ACLDryRun(ctx interface{}, username interface{}, command ...interface{}) *MockPipeliner_ACLDryRun_Call {
	return &MockPipeliner_ACLDryRun_Call{Call: _e.mock.On("ACLDryRun",
		append([]interface{}{ctx, username}, command...)...)}
}

func (_c *MockPipeliner_ACLDryRun_Call) Run(run func(ctx context.Context, username string, command ...interface{})) *MockPipeliner_ACLDryRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ACLDryRun_Call) Return(_a0 *StringCmd) *MockPipeliner_ACLDryRun_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLDryRun_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *StringCmd) *MockPipeliner_ACLDryRun_Call {
	_c.Call.Return(run)
	return _c
}

// ACLList provides a mock function with given fields: ctx
func (_m *MockPipeliner) ACLList(ctx context.Context) *StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLList")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLList'
type MockPipeliner_ACLList_Call struct {
	*mock.Call
}

// ACLList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ACLList(ctx interface{}) *MockPipeliner_ACLList_Call {
	return &MockPipeliner_ACLList_Call{Call: _e.mock.On("ACLList", ctx)}
}

func (_c *MockPipeliner_ACLList_Call) Run(run func(ctx context.Context)) *MockPipeliner_ACLList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ACLList_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ACLList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLList_Call) RunAndReturn(run func(context.Context) *StringSliceCmd) *MockPipeliner_ACLList_Call {
	_c.Call.Return(run)
	return _c
}

// ACLLog provides a mock function with given fields: ctx, count
func (_m *MockPipeliner) ACLLog(ctx context.Context, count int64) *ACLLogCmd {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for ACLLog")
	}

	var r0 *ACLLogCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *ACLLogCmd); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ACLLogCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLLog'
type MockPipeliner_ACLLog_Call struct {
	*mock.Call
}

// ACLLog is a helper method to define mock.On call
//   - ctx context.Context
//   - count int64
func (_e *MockPipeliner_Expecter) ACLLog(ctx interface{}, count interface{}) *MockPipeliner_ACLLog_Call {
	return &MockPipeliner_ACLLog_Call{Call: _e.mock.On("ACLLog", ctx, count)}
}

func (_c *MockPipeliner_ACLLog_Call) Run(run func(ctx context.Context, count int64)) *MockPipeliner_ACLLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ACLLog_Call) Return(_a0 *ACLLogCmd) *MockPipeliner_ACLLog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLLog_Call) RunAndReturn(run func(context.Context, int64) *ACLLogCmd) *MockPipeliner_ACLLog_Call {
	_c.Call.Return(run)
	return _c
}

// ACLLogReset provides a mock function with given fields: ctx
func (_m *MockPipeliner) ACLLogReset(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLLogReset")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLLogReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLLogReset'
type MockPipeliner_ACLLogReset_Call struct {
	*mock.Call
}

// ACLLogReset is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ACLLogReset(ctx interface{}) *MockPipeliner_ACLLogReset_Call {
	return &MockPipeliner_ACLLogReset_Call{Call: _e.mock.On("ACLLogReset", ctx)}
}

func (_c *MockPipeliner_ACLLogReset_Call) Run(run func(ctx context.Context)) *MockPipeliner_ACLLogReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ACLLogReset_Call) Return(_a0 *StatusCmd) *MockPipeliner_ACLLogReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLLogReset_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ACLLogReset_Call {
	_c.Call.Return(run)
	return _c
}

// ACLSetUser provides a mock function with given fields: ctx, username, rules
func (_m *MockPipeliner) ACLSetUser(ctx context.Context, username string, rules ...string) *StatusCmd {
	_va := make([]interface{}, len(rules))
	for _i := range rules {
		_va[_i] = rules[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLSetUser")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StatusCmd); ok {
		r0 = rf(ctx, username, rules...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ACLSetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLSetUser'
type MockPipeliner_ACLSetUser_Call struct {
	*mock.Call
}

// ACLSetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - rules ...string
func (_e *MockPipeliner_Expecter) ACLSetUser(ctx interface{}, username interface{}, rules ...interface{}) *MockPipeliner_ACLSetUser_Call {
	return &MockPipeliner_ACLSetUser_Call{Call: _e.mock.On("ACLSetUser",
		append([]interface{}{ctx, username}, rules...)...)}
}

func (_c *MockPipeliner_ACLSetUser_Call) Run(run func(ctx context.Context, username string, rules ...string)) *MockPipeliner_ACLSetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ACLSetUser_Call) Return(_a0 *StatusCmd) *MockPipeliner_ACLSetUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ACLSetUser_Call) RunAndReturn(run func(context.Context, string, ...string) *StatusCmd) *MockPipeliner_ACLSetUser_Call {
	_c.Call.Return(run)
	return _c
}

// Append provides a mock function with given fields: ctx, key, value
func (_m *MockPipeliner) Append(ctx context.Context, key string, value string) *IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type MockPipeliner_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
func (_e *MockPipeliner_Expecter) Append(ctx interface{}, key interface{}, value interface{}) *MockPipeliner_Append_Call {
	return &MockPipeliner_Append_Call{Call: _e.mock.On("Append", ctx, key, value)}
}

func (_c *MockPipeliner_Append_Call) Run(run func(ctx context.Context, key string, value string)) *MockPipeliner_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_Append_Call) Return(_a0 *IntCmd) *MockPipeliner_Append_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Append_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_Append_Call {
	_c.Call.Return(run)
	return _c
}

// Auth provides a mock function with given fields: ctx, password
func (_m *MockPipeliner) Auth(ctx context.Context, password string) *StatusCmd {
	ret := _m.Called(ctx, password)

	if len(ret) == 0 {
		panic("no return value specified for Auth")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Auth_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Auth'
type MockPipeliner_Auth_Call struct {
	*mock.Call
}

// Auth is a helper method to define mock.On call
//   - ctx context.Context
//   - password string
func (_e *MockPipeliner_Expecter) Auth(ctx interface{}, password interface{}) *MockPipeliner_Auth_Call {
	return &MockPipeliner_Auth_Call{Call: _e.mock.On("Auth", ctx, password)}
}

func (_c *MockPipeliner_Auth_Call) Run(run func(ctx context.Context, password string)) *MockPipeliner_Auth_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Auth_Call) Return(_a0 *StatusCmd) *MockPipeliner_Auth_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Auth_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_Auth_Call {
	_c.Call.Return(run)
	return _c
}

// AuthACL provides a mock function with given fields: ctx, username, password
func (_m *MockPipeliner) AuthACL(ctx context.Context, username string, password string) *StatusCmd {
	ret := _m.Called(ctx, username, password)

	if len(ret) == 0 {
		panic("no return value specified for AuthACL")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, username, password)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_AuthACL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AuthACL'
type MockPipeliner_AuthACL_Call struct {
	*mock.Call
}

// AuthACL is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - password string
func (_e *MockPipeliner_Expecter) AuthACL(ctx interface{}, username interface{}, password interface{}) *MockPipeliner_AuthACL_Call {
	return &MockPipeliner_AuthACL_Call{Call: _e.mock.On("AuthACL", ctx, username, password)}
}

func (_c *MockPipeliner_AuthACL_Call) Run(run func(ctx context.Context, username string, password string)) *MockPipeliner_AuthACL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_AuthACL_Call) Return(_a0 *StatusCmd) *MockPipeliner_AuthACL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_AuthACL_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_AuthACL_Call {
	_c.Call.Return(run)
	return _c
}

// BFAdd provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) BFAdd(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for BFAdd")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_BFAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFAdd'
type MockPipeliner_BFAdd_Call struct {
	*mock.Call
}

// BFAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) BFAdd(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_BFAdd_Call {
	return &MockPipeliner_BFAdd_Call{Call: _e.mock.On("BFAdd", ctx, key, element)}
}

func (_c *MockPipeliner_BFAdd_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_BFAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_BFAdd_Call) Return(_a0 *BoolCmd) *MockPipeliner_BFAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFAdd_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_BFAdd_Call {
	_c.Call.Return(run)
	return _c
}

// BFCard provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFCard(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFCard")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BFCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFCard'
type MockPipeliner_BFCard_Call struct {
	*mock.Call
}

// BFCard is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFCard(ctx interface{}, key interface{}) *MockPipeliner_BFCard_Call {
	return &MockPipeliner_BFCard_Call{Call: _e.mock.On("BFCard", ctx, key)}
}

func (_c *MockPipeliner_BFCard_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFCard_Call) Return(_a0 *IntCmd) *MockPipeliner_BFCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFCard_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_BFCard_Call {
	_c.Call.Return(run)
	return _c
}

// BFExists provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) BFExists(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for BFExists")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_BFExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFExists'
type MockPipeliner_BFExists_Call struct {
	*mock.Call
}

// BFExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) BFExists(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_BFExists_Call {
	return &MockPipeliner_BFExists_Call{Call: _e.mock.On("BFExists", ctx, key, element)}
}

func (_c *MockPipeliner_BFExists_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_BFExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_BFExists_Call) Return(_a0 *BoolCmd) *MockPipeliner_BFExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFExists_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_BFExists_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfo(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfo")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfo'
type MockPipeliner_BFInfo_Call struct {
	*mock.Call
}

// BFInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfo(ctx interface{}, key interface{}) *MockPipeliner_BFInfo_Call {
	return &MockPipeliner_BFInfo_Call{Call: _e.mock.On("BFInfo", ctx, key)}
}

func (_c *MockPipeliner_BFInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfo_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfo_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfo_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoArg provides a mock function with given fields: ctx, key, option
func (_m *MockPipeliner) BFInfoArg(ctx context.Context, key string, option string) *BFInfoCmd {
	ret := _m.Called(ctx, key, option)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoArg")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key, option)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoArg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoArg'
type MockPipeliner_BFInfoArg_Call struct {
	*mock.Call
}

// BFInfoArg is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - option string
func (_e *MockPipeliner_Expecter) BFInfoArg(ctx interface{}, key interface{}, option interface{}) *MockPipeliner_BFInfoArg_Call {
	return &MockPipeliner_BFInfoArg_Call{Call: _e.mock.On("BFInfoArg", ctx, key, option)}
}

func (_c *MockPipeliner_BFInfoArg_Call) Run(run func(ctx context.Context, key string, option string)) *MockPipeliner_BFInfoArg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoArg_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoArg_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoArg_Call) RunAndReturn(run func(context.Context, string, string) *BFInfoCmd) *MockPipeliner_BFInfoArg_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoCapacity provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfoCapacity(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoCapacity")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoCapacity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoCapacity'
type MockPipeliner_BFInfoCapacity_Call struct {
	*mock.Call
}

// BFInfoCapacity is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfoCapacity(ctx interface{}, key interface{}) *MockPipeliner_BFInfoCapacity_Call {
	return &MockPipeliner_BFInfoCapacity_Call{Call: _e.mock.On("BFInfoCapacity", ctx, key)}
}

func (_c *MockPipeliner_BFInfoCapacity_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfoCapacity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoCapacity_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoCapacity_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoCapacity_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfoCapacity_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoExpansion provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfoExpansion(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoExpansion")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoExpansion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoExpansion'
type MockPipeliner_BFInfoExpansion_Call struct {
	*mock.Call
}

// BFInfoExpansion is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfoExpansion(ctx interface{}, key interface{}) *MockPipeliner_BFInfoExpansion_Call {
	return &MockPipeliner_BFInfoExpansion_Call{Call: _e.mock.On("BFInfoExpansion", ctx, key)}
}

func (_c *MockPipeliner_BFInfoExpansion_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfoExpansion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoExpansion_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoExpansion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoExpansion_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfoExpansion_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoFilters provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfoFilters(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoFilters")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoFilters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoFilters'
type MockPipeliner_BFInfoFilters_Call struct {
	*mock.Call
}

// BFInfoFilters is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfoFilters(ctx interface{}, key interface{}) *MockPipeliner_BFInfoFilters_Call {
	return &MockPipeliner_BFInfoFilters_Call{Call: _e.mock.On("BFInfoFilters", ctx, key)}
}

func (_c *MockPipeliner_BFInfoFilters_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfoFilters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoFilters_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoFilters_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoFilters_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfoFilters_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoItems provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfoItems(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoItems")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoItems_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoItems'
type MockPipeliner_BFInfoItems_Call struct {
	*mock.Call
}

// BFInfoItems is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfoItems(ctx interface{}, key interface{}) *MockPipeliner_BFInfoItems_Call {
	return &MockPipeliner_BFInfoItems_Call{Call: _e.mock.On("BFInfoItems", ctx, key)}
}

func (_c *MockPipeliner_BFInfoItems_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfoItems_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoItems_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoItems_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoItems_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfoItems_Call {
	_c.Call.Return(run)
	return _c
}

// BFInfoSize provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) BFInfoSize(ctx context.Context, key string) *BFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for BFInfoSize")
	}

	var r0 *BFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInfoSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInfoSize'
type MockPipeliner_BFInfoSize_Call struct {
	*mock.Call
}

// BFInfoSize is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) BFInfoSize(ctx interface{}, key interface{}) *MockPipeliner_BFInfoSize_Call {
	return &MockPipeliner_BFInfoSize_Call{Call: _e.mock.On("BFInfoSize", ctx, key)}
}

func (_c *MockPipeliner_BFInfoSize_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_BFInfoSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_BFInfoSize_Call) Return(_a0 *BFInfoCmd) *MockPipeliner_BFInfoSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInfoSize_Call) RunAndReturn(run func(context.Context, string) *BFInfoCmd) *MockPipeliner_BFInfoSize_Call {
	_c.Call.Return(run)
	return _c
}

// BFInsert provides a mock function with given fields: ctx, key, options, elements
func (_m *MockPipeliner) BFInsert(ctx context.Context, key string, options *BFInsertOptions, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFInsert")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *BFInsertOptions, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BFInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFInsert'
type MockPipeliner_BFInsert_Call struct {
	*mock.Call
}

// BFInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *BFInsertOptions
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) BFInsert(ctx interface{}, key interface{}, options interface{}, elements ...interface{}) *MockPipeliner_BFInsert_Call {
	return &MockPipeliner_BFInsert_Call{Call: _e.mock.On("BFInsert",
		append([]interface{}{ctx, key, options}, elements...)...)}
}

func (_c *MockPipeliner_BFInsert_Call) Run(run func(ctx context.Context, key string, options *BFInsertOptions, elements ...interface{})) *MockPipeliner_BFInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*BFInsertOptions), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BFInsert_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_BFInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFInsert_Call) RunAndReturn(run func(context.Context, string, *BFInsertOptions, ...interface{}) *BoolSliceCmd) *MockPipeliner_BFInsert_Call {
	_c.Call.Return(run)
	return _c
}

// BFLoadChunk provides a mock function with given fields: ctx, key, iterator, data
func (_m *MockPipeliner) BFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd {
	ret := _m.Called(ctx, key, iterator, data)

	if len(ret) == 0 {
		panic("no return value specified for BFLoadChunk")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, key, iterator, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BFLoadChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFLoadChunk'
type MockPipeliner_BFLoadChunk_Call struct {
	*mock.Call
}

// BFLoadChunk is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - iterator int64
//   - data interface{}
func (_e *MockPipeliner_Expecter) BFLoadChunk(ctx interface{}, key interface{}, iterator interface{}, data interface{}) *MockPipeliner_BFLoadChunk_Call {
	return &MockPipeliner_BFLoadChunk_Call{Call: _e.mock.On("BFLoadChunk", ctx, key, iterator, data)}
}

func (_c *MockPipeliner_BFLoadChunk_Call) Run(run func(ctx context.Context, key string, iterator int64, data interface{})) *MockPipeliner_BFLoadChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_BFLoadChunk_Call) Return(_a0 *StatusCmd) *MockPipeliner_BFLoadChunk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFLoadChunk_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *StatusCmd) *MockPipeliner_BFLoadChunk_Call {
	_c.Call.Return(run)
	return _c
}

// BFMAdd provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) BFMAdd(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFMAdd")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BFMAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFMAdd'
type MockPipeliner_BFMAdd_Call struct {
	*mock.Call
}

// BFMAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) BFMAdd(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_BFMAdd_Call {
	return &MockPipeliner_BFMAdd_Call{Call: _e.mock.On("BFMAdd",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_BFMAdd_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_BFMAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BFMAdd_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_BFMAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFMAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolSliceCmd) *MockPipeliner_BFMAdd_Call {
	_c.Call.Return(run)
	return _c
}

// BFMExists provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) BFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BFMExists")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BFMExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFMExists'
type MockPipeliner_BFMExists_Call struct {
	*mock.Call
}

// BFMExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) BFMExists(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_BFMExists_Call {
	return &MockPipeliner_BFMExists_Call{Call: _e.mock.On("BFMExists",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_BFMExists_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_BFMExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BFMExists_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_BFMExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFMExists_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolSliceCmd) *MockPipeliner_BFMExists_Call {
	_c.Call.Return(run)
	return _c
}

// BFReserve provides a mock function with given fields: ctx, key, errorRate, capacity
func (_m *MockPipeliner) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity)

	if len(ret) == 0 {
		panic("no return value specified for BFReserve")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BFReserve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFReserve'
type MockPipeliner_BFReserve_Call struct {
	*mock.Call
}

// BFReserve is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - errorRate float64
//   - capacity int64
func (_e *MockPipeliner_Expecter) BFReserve(ctx interface{}, key interface{}, errorRate interface{}, capacity interface{}) *MockPipeliner_BFReserve_Call {
	return &MockPipeliner_BFReserve_Call{Call: _e.mock.On("BFReserve", ctx, key, errorRate, capacity)}
}

func (_c *MockPipeliner_BFReserve_Call) Run(run func(ctx context.Context, key string, errorRate float64, capacity int64)) *MockPipeliner_BFReserve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_BFReserve_Call) Return(_a0 *StatusCmd) *MockPipeliner_BFReserve_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFReserve_Call) RunAndReturn(run func(context.Context, string, float64, int64) *StatusCmd) *MockPipeliner_BFReserve_Call {
	_c.Call.Return(run)
	return _c
}

// BFReserveExpansion provides a mock function with given fields: ctx, key, errorRate, capacity, expansion
func (_m *MockPipeliner) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity, expansion)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveExpansion")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity, expansion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BFReserveExpansion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFReserveExpansion'
type MockPipeliner_BFReserveExpansion_Call struct {
	*mock.Call
}

// BFReserveExpansion is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - errorRate float64
//   - capacity int64
//   - expansion int64
func (_e *MockPipeliner_Expecter) BFReserveExpansion(ctx interface{}, key interface{}, errorRate interface{}, capacity interface{}, expansion interface{}) *MockPipeliner_BFReserveExpansion_Call {
	return &MockPipeliner_BFReserveExpansion_Call{Call: _e.mock.On("BFReserveExpansion", ctx, key, errorRate, capacity, expansion)}
}

func (_c *MockPipeliner_BFReserveExpansion_Call) Run(run func(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64)) *MockPipeliner_BFReserveExpansion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(int64), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_BFReserveExpansion_Call) Return(_a0 *StatusCmd) *MockPipeliner_BFReserveExpansion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFReserveExpansion_Call) RunAndReturn(run func(context.Context, string, float64, int64, int64) *StatusCmd) *MockPipeliner_BFReserveExpansion_Call {
	_c.Call.Return(run)
	return _c
}

// BFReserveNonScaling provides a mock function with given fields: ctx, key, errorRate, capacity
func (_m *MockPipeliner) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *StatusCmd {
	ret := _m.Called(ctx, key, errorRate, capacity)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveNonScaling")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BFReserveNonScaling_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFReserveNonScaling'
type MockPipeliner_BFReserveNonScaling_Call struct {
	*mock.Call
}

// BFReserveNonScaling is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - errorRate float64
//   - capacity int64
func (_e *MockPipeliner_Expecter) BFReserveNonScaling(ctx interface{}, key interface{}, errorRate interface{}, capacity interface{}) *MockPipeliner_BFReserveNonScaling_Call {
	return &MockPipeliner_BFReserveNonScaling_Call{Call: _e.mock.On("BFReserveNonScaling", ctx, key, errorRate, capacity)}
}

func (_c *MockPipeliner_BFReserveNonScaling_Call) Run(run func(ctx context.Context, key string, errorRate float64, capacity int64)) *MockPipeliner_BFReserveNonScaling_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_BFReserveNonScaling_Call) Return(_a0 *StatusCmd) *MockPipeliner_BFReserveNonScaling_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFReserveNonScaling_Call) RunAndReturn(run func(context.Context, string, float64, int64) *StatusCmd) *MockPipeliner_BFReserveNonScaling_Call {
	_c.Call.Return(run)
	return _c
}

// BFReserveWithArgs provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) BFReserveWithArgs(ctx context.Context, key string, options *BFReserveOptions) *StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for BFReserveWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *BFReserveOptions) *StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BFReserveWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFReserveWithArgs'
type MockPipeliner_BFReserveWithArgs_Call struct {
	*mock.Call
}

// BFReserveWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *BFReserveOptions
func (_e *MockPipeliner_Expecter) BFReserveWithArgs(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_BFReserveWithArgs_Call {
	return &MockPipeliner_BFReserveWithArgs_Call{Call: _e.mock.On("BFReserveWithArgs", ctx, key, options)}
}

func (_c *MockPipeliner_BFReserveWithArgs_Call) Run(run func(ctx context.Context, key string, options *BFReserveOptions)) *MockPipeliner_BFReserveWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*BFReserveOptions))
	})
	return _c
}

func (_c *MockPipeliner_BFReserveWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_BFReserveWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFReserveWithArgs_Call) RunAndReturn(run func(context.Context, string, *BFReserveOptions) *StatusCmd) *MockPipeliner_BFReserveWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// BFScanDump provides a mock function with given fields: ctx, key, iterator
func (_m *MockPipeliner) BFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd {
	ret := _m.Called(ctx, key, iterator)

	if len(ret) == 0 {
		panic("no return value specified for BFScanDump")
	}

	var r0 *ScanDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *ScanDumpCmd); ok {
		r0 = rf(ctx, key, iterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanDumpCmd)
		}
	}

	return r0
}

// MockPipeliner_BFScanDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BFScanDump'
type MockPipeliner_BFScanDump_Call struct {
	*mock.Call
}

// BFScanDump is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - iterator int64
func (_e *MockPipeliner_Expecter) BFScanDump(ctx interface{}, key interface{}, iterator interface{}) *MockPipeliner_BFScanDump_Call {
	return &MockPipeliner_BFScanDump_Call{Call: _e.mock.On("BFScanDump", ctx, key, iterator)}
}

func (_c *MockPipeliner_BFScanDump_Call) Run(run func(ctx context.Context, key string, iterator int64)) *MockPipeliner_BFScanDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_BFScanDump_Call) Return(_a0 *ScanDumpCmd) *MockPipeliner_BFScanDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BFScanDump_Call) RunAndReturn(run func(context.Context, string, int64) *ScanDumpCmd) *MockPipeliner_BFScanDump_Call {
	_c.Call.Return(run)
	return _c
}

// BLMPop provides a mock function with given fields: ctx, timeout, direction, count, keys
func (_m *MockPipeliner) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLMPop")
	}

	var r0 *KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, int64, ...string) *KeyValuesCmd); ok {
		r0 = rf(ctx, timeout, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValuesCmd)
		}
	}

	return r0
}

// MockPipeliner_BLMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLMPop'
type MockPipeliner_BLMPop_Call struct {
	*mock.Call
}

// BLMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - direction string
//   - count int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) BLMPop(ctx interface{}, timeout interface{}, direction interface{}, count interface{}, keys ...interface{}) *MockPipeliner_BLMPop_Call {
	return &MockPipeliner_BLMPop_Call{Call: _e.mock.On("BLMPop",
		append([]interface{}{ctx, timeout, direction, count}, keys...)...)}
}

func (_c *MockPipeliner_BLMPop_Call) Run(run func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string)) *MockPipeliner_BLMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), args[2].(string), args[3].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BLMPop_Call) Return(_a0 *KeyValuesCmd) *MockPipeliner_BLMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BLMPop_Call) RunAndReturn(run func(context.Context, time.Duration, string, int64, ...string) *KeyValuesCmd) *MockPipeliner_BLMPop_Call {
	_c.Call.Return(run)
	return _c
}

// BLMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos, timeout
func (_m *MockPipeliner) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BLMove")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_BLMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLMove'
type MockPipeliner_BLMove_Call struct {
	*mock.Call
}

// BLMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
//   - timeout time.Duration
func (_e *MockPipeliner_Expecter) BLMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}, timeout interface{}) *MockPipeliner_BLMove_Call {
	return &MockPipeliner_BLMove_Call{Call: _e.mock.On("BLMove", ctx, source, destination, srcpos, destpos, timeout)}
}

func (_c *MockPipeliner_BLMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration)) *MockPipeliner_BLMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_BLMove_Call) Return(_a0 *StringCmd) *MockPipeliner_BLMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BLMove_Call) RunAndReturn(run func(context.Context, string, string, string, string, time.Duration) *StringCmd) *MockPipeliner_BLMove_Call {
	_c.Call.Return(run)
	return _c
}

// BLPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockPipeliner) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BLPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLPop'
type MockPipeliner_BLPop_Call struct {
	*mock.Call
}

// BLPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockPipeliner_Expecter) BLPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockPipeliner_BLPop_Call {
	return &MockPipeliner_BLPop_Call{Call: _e.mock.On("BLPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockPipeliner_BLPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockPipeliner_BLPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BLPop_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_BLPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BLPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *StringSliceCmd) *MockPipeliner_BLPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockPipeliner) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BRPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPop'
type MockPipeliner_BRPop_Call struct {
	*mock.Call
}

// BRPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockPipeliner_Expecter) BRPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockPipeliner_BRPop_Call {
	return &MockPipeliner_BRPop_Call{Call: _e.mock.On("BRPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockPipeliner_BRPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockPipeliner_BRPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BRPop_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_BRPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BRPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *StringSliceCmd) *MockPipeliner_BRPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPopLPush provides a mock function with given fields: ctx, source, destination, timeout
func (_m *MockPipeliner) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *StringCmd {
	ret := _m.Called(ctx, source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_BRPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPopLPush'
type MockPipeliner_BRPopLPush_Call struct {
	*mock.Call
}

// BRPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - timeout time.Duration
func (_e *MockPipeliner_Expecter) BRPopLPush(ctx interface{}, source interface{}, destination interface{}, timeout interface{}) *MockPipeliner_BRPopLPush_Call {
	return &MockPipeliner_BRPopLPush_Call{Call: _e.mock.On("BRPopLPush", ctx, source, destination, timeout)}
}

func (_c *MockPipeliner_BRPopLPush_Call) Run(run func(ctx context.Context, source string, destination string, timeout time.Duration)) *MockPipeliner_BRPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_BRPopLPush_Call) Return(_a0 *StringCmd) *MockPipeliner_BRPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BRPopLPush_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) *StringCmd) *MockPipeliner_BRPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// BZMPop provides a mock function with given fields: ctx, timeout, order, count, keys
func (_m *MockPipeliner) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *ZSliceWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, order, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZMPop")
	}

	var r0 *ZSliceWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, int64, ...string) *ZSliceWithKeyCmd); ok {
		r0 = rf(ctx, timeout, order, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceWithKeyCmd)
		}
	}

	return r0
}

// MockPipeliner_BZMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BZMPop'
type MockPipeliner_BZMPop_Call struct {
	*mock.Call
}

// BZMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - order string
//   - count int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) BZMPop(ctx interface{}, timeout interface{}, order interface{}, count interface{}, keys ...interface{}) *MockPipeliner_BZMPop_Call {
	return &MockPipeliner_BZMPop_Call{Call: _e.mock.On("BZMPop",
		append([]interface{}{ctx, timeout, order, count}, keys...)...)}
}

func (_c *MockPipeliner_BZMPop_Call) Run(run func(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string)) *MockPipeliner_BZMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), args[2].(string), args[3].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BZMPop_Call) Return(_a0 *ZSliceWithKeyCmd) *MockPipeliner_BZMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BZMPop_Call) RunAndReturn(run func(context.Context, time.Duration, string, int64, ...string) *ZSliceWithKeyCmd) *MockPipeliner_BZMPop_Call {
	_c.Call.Return(run)
	return _c
}

// BZPopMax provides a mock function with given fields: ctx, timeout, keys
func (_m *MockPipeliner) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMax")
	}

	var r0 *ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZWithKeyCmd)
		}
	}

	return r0
}

// MockPipeliner_BZPopMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BZPopMax'
type MockPipeliner_BZPopMax_Call struct {
	*mock.Call
}

// BZPopMax is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockPipeliner_Expecter) BZPopMax(ctx interface{}, timeout interface{}, keys ...interface{}) *MockPipeliner_BZPopMax_Call {
	return &MockPipeliner_BZPopMax_Call{Call: _e.mock.On("BZPopMax",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockPipeliner_BZPopMax_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockPipeliner_BZPopMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BZPopMax_Call) Return(_a0 *ZWithKeyCmd) *MockPipeliner_BZPopMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BZPopMax_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *ZWithKeyCmd) *MockPipeliner_BZPopMax_Call {
	_c.Call.Return(run)
	return _c
}

// BZPopMin provides a mock function with given fields: ctx, timeout, keys
func (_m *MockPipeliner) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMin")
	}

	var r0 *ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *ZWithKeyCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZWithKeyCmd)
		}
	}

	return r0
}

// MockPipeliner_BZPopMin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BZPopMin'
type MockPipeliner_BZPopMin_Call struct {
	*mock.Call
}

// BZPopMin is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockPipeliner_Expecter) BZPopMin(ctx interface{}, timeout interface{}, keys ...interface{}) *MockPipeliner_BZPopMin_Call {
	return &MockPipeliner_BZPopMin_Call{Call: _e.mock.On("BZPopMin",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockPipeliner_BZPopMin_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockPipeliner_BZPopMin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BZPopMin_Call) Return(_a0 *ZWithKeyCmd) *MockPipeliner_BZPopMin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BZPopMin_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *ZWithKeyCmd) *MockPipeliner_BZPopMin_Call {
	_c.Call.Return(run)
	return _c
}

// BgRewriteAOF provides a mock function with given fields: ctx
func (_m *MockPipeliner) BgRewriteAOF(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgRewriteAOF")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BgRewriteAOF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BgRewriteAOF'
type MockPipeliner_BgRewriteAOF_Call struct {
	*mock.Call
}

// BgRewriteAOF is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) BgRewriteAOF(ctx interface{}) *MockPipeliner_BgRewriteAOF_Call {
	return &MockPipeliner_BgRewriteAOF_Call{Call: _e.mock.On("BgRewriteAOF", ctx)}
}

func (_c *MockPipeliner_BgRewriteAOF_Call) Run(run func(ctx context.Context)) *MockPipeliner_BgRewriteAOF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_BgRewriteAOF_Call) Return(_a0 *StatusCmd) *MockPipeliner_BgRewriteAOF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BgRewriteAOF_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_BgRewriteAOF_Call {
	_c.Call.Return(run)
	return _c
}

// BgSave provides a mock function with given fields: ctx
func (_m *MockPipeliner) BgSave(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BgSave")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_BgSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BgSave'
type MockPipeliner_BgSave_Call struct {
	*mock.Call
}

// BgSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) BgSave(ctx interface{}) *MockPipeliner_BgSave_Call {
	return &MockPipeliner_BgSave_Call{Call: _e.mock.On("BgSave", ctx)}
}

func (_c *MockPipeliner_BgSave_Call) Run(run func(ctx context.Context)) *MockPipeliner_BgSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_BgSave_Call) Return(_a0 *StatusCmd) *MockPipeliner_BgSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BgSave_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_BgSave_Call {
	_c.Call.Return(run)
	return _c
}

// BitCount provides a mock function with given fields: ctx, key, bitCount
func (_m *MockPipeliner) BitCount(ctx context.Context, key string, bitCount *BitCount) *IntCmd {
	ret := _m.Called(ctx, key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *BitCount) *IntCmd); ok {
		r0 = rf(ctx, key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitCount'
type MockPipeliner_BitCount_Call struct {
	*mock.Call
}

// BitCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bitCount *BitCount
func (_e *MockPipeliner_Expecter) BitCount(ctx interface{}, key interface{}, bitCount interface{}) *MockPipeliner_BitCount_Call {
	return &MockPipeliner_BitCount_Call{Call: _e.mock.On("BitCount", ctx, key, bitCount)}
}

func (_c *MockPipeliner_BitCount_Call) Run(run func(ctx context.Context, key string, bitCount *BitCount)) *MockPipeliner_BitCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*BitCount))
	})
	return _c
}

func (_c *MockPipeliner_BitCount_Call) Return(_a0 *IntCmd) *MockPipeliner_BitCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitCount_Call) RunAndReturn(run func(context.Context, string, *BitCount) *IntCmd) *MockPipeliner_BitCount_Call {
	_c.Call.Return(run)
	return _c
}

// BitField provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) BitField(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitField")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BitField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitField'
type MockPipeliner_BitField_Call struct {
	*mock.Call
}

// BitField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) BitField(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_BitField_Call {
	return &MockPipeliner_BitField_Call{Call: _e.mock.On("BitField",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_BitField_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_BitField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitField_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_BitField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitField_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockPipeliner_BitField_Call {
	_c.Call.Return(run)
	return _c
}

// BitFieldRO provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) BitFieldRO(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitFieldRO")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_BitFieldRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitFieldRO'
type MockPipeliner_BitFieldRO_Call struct {
	*mock.Call
}

// BitFieldRO is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) BitFieldRO(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_BitFieldRO_Call {
	return &MockPipeliner_BitFieldRO_Call{Call: _e.mock.On("BitFieldRO",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_BitFieldRO_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_BitFieldRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitFieldRO_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_BitFieldRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitFieldRO_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockPipeliner_BitFieldRO_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpAnd provides a mock function with given fields: ctx, destKey, keys
func (_m *MockPipeliner) BitOpAnd(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitOpAnd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpAnd'
type MockPipeliner_BitOpAnd_Call struct {
	*mock.Call
}

// BitOpAnd is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockPipeliner_Expecter) BitOpAnd(ctx interface{}, destKey interface{}, keys ...interface{}) *MockPipeliner_BitOpAnd_Call {
	return &MockPipeliner_BitOpAnd_Call{Call: _e.mock.On("BitOpAnd",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockPipeliner_BitOpAnd_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockPipeliner_BitOpAnd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitOpAnd_Call) Return(_a0 *IntCmd) *MockPipeliner_BitOpAnd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitOpAnd_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_BitOpAnd_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpNot provides a mock function with given fields: ctx, destKey, key
func (_m *MockPipeliner) BitOpNot(ctx context.Context, destKey string, key string) *IntCmd {
	ret := _m.Called(ctx, destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitOpNot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpNot'
type MockPipeliner_BitOpNot_Call struct {
	*mock.Call
}

// BitOpNot is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - key string
func (_e *MockPipeliner_Expecter) BitOpNot(ctx interface{}, destKey interface{}, key interface{}) *MockPipeliner_BitOpNot_Call {
	return &MockPipeliner_BitOpNot_Call{Call: _e.mock.On("BitOpNot", ctx, destKey, key)}
}

func (_c *MockPipeliner_BitOpNot_Call) Run(run func(ctx context.Context, destKey string, key string)) *MockPipeliner_BitOpNot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_BitOpNot_Call) Return(_a0 *IntCmd) *MockPipeliner_BitOpNot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitOpNot_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_BitOpNot_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpOr provides a mock function with given fields: ctx, destKey, keys
func (_m *MockPipeliner) BitOpOr(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitOpOr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpOr'
type MockPipeliner_BitOpOr_Call struct {
	*mock.Call
}

// BitOpOr is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockPipeliner_Expecter) BitOpOr(ctx interface{}, destKey interface{}, keys ...interface{}) *MockPipeliner_BitOpOr_Call {
	return &MockPipeliner_BitOpOr_Call{Call: _e.mock.On("BitOpOr",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockPipeliner_BitOpOr_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockPipeliner_BitOpOr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitOpOr_Call) Return(_a0 *IntCmd) *MockPipeliner_BitOpOr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitOpOr_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_BitOpOr_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpXor provides a mock function with given fields: ctx, destKey, keys
func (_m *MockPipeliner) BitOpXor(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitOpXor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpXor'
type MockPipeliner_BitOpXor_Call struct {
	*mock.Call
}

// BitOpXor is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockPipeliner_Expecter) BitOpXor(ctx interface{}, destKey interface{}, keys ...interface{}) *MockPipeliner_BitOpXor_Call {
	return &MockPipeliner_BitOpXor_Call{Call: _e.mock.On("BitOpXor",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockPipeliner_BitOpXor_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockPipeliner_BitOpXor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitOpXor_Call) Return(_a0 *IntCmd) *MockPipeliner_BitOpXor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitOpXor_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_BitOpXor_Call {
	_c.Call.Return(run)
	return _c
}

// BitPos provides a mock function with given fields: ctx, key, bit, pos
func (_m *MockPipeliner) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...int64) *IntCmd); ok {
		r0 = rf(ctx, key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitPos'
type MockPipeliner_BitPos_Call struct {
	*mock.Call
}

// BitPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bit int64
//   - pos ...int64
func (_e *MockPipeliner_Expecter) BitPos(ctx interface{}, key interface{}, bit interface{}, pos ...interface{}) *MockPipeliner_BitPos_Call {
	return &MockPipeliner_BitPos_Call{Call: _e.mock.On("BitPos",
		append([]interface{}{ctx, key, bit}, pos...)...)}
}

func (_c *MockPipeliner_BitPos_Call) Run(run func(ctx context.Context, key string, bit int64, pos ...int64)) *MockPipeliner_BitPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_BitPos_Call) Return(_a0 *IntCmd) *MockPipeliner_BitPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitPos_Call) RunAndReturn(run func(context.Context, string, int64, ...int64) *IntCmd) *MockPipeliner_BitPos_Call {
	_c.Call.Return(run)
	return _c
}

// BitPosSpan provides a mock function with given fields: ctx, key, bit, start, end, span
func (_m *MockPipeliner) BitPosSpan(ctx context.Context, key string, bit int8, start int64, end int64, span string) *IntCmd {
	ret := _m.Called(ctx, key, bit, start, end, span)

	if len(ret) == 0 {
		panic("no return value specified for BitPosSpan")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int8, int64, int64, string) *IntCmd); ok {
		r0 = rf(ctx, key, bit, start, end, span)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_BitPosSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitPosSpan'
type MockPipeliner_BitPosSpan_Call struct {
	*mock.Call
}

// BitPosSpan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bit int8
//   - start int64
//   - end int64
//   - span string
func (_e *MockPipeliner_Expecter) BitPosSpan(ctx interface{}, key interface{}, bit interface{}, start interface{}, end interface{}, span interface{}) *MockPipeliner_BitPosSpan_Call {
	return &MockPipeliner_BitPosSpan_Call{Call: _e.mock.On("BitPosSpan", ctx, key, bit, start, end, span)}
}

func (_c *MockPipeliner_BitPosSpan_Call) Run(run func(ctx context.Context, key string, bit int8, start int64, end int64, span string)) *MockPipeliner_BitPosSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int8), args[3].(int64), args[4].(int64), args[5].(string))
	})
	return _c
}

func (_c *MockPipeliner_BitPosSpan_Call) Return(_a0 *IntCmd) *MockPipeliner_BitPosSpan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_BitPosSpan_Call) RunAndReturn(run func(context.Context, string, int8, int64, int64, string) *IntCmd) *MockPipeliner_BitPosSpan_Call {
	_c.Call.Return(run)
	return _c
}

// CFAdd provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) CFAdd(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFAdd")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_CFAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFAdd'
type MockPipeliner_CFAdd_Call struct {
	*mock.Call
}

// CFAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) CFAdd(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_CFAdd_Call {
	return &MockPipeliner_CFAdd_Call{Call: _e.mock.On("CFAdd", ctx, key, element)}
}

func (_c *MockPipeliner_CFAdd_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_CFAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFAdd_Call) Return(_a0 *BoolCmd) *MockPipeliner_CFAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFAdd_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_CFAdd_Call {
	_c.Call.Return(run)
	return _c
}

// CFAddNX provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) CFAddNX(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFAddNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_CFAddNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFAddNX'
type MockPipeliner_CFAddNX_Call struct {
	*mock.Call
}

// CFAddNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) CFAddNX(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_CFAddNX_Call {
	return &MockPipeliner_CFAddNX_Call{Call: _e.mock.On("CFAddNX", ctx, key, element)}
}

func (_c *MockPipeliner_CFAddNX_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_CFAddNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFAddNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_CFAddNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFAddNX_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_CFAddNX_Call {
	_c.Call.Return(run)
	return _c
}

// CFCount provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) CFCount(ctx context.Context, key string, element interface{}) *IntCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_CFCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFCount'
type MockPipeliner_CFCount_Call struct {
	*mock.Call
}

// CFCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) CFCount(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_CFCount_Call {
	return &MockPipeliner_CFCount_Call{Call: _e.mock.On("CFCount", ctx, key, element)}
}

func (_c *MockPipeliner_CFCount_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_CFCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFCount_Call) Return(_a0 *IntCmd) *MockPipeliner_CFCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFCount_Call) RunAndReturn(run func(context.Context, string, interface{}) *IntCmd) *MockPipeliner_CFCount_Call {
	_c.Call.Return(run)
	return _c
}

// CFDel provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) CFDel(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFDel")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_CFDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFDel'
type MockPipeliner_CFDel_Call struct {
	*mock.Call
}

// CFDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) CFDel(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_CFDel_Call {
	return &MockPipeliner_CFDel_Call{Call: _e.mock.On("CFDel", ctx, key, element)}
}

func (_c *MockPipeliner_CFDel_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_CFDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFDel_Call) Return(_a0 *BoolCmd) *MockPipeliner_CFDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFDel_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_CFDel_Call {
	_c.Call.Return(run)
	return _c
}

// CFExists provides a mock function with given fields: ctx, key, element
func (_m *MockPipeliner) CFExists(ctx context.Context, key string, element interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, element)

	if len(ret) == 0 {
		panic("no return value specified for CFExists")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, element)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_CFExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFExists'
type MockPipeliner_CFExists_Call struct {
	*mock.Call
}

// CFExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - element interface{}
func (_e *MockPipeliner_Expecter) CFExists(ctx interface{}, key interface{}, element interface{}) *MockPipeliner_CFExists_Call {
	return &MockPipeliner_CFExists_Call{Call: _e.mock.On("CFExists", ctx, key, element)}
}

func (_c *MockPipeliner_CFExists_Call) Run(run func(ctx context.Context, key string, element interface{})) *MockPipeliner_CFExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFExists_Call) Return(_a0 *BoolCmd) *MockPipeliner_CFExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFExists_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_CFExists_Call {
	_c.Call.Return(run)
	return _c
}

// CFInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) CFInfo(ctx context.Context, key string) *CFInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for CFInfo")
	}

	var r0 *CFInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *CFInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CFInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_CFInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFInfo'
type MockPipeliner_CFInfo_Call struct {
	*mock.Call
}

// CFInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) CFInfo(ctx interface{}, key interface{}) *MockPipeliner_CFInfo_Call {
	return &MockPipeliner_CFInfo_Call{Call: _e.mock.On("CFInfo", ctx, key)}
}

func (_c *MockPipeliner_CFInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_CFInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_CFInfo_Call) Return(_a0 *CFInfoCmd) *MockPipeliner_CFInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFInfo_Call) RunAndReturn(run func(context.Context, string) *CFInfoCmd) *MockPipeliner_CFInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CFInsert provides a mock function with given fields: ctx, key, options, elements
func (_m *MockPipeliner) CFInsert(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFInsert")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *CFInsertOptions, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CFInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFInsert'
type MockPipeliner_CFInsert_Call struct {
	*mock.Call
}

// CFInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *CFInsertOptions
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) CFInsert(ctx interface{}, key interface{}, options interface{}, elements ...interface{}) *MockPipeliner_CFInsert_Call {
	return &MockPipeliner_CFInsert_Call{Call: _e.mock.On("CFInsert",
		append([]interface{}{ctx, key, options}, elements...)...)}
}

func (_c *MockPipeliner_CFInsert_Call) Run(run func(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{})) *MockPipeliner_CFInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*CFInsertOptions), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CFInsert_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_CFInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFInsert_Call) RunAndReturn(run func(context.Context, string, *CFInsertOptions, ...interface{}) *BoolSliceCmd) *MockPipeliner_CFInsert_Call {
	_c.Call.Return(run)
	return _c
}

// CFInsertNX provides a mock function with given fields: ctx, key, options, elements
func (_m *MockPipeliner) CFInsertNX(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFInsertNX")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *CFInsertOptions, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, options, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CFInsertNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFInsertNX'
type MockPipeliner_CFInsertNX_Call struct {
	*mock.Call
}

// CFInsertNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *CFInsertOptions
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) CFInsertNX(ctx interface{}, key interface{}, options interface{}, elements ...interface{}) *MockPipeliner_CFInsertNX_Call {
	return &MockPipeliner_CFInsertNX_Call{Call: _e.mock.On("CFInsertNX",
		append([]interface{}{ctx, key, options}, elements...)...)}
}

func (_c *MockPipeliner_CFInsertNX_Call) Run(run func(ctx context.Context, key string, options *CFInsertOptions, elements ...interface{})) *MockPipeliner_CFInsertNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*CFInsertOptions), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CFInsertNX_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_CFInsertNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFInsertNX_Call) RunAndReturn(run func(context.Context, string, *CFInsertOptions, ...interface{}) *IntSliceCmd) *MockPipeliner_CFInsertNX_Call {
	_c.Call.Return(run)
	return _c
}

// CFLoadChunk provides a mock function with given fields: ctx, key, iterator, data
func (_m *MockPipeliner) CFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *StatusCmd {
	ret := _m.Called(ctx, key, iterator, data)

	if len(ret) == 0 {
		panic("no return value specified for CFLoadChunk")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, key, iterator, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFLoadChunk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFLoadChunk'
type MockPipeliner_CFLoadChunk_Call struct {
	*mock.Call
}

// CFLoadChunk is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - iterator int64
//   - data interface{}
func (_e *MockPipeliner_Expecter) CFLoadChunk(ctx interface{}, key interface{}, iterator interface{}, data interface{}) *MockPipeliner_CFLoadChunk_Call {
	return &MockPipeliner_CFLoadChunk_Call{Call: _e.mock.On("CFLoadChunk", ctx, key, iterator, data)}
}

func (_c *MockPipeliner_CFLoadChunk_Call) Run(run func(ctx context.Context, key string, iterator int64, data interface{})) *MockPipeliner_CFLoadChunk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_CFLoadChunk_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFLoadChunk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFLoadChunk_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *StatusCmd) *MockPipeliner_CFLoadChunk_Call {
	_c.Call.Return(run)
	return _c
}

// CFMExists provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) CFMExists(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CFMExists")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CFMExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFMExists'
type MockPipeliner_CFMExists_Call struct {
	*mock.Call
}

// CFMExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) CFMExists(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_CFMExists_Call {
	return &MockPipeliner_CFMExists_Call{Call: _e.mock.On("CFMExists",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_CFMExists_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_CFMExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CFMExists_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_CFMExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFMExists_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolSliceCmd) *MockPipeliner_CFMExists_Call {
	_c.Call.Return(run)
	return _c
}

// CFReserve provides a mock function with given fields: ctx, key, capacity
func (_m *MockPipeliner) CFReserve(ctx context.Context, key string, capacity int64) *StatusCmd {
	ret := _m.Called(ctx, key, capacity)

	if len(ret) == 0 {
		panic("no return value specified for CFReserve")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, capacity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFReserve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFReserve'
type MockPipeliner_CFReserve_Call struct {
	*mock.Call
}

// CFReserve is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - capacity int64
func (_e *MockPipeliner_Expecter) CFReserve(ctx interface{}, key interface{}, capacity interface{}) *MockPipeliner_CFReserve_Call {
	return &MockPipeliner_CFReserve_Call{Call: _e.mock.On("CFReserve", ctx, key, capacity)}
}

func (_c *MockPipeliner_CFReserve_Call) Run(run func(ctx context.Context, key string, capacity int64)) *MockPipeliner_CFReserve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CFReserve_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFReserve_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFReserve_Call) RunAndReturn(run func(context.Context, string, int64) *StatusCmd) *MockPipeliner_CFReserve_Call {
	_c.Call.Return(run)
	return _c
}

// CFReserveBucketSize provides a mock function with given fields: ctx, key, capacity, bucketsize
func (_m *MockPipeliner) CFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *StatusCmd {
	ret := _m.Called(ctx, key, capacity, bucketsize)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveBucketSize")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, capacity, bucketsize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFReserveBucketSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFReserveBucketSize'
type MockPipeliner_CFReserveBucketSize_Call struct {
	*mock.Call
}

// CFReserveBucketSize is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - capacity int64
//   - bucketsize int64
func (_e *MockPipeliner_Expecter) CFReserveBucketSize(ctx interface{}, key interface{}, capacity interface{}, bucketsize interface{}) *MockPipeliner_CFReserveBucketSize_Call {
	return &MockPipeliner_CFReserveBucketSize_Call{Call: _e.mock.On("CFReserveBucketSize", ctx, key, capacity, bucketsize)}
}

func (_c *MockPipeliner_CFReserveBucketSize_Call) Run(run func(ctx context.Context, key string, capacity int64, bucketsize int64)) *MockPipeliner_CFReserveBucketSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CFReserveBucketSize_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFReserveBucketSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFReserveBucketSize_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockPipeliner_CFReserveBucketSize_Call {
	_c.Call.Return(run)
	return _c
}

// CFReserveExpansion provides a mock function with given fields: ctx, key, capacity, expansion
func (_m *MockPipeliner) CFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *StatusCmd {
	ret := _m.Called(ctx, key, capacity, expansion)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveExpansion")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, capacity, expansion)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFReserveExpansion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFReserveExpansion'
type MockPipeliner_CFReserveExpansion_Call struct {
	*mock.Call
}

// CFReserveExpansion is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - capacity int64
//   - expansion int64
func (_e *MockPipeliner_Expecter) CFReserveExpansion(ctx interface{}, key interface{}, capacity interface{}, expansion interface{}) *MockPipeliner_CFReserveExpansion_Call {
	return &MockPipeliner_CFReserveExpansion_Call{Call: _e.mock.On("CFReserveExpansion", ctx, key, capacity, expansion)}
}

func (_c *MockPipeliner_CFReserveExpansion_Call) Run(run func(ctx context.Context, key string, capacity int64, expansion int64)) *MockPipeliner_CFReserveExpansion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CFReserveExpansion_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFReserveExpansion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFReserveExpansion_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockPipeliner_CFReserveExpansion_Call {
	_c.Call.Return(run)
	return _c
}

// CFReserveMaxIterations provides a mock function with given fields: ctx, key, capacity, maxiterations
func (_m *MockPipeliner) CFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *StatusCmd {
	ret := _m.Called(ctx, key, capacity, maxiterations)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveMaxIterations")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, capacity, maxiterations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFReserveMaxIterations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFReserveMaxIterations'
type MockPipeliner_CFReserveMaxIterations_Call struct {
	*mock.Call
}

// CFReserveMaxIterations is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - capacity int64
//   - maxiterations int64
func (_e *MockPipeliner_Expecter) CFReserveMaxIterations(ctx interface{}, key interface{}, capacity interface{}, maxiterations interface{}) *MockPipeliner_CFReserveMaxIterations_Call {
	return &MockPipeliner_CFReserveMaxIterations_Call{Call: _e.mock.On("CFReserveMaxIterations", ctx, key, capacity, maxiterations)}
}

func (_c *MockPipeliner_CFReserveMaxIterations_Call) Run(run func(ctx context.Context, key string, capacity int64, maxiterations int64)) *MockPipeliner_CFReserveMaxIterations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CFReserveMaxIterations_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFReserveMaxIterations_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFReserveMaxIterations_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockPipeliner_CFReserveMaxIterations_Call {
	_c.Call.Return(run)
	return _c
}

// CFReserveWithArgs provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) CFReserveWithArgs(ctx context.Context, key string, options *CFReserveOptions) *StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for CFReserveWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *CFReserveOptions) *StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CFReserveWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFReserveWithArgs'
type MockPipeliner_CFReserveWithArgs_Call struct {
	*mock.Call
}

// CFReserveWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *CFReserveOptions
func (_e *MockPipeliner_Expecter) CFReserveWithArgs(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_CFReserveWithArgs_Call {
	return &MockPipeliner_CFReserveWithArgs_Call{Call: _e.mock.On("CFReserveWithArgs", ctx, key, options)}
}

func (_c *MockPipeliner_CFReserveWithArgs_Call) Run(run func(ctx context.Context, key string, options *CFReserveOptions)) *MockPipeliner_CFReserveWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*CFReserveOptions))
	})
	return _c
}

func (_c *MockPipeliner_CFReserveWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_CFReserveWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFReserveWithArgs_Call) RunAndReturn(run func(context.Context, string, *CFReserveOptions) *StatusCmd) *MockPipeliner_CFReserveWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// CFScanDump provides a mock function with given fields: ctx, key, iterator
func (_m *MockPipeliner) CFScanDump(ctx context.Context, key string, iterator int64) *ScanDumpCmd {
	ret := _m.Called(ctx, key, iterator)

	if len(ret) == 0 {
		panic("no return value specified for CFScanDump")
	}

	var r0 *ScanDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *ScanDumpCmd); ok {
		r0 = rf(ctx, key, iterator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanDumpCmd)
		}
	}

	return r0
}

// MockPipeliner_CFScanDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CFScanDump'
type MockPipeliner_CFScanDump_Call struct {
	*mock.Call
}

// CFScanDump is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - iterator int64
func (_e *MockPipeliner_Expecter) CFScanDump(ctx interface{}, key interface{}, iterator interface{}) *MockPipeliner_CFScanDump_Call {
	return &MockPipeliner_CFScanDump_Call{Call: _e.mock.On("CFScanDump", ctx, key, iterator)}
}

func (_c *MockPipeliner_CFScanDump_Call) Run(run func(ctx context.Context, key string, iterator int64)) *MockPipeliner_CFScanDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CFScanDump_Call) Return(_a0 *ScanDumpCmd) *MockPipeliner_CFScanDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CFScanDump_Call) RunAndReturn(run func(context.Context, string, int64) *ScanDumpCmd) *MockPipeliner_CFScanDump_Call {
	_c.Call.Return(run)
	return _c
}

// CMSIncrBy provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) CMSIncrBy(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSIncrBy")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSIncrBy'
type MockPipeliner_CMSIncrBy_Call struct {
	*mock.Call
}

// CMSIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) CMSIncrBy(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_CMSIncrBy_Call {
	return &MockPipeliner_CMSIncrBy_Call{Call: _e.mock.On("CMSIncrBy",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_CMSIncrBy_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_CMSIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CMSIncrBy_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_CMSIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSIncrBy_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockPipeliner_CMSIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// CMSInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) CMSInfo(ctx context.Context, key string) *CMSInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for CMSInfo")
	}

	var r0 *CMSInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *CMSInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CMSInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSInfo'
type MockPipeliner_CMSInfo_Call struct {
	*mock.Call
}

// CMSInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) CMSInfo(ctx interface{}, key interface{}) *MockPipeliner_CMSInfo_Call {
	return &MockPipeliner_CMSInfo_Call{Call: _e.mock.On("CMSInfo", ctx, key)}
}

func (_c *MockPipeliner_CMSInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_CMSInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_CMSInfo_Call) Return(_a0 *CMSInfoCmd) *MockPipeliner_CMSInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSInfo_Call) RunAndReturn(run func(context.Context, string) *CMSInfoCmd) *MockPipeliner_CMSInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CMSInitByDim provides a mock function with given fields: ctx, key, width, height
func (_m *MockPipeliner) CMSInitByDim(ctx context.Context, key string, width int64, height int64) *StatusCmd {
	ret := _m.Called(ctx, key, width, height)

	if len(ret) == 0 {
		panic("no return value specified for CMSInitByDim")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, width, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSInitByDim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSInitByDim'
type MockPipeliner_CMSInitByDim_Call struct {
	*mock.Call
}

// CMSInitByDim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - width int64
//   - height int64
func (_e *MockPipeliner_Expecter) CMSInitByDim(ctx interface{}, key interface{}, width interface{}, height interface{}) *MockPipeliner_CMSInitByDim_Call {
	return &MockPipeliner_CMSInitByDim_Call{Call: _e.mock.On("CMSInitByDim", ctx, key, width, height)}
}

func (_c *MockPipeliner_CMSInitByDim_Call) Run(run func(ctx context.Context, key string, width int64, height int64)) *MockPipeliner_CMSInitByDim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_CMSInitByDim_Call) Return(_a0 *StatusCmd) *MockPipeliner_CMSInitByDim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSInitByDim_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockPipeliner_CMSInitByDim_Call {
	_c.Call.Return(run)
	return _c
}

// CMSInitByProb provides a mock function with given fields: ctx, key, errorRate, probability
func (_m *MockPipeliner) CMSInitByProb(ctx context.Context, key string, errorRate float64, probability float64) *StatusCmd {
	ret := _m.Called(ctx, key, errorRate, probability)

	if len(ret) == 0 {
		panic("no return value specified for CMSInitByProb")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64) *StatusCmd); ok {
		r0 = rf(ctx, key, errorRate, probability)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSInitByProb_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSInitByProb'
type MockPipeliner_CMSInitByProb_Call struct {
	*mock.Call
}

// CMSInitByProb is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - errorRate float64
//   - probability float64
func (_e *MockPipeliner_Expecter) CMSInitByProb(ctx interface{}, key interface{}, errorRate interface{}, probability interface{}) *MockPipeliner_CMSInitByProb_Call {
	return &MockPipeliner_CMSInitByProb_Call{Call: _e.mock.On("CMSInitByProb", ctx, key, errorRate, probability)}
}

func (_c *MockPipeliner_CMSInitByProb_Call) Run(run func(ctx context.Context, key string, errorRate float64, probability float64)) *MockPipeliner_CMSInitByProb_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64))
	})
	return _c
}

func (_c *MockPipeliner_CMSInitByProb_Call) Return(_a0 *StatusCmd) *MockPipeliner_CMSInitByProb_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSInitByProb_Call) RunAndReturn(run func(context.Context, string, float64, float64) *StatusCmd) *MockPipeliner_CMSInitByProb_Call {
	_c.Call.Return(run)
	return _c
}

// CMSMerge provides a mock function with given fields: ctx, destKey, sourceKeys
func (_m *MockPipeliner) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *StatusCmd {
	_va := make([]interface{}, len(sourceKeys))
	for _i := range sourceKeys {
		_va[_i] = sourceKeys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSMerge")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StatusCmd); ok {
		r0 = rf(ctx, destKey, sourceKeys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSMerge'
type MockPipeliner_CMSMerge_Call struct {
	*mock.Call
}

// CMSMerge is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - sourceKeys ...string
func (_e *MockPipeliner_Expecter) CMSMerge(ctx interface{}, destKey interface{}, sourceKeys ...interface{}) *MockPipeliner_CMSMerge_Call {
	return &MockPipeliner_CMSMerge_Call{Call: _e.mock.On("CMSMerge",
		append([]interface{}{ctx, destKey}, sourceKeys...)...)}
}

func (_c *MockPipeliner_CMSMerge_Call) Run(run func(ctx context.Context, destKey string, sourceKeys ...string)) *MockPipeliner_CMSMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CMSMerge_Call) Return(_a0 *StatusCmd) *MockPipeliner_CMSMerge_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSMerge_Call) RunAndReturn(run func(context.Context, string, ...string) *StatusCmd) *MockPipeliner_CMSMerge_Call {
	_c.Call.Return(run)
	return _c
}

// CMSMergeWithWeight provides a mock function with given fields: ctx, destKey, sourceKeys
func (_m *MockPipeliner) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *StatusCmd {
	ret := _m.Called(ctx, destKey, sourceKeys)

	if len(ret) == 0 {
		panic("no return value specified for CMSMergeWithWeight")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]int64) *StatusCmd); ok {
		r0 = rf(ctx, destKey, sourceKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSMergeWithWeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSMergeWithWeight'
type MockPipeliner_CMSMergeWithWeight_Call struct {
	*mock.Call
}

// CMSMergeWithWeight is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - sourceKeys map[string]int64
func (_e *MockPipeliner_Expecter) CMSMergeWithWeight(ctx interface{}, destKey interface{}, sourceKeys interface{}) *MockPipeliner_CMSMergeWithWeight_Call {
	return &MockPipeliner_CMSMergeWithWeight_Call{Call: _e.mock.On("CMSMergeWithWeight", ctx, destKey, sourceKeys)}
}

func (_c *MockPipeliner_CMSMergeWithWeight_Call) Run(run func(ctx context.Context, destKey string, sourceKeys map[string]int64)) *MockPipeliner_CMSMergeWithWeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]int64))
	})
	return _c
}

func (_c *MockPipeliner_CMSMergeWithWeight_Call) Return(_a0 *StatusCmd) *MockPipeliner_CMSMergeWithWeight_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSMergeWithWeight_Call) RunAndReturn(run func(context.Context, string, map[string]int64) *StatusCmd) *MockPipeliner_CMSMergeWithWeight_Call {
	_c.Call.Return(run)
	return _c
}

// CMSQuery provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) CMSQuery(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CMSQuery")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CMSQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CMSQuery'
type MockPipeliner_CMSQuery_Call struct {
	*mock.Call
}

// CMSQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) CMSQuery(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_CMSQuery_Call {
	return &MockPipeliner_CMSQuery_Call{Call: _e.mock.On("CMSQuery",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_CMSQuery_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_CMSQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CMSQuery_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_CMSQuery_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CMSQuery_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockPipeliner_CMSQuery_Call {
	_c.Call.Return(run)
	return _c
}

// ClientGetName provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClientGetName(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientGetName")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientGetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientGetName'
type MockPipeliner_ClientGetName_Call struct {
	*mock.Call
}

// ClientGetName is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClientGetName(ctx interface{}) *MockPipeliner_ClientGetName_Call {
	return &MockPipeliner_ClientGetName_Call{Call: _e.mock.On("ClientGetName", ctx)}
}

func (_c *MockPipeliner_ClientGetName_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClientGetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClientGetName_Call) Return(_a0 *StringCmd) *MockPipeliner_ClientGetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientGetName_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClientGetName_Call {
	_c.Call.Return(run)
	return _c
}

// ClientID provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClientID(ctx context.Context) *IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientID")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientID'
type MockPipeliner_ClientID_Call struct {
	*mock.Call
}

// ClientID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClientID(ctx interface{}) *MockPipeliner_ClientID_Call {
	return &MockPipeliner_ClientID_Call{Call: _e.mock.On("ClientID", ctx)}
}

func (_c *MockPipeliner_ClientID_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClientID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClientID_Call) Return(_a0 *IntCmd) *MockPipeliner_ClientID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientID_Call) RunAndReturn(run func(context.Context) *IntCmd) *MockPipeliner_ClientID_Call {
	_c.Call.Return(run)
	return _c
}

// ClientInfo provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClientInfo(ctx context.Context) *ClientInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientInfo")
	}

	var r0 *ClientInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *ClientInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ClientInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientInfo'
type MockPipeliner_ClientInfo_Call struct {
	*mock.Call
}

// ClientInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClientInfo(ctx interface{}) *MockPipeliner_ClientInfo_Call {
	return &MockPipeliner_ClientInfo_Call{Call: _e.mock.On("ClientInfo", ctx)}
}

func (_c *MockPipeliner_ClientInfo_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClientInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClientInfo_Call) Return(_a0 *ClientInfoCmd) *MockPipeliner_ClientInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientInfo_Call) RunAndReturn(run func(context.Context) *ClientInfoCmd) *MockPipeliner_ClientInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ClientKill provides a mock function with given fields: ctx, ipPort
func (_m *MockPipeliner) ClientKill(ctx context.Context, ipPort string) *StatusCmd {
	ret := _m.Called(ctx, ipPort)

	if len(ret) == 0 {
		panic("no return value specified for ClientKill")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientKill'
type MockPipeliner_ClientKill_Call struct {
	*mock.Call
}

// ClientKill is a helper method to define mock.On call
//   - ctx context.Context
//   - ipPort string
func (_e *MockPipeliner_Expecter) ClientKill(ctx interface{}, ipPort interface{}) *MockPipeliner_ClientKill_Call {
	return &MockPipeliner_ClientKill_Call{Call: _e.mock.On("ClientKill", ctx, ipPort)}
}

func (_c *MockPipeliner_ClientKill_Call) Run(run func(ctx context.Context, ipPort string)) *MockPipeliner_ClientKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClientKill_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClientKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientKill_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_ClientKill_Call {
	_c.Call.Return(run)
	return _c
}

// ClientKillByFilter provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) ClientKillByFilter(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientKillByFilter")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientKillByFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientKillByFilter'
type MockPipeliner_ClientKillByFilter_Call struct {
	*mock.Call
}

// ClientKillByFilter is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) ClientKillByFilter(ctx interface{}, keys ...interface{}) *MockPipeliner_ClientKillByFilter_Call {
	return &MockPipeliner_ClientKillByFilter_Call{Call: _e.mock.On("ClientKillByFilter",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_ClientKillByFilter_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_ClientKillByFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ClientKillByFilter_Call) Return(_a0 *IntCmd) *MockPipeliner_ClientKillByFilter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientKillByFilter_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_ClientKillByFilter_Call {
	_c.Call.Return(run)
	return _c
}

// ClientList provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClientList(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientList")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientList'
type MockPipeliner_ClientList_Call struct {
	*mock.Call
}

// ClientList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClientList(ctx interface{}) *MockPipeliner_ClientList_Call {
	return &MockPipeliner_ClientList_Call{Call: _e.mock.On("ClientList", ctx)}
}

func (_c *MockPipeliner_ClientList_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClientList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClientList_Call) Return(_a0 *StringCmd) *MockPipeliner_ClientList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientList_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClientList_Call {
	_c.Call.Return(run)
	return _c
}

// ClientPause provides a mock function with given fields: ctx, dur
func (_m *MockPipeliner) ClientPause(ctx context.Context, dur time.Duration) *BoolCmd {
	ret := _m.Called(ctx, dur)

	if len(ret) == 0 {
		panic("no return value specified for ClientPause")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientPause_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientPause'
type MockPipeliner_ClientPause_Call struct {
	*mock.Call
}

// ClientPause is a helper method to define mock.On call
//   - ctx context.Context
//   - dur time.Duration
func (_e *MockPipeliner_Expecter) ClientPause(ctx interface{}, dur interface{}) *MockPipeliner_ClientPause_Call {
	return &MockPipeliner_ClientPause_Call{Call: _e.mock.On("ClientPause", ctx, dur)}
}

func (_c *MockPipeliner_ClientPause_Call) Run(run func(ctx context.Context, dur time.Duration)) *MockPipeliner_ClientPause_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_ClientPause_Call) Return(_a0 *BoolCmd) *MockPipeliner_ClientPause_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientPause_Call) RunAndReturn(run func(context.Context, time.Duration) *BoolCmd) *MockPipeliner_ClientPause_Call {
	_c.Call.Return(run)
	return _c
}

// ClientSetInfo provides a mock function with given fields: ctx, info
func (_m *MockPipeliner) ClientSetInfo(ctx context.Context, info LibraryInfo) *StatusCmd {
	ret := _m.Called(ctx, info)

	if len(ret) == 0 {
		panic("no return value specified for ClientSetInfo")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, LibraryInfo) *StatusCmd); ok {
		r0 = rf(ctx, info)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientSetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientSetInfo'
type MockPipeliner_ClientSetInfo_Call struct {
	*mock.Call
}

// ClientSetInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - info LibraryInfo
func (_e *MockPipeliner_Expecter) ClientSetInfo(ctx interface{}, info interface{}) *MockPipeliner_ClientSetInfo_Call {
	return &MockPipeliner_ClientSetInfo_Call{Call: _e.mock.On("ClientSetInfo", ctx, info)}
}

func (_c *MockPipeliner_ClientSetInfo_Call) Run(run func(ctx context.Context, info LibraryInfo)) *MockPipeliner_ClientSetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(LibraryInfo))
	})
	return _c
}

func (_c *MockPipeliner_ClientSetInfo_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClientSetInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientSetInfo_Call) RunAndReturn(run func(context.Context, LibraryInfo) *StatusCmd) *MockPipeliner_ClientSetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ClientSetName provides a mock function with given fields: ctx, name
func (_m *MockPipeliner) ClientSetName(ctx context.Context, name string) *BoolCmd {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for ClientSetName")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BoolCmd); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientSetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientSetName'
type MockPipeliner_ClientSetName_Call struct {
	*mock.Call
}

// ClientSetName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockPipeliner_Expecter) ClientSetName(ctx interface{}, name interface{}) *MockPipeliner_ClientSetName_Call {
	return &MockPipeliner_ClientSetName_Call{Call: _e.mock.On("ClientSetName", ctx, name)}
}

func (_c *MockPipeliner_ClientSetName_Call) Run(run func(ctx context.Context, name string)) *MockPipeliner_ClientSetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClientSetName_Call) Return(_a0 *BoolCmd) *MockPipeliner_ClientSetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientSetName_Call) RunAndReturn(run func(context.Context, string) *BoolCmd) *MockPipeliner_ClientSetName_Call {
	_c.Call.Return(run)
	return _c
}

// ClientUnblock provides a mock function with given fields: ctx, id
func (_m *MockPipeliner) ClientUnblock(ctx context.Context, id int64) *IntCmd {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnblock")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *IntCmd); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientUnblock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientUnblock'
type MockPipeliner_ClientUnblock_Call struct {
	*mock.Call
}

// ClientUnblock is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockPipeliner_Expecter) ClientUnblock(ctx interface{}, id interface{}) *MockPipeliner_ClientUnblock_Call {
	return &MockPipeliner_ClientUnblock_Call{Call: _e.mock.On("ClientUnblock", ctx, id)}
}

func (_c *MockPipeliner_ClientUnblock_Call) Run(run func(ctx context.Context, id int64)) *MockPipeliner_ClientUnblock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ClientUnblock_Call) Return(_a0 *IntCmd) *MockPipeliner_ClientUnblock_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientUnblock_Call) RunAndReturn(run func(context.Context, int64) *IntCmd) *MockPipeliner_ClientUnblock_Call {
	_c.Call.Return(run)
	return _c
}

// ClientUnblockWithError provides a mock function with given fields: ctx, id
func (_m *MockPipeliner) ClientUnblockWithError(ctx context.Context, id int64) *IntCmd {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnblockWithError")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *IntCmd); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientUnblockWithError_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientUnblockWithError'
type MockPipeliner_ClientUnblockWithError_Call struct {
	*mock.Call
}

// ClientUnblockWithError is a helper method to define mock.On call
//   - ctx context.Context
//   - id int64
func (_e *MockPipeliner_Expecter) ClientUnblockWithError(ctx interface{}, id interface{}) *MockPipeliner_ClientUnblockWithError_Call {
	return &MockPipeliner_ClientUnblockWithError_Call{Call: _e.mock.On("ClientUnblockWithError", ctx, id)}
}

func (_c *MockPipeliner_ClientUnblockWithError_Call) Run(run func(ctx context.Context, id int64)) *MockPipeliner_ClientUnblockWithError_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ClientUnblockWithError_Call) Return(_a0 *IntCmd) *MockPipeliner_ClientUnblockWithError_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientUnblockWithError_Call) RunAndReturn(run func(context.Context, int64) *IntCmd) *MockPipeliner_ClientUnblockWithError_Call {
	_c.Call.Return(run)
	return _c
}

// ClientUnpause provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClientUnpause(ctx context.Context) *BoolCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClientUnpause")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context) *BoolCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ClientUnpause_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientUnpause'
type MockPipeliner_ClientUnpause_Call struct {
	*mock.Call
}

// ClientUnpause is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClientUnpause(ctx interface{}) *MockPipeliner_ClientUnpause_Call {
	return &MockPipeliner_ClientUnpause_Call{Call: _e.mock.On("ClientUnpause", ctx)}
}

func (_c *MockPipeliner_ClientUnpause_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClientUnpause_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClientUnpause_Call) Return(_a0 *BoolCmd) *MockPipeliner_ClientUnpause_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClientUnpause_Call) RunAndReturn(run func(context.Context) *BoolCmd) *MockPipeliner_ClientUnpause_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterAddSlots provides a mock function with given fields: ctx, slots
func (_m *MockPipeliner) ClusterAddSlots(ctx context.Context, slots ...int) *StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlots")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterAddSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterAddSlots'
type MockPipeliner_ClusterAddSlots_Call struct {
	*mock.Call
}

// ClusterAddSlots is a helper method to define mock.On call
//   - ctx context.Context
//   - slots ...int
func (_e *MockPipeliner_Expecter) ClusterAddSlots(ctx interface{}, slots ...interface{}) *MockPipeliner_ClusterAddSlots_Call {
	return &MockPipeliner_ClusterAddSlots_Call{Call: _e.mock.On("ClusterAddSlots",
		append([]interface{}{ctx}, slots...)...)}
}

func (_c *MockPipeliner_ClusterAddSlots_Call) Run(run func(ctx context.Context, slots ...int)) *MockPipeliner_ClusterAddSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ClusterAddSlots_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterAddSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterAddSlots_Call) RunAndReturn(run func(context.Context, ...int) *StatusCmd) *MockPipeliner_ClusterAddSlots_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterAddSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *MockPipeliner) ClusterAddSlotsRange(ctx context.Context, min int, max int) *StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlotsRange")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterAddSlotsRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterAddSlotsRange'
type MockPipeliner_ClusterAddSlotsRange_Call struct {
	*mock.Call
}

// ClusterAddSlotsRange is a helper method to define mock.On call
//   - ctx context.Context
//   - min int
//   - max int
func (_e *MockPipeliner_Expecter) ClusterAddSlotsRange(ctx interface{}, min interface{}, max interface{}) *MockPipeliner_ClusterAddSlotsRange_Call {
	return &MockPipeliner_ClusterAddSlotsRange_Call{Call: _e.mock.On("ClusterAddSlotsRange", ctx, min, max)}
}

func (_c *MockPipeliner_ClusterAddSlotsRange_Call) Run(run func(ctx context.Context, min int, max int)) *MockPipeliner_ClusterAddSlotsRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_ClusterAddSlotsRange_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterAddSlotsRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterAddSlotsRange_Call) RunAndReturn(run func(context.Context, int, int) *StatusCmd) *MockPipeliner_ClusterAddSlotsRange_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterCountFailureReports provides a mock function with given fields: ctx, nodeID
func (_m *MockPipeliner) ClusterCountFailureReports(ctx context.Context, nodeID string) *IntCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountFailureReports")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterCountFailureReports_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterCountFailureReports'
type MockPipeliner_ClusterCountFailureReports_Call struct {
	*mock.Call
}

// ClusterCountFailureReports is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockPipeliner_Expecter) ClusterCountFailureReports(ctx interface{}, nodeID interface{}) *MockPipeliner_ClusterCountFailureReports_Call {
	return &MockPipeliner_ClusterCountFailureReports_Call{Call: _e.mock.On("ClusterCountFailureReports", ctx, nodeID)}
}

func (_c *MockPipeliner_ClusterCountFailureReports_Call) Run(run func(ctx context.Context, nodeID string)) *MockPipeliner_ClusterCountFailureReports_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterCountFailureReports_Call) Return(_a0 *IntCmd) *MockPipeliner_ClusterCountFailureReports_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterCountFailureReports_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ClusterCountFailureReports_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterCountKeysInSlot provides a mock function with given fields: ctx, slot
func (_m *MockPipeliner) ClusterCountKeysInSlot(ctx context.Context, slot int) *IntCmd {
	ret := _m.Called(ctx, slot)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountKeysInSlot")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int) *IntCmd); ok {
		r0 = rf(ctx, slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterCountKeysInSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterCountKeysInSlot'
type MockPipeliner_ClusterCountKeysInSlot_Call struct {
	*mock.Call
}

// ClusterCountKeysInSlot is a helper method to define mock.On call
//   - ctx context.Context
//   - slot int
func (_e *MockPipeliner_Expecter) ClusterCountKeysInSlot(ctx interface{}, slot interface{}) *MockPipeliner_ClusterCountKeysInSlot_Call {
	return &MockPipeliner_ClusterCountKeysInSlot_Call{Call: _e.mock.On("ClusterCountKeysInSlot", ctx, slot)}
}

func (_c *MockPipeliner_ClusterCountKeysInSlot_Call) Run(run func(ctx context.Context, slot int)) *MockPipeliner_ClusterCountKeysInSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockPipeliner_ClusterCountKeysInSlot_Call) Return(_a0 *IntCmd) *MockPipeliner_ClusterCountKeysInSlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterCountKeysInSlot_Call) RunAndReturn(run func(context.Context, int) *IntCmd) *MockPipeliner_ClusterCountKeysInSlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterDelSlots provides a mock function with given fields: ctx, slots
func (_m *MockPipeliner) ClusterDelSlots(ctx context.Context, slots ...int) *StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlots")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...int) *StatusCmd); ok {
		r0 = rf(ctx, slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterDelSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterDelSlots'
type MockPipeliner_ClusterDelSlots_Call struct {
	*mock.Call
}

// ClusterDelSlots is a helper method to define mock.On call
//   - ctx context.Context
//   - slots ...int
func (_e *MockPipeliner_Expecter) ClusterDelSlots(ctx interface{}, slots ...interface{}) *MockPipeliner_ClusterDelSlots_Call {
	return &MockPipeliner_ClusterDelSlots_Call{Call: _e.mock.On("ClusterDelSlots",
		append([]interface{}{ctx}, slots...)...)}
}

func (_c *MockPipeliner_ClusterDelSlots_Call) Run(run func(ctx context.Context, slots ...int)) *MockPipeliner_ClusterDelSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ClusterDelSlots_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterDelSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterDelSlots_Call) RunAndReturn(run func(context.Context, ...int) *StatusCmd) *MockPipeliner_ClusterDelSlots_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterDelSlotsRange provides a mock function with given fields: ctx, min, max
func (_m *MockPipeliner) ClusterDelSlotsRange(ctx context.Context, min int, max int) *StatusCmd {
	ret := _m.Called(ctx, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlotsRange")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *StatusCmd); ok {
		r0 = rf(ctx, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterDelSlotsRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterDelSlotsRange'
type MockPipeliner_ClusterDelSlotsRange_Call struct {
	*mock.Call
}

// ClusterDelSlotsRange is a helper method to define mock.On call
//   - ctx context.Context
//   - min int
//   - max int
func (_e *MockPipeliner_Expecter) ClusterDelSlotsRange(ctx interface{}, min interface{}, max interface{}) *MockPipeliner_ClusterDelSlotsRange_Call {
	return &MockPipeliner_ClusterDelSlotsRange_Call{Call: _e.mock.On("ClusterDelSlotsRange", ctx, min, max)}
}

func (_c *MockPipeliner_ClusterDelSlotsRange_Call) Run(run func(ctx context.Context, min int, max int)) *MockPipeliner_ClusterDelSlotsRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_ClusterDelSlotsRange_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterDelSlotsRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterDelSlotsRange_Call) RunAndReturn(run func(context.Context, int, int) *StatusCmd) *MockPipeliner_ClusterDelSlotsRange_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterFailover provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterFailover(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterFailover")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterFailover_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterFailover'
type MockPipeliner_ClusterFailover_Call struct {
	*mock.Call
}

// ClusterFailover is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterFailover(ctx interface{}) *MockPipeliner_ClusterFailover_Call {
	return &MockPipeliner_ClusterFailover_Call{Call: _e.mock.On("ClusterFailover", ctx)}
}

func (_c *MockPipeliner_ClusterFailover_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterFailover_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterFailover_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterFailover_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterFailover_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ClusterFailover_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterForget provides a mock function with given fields: ctx, nodeID
func (_m *MockPipeliner) ClusterForget(ctx context.Context, nodeID string) *StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterForget")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterForget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterForget'
type MockPipeliner_ClusterForget_Call struct {
	*mock.Call
}

// ClusterForget is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockPipeliner_Expecter) ClusterForget(ctx interface{}, nodeID interface{}) *MockPipeliner_ClusterForget_Call {
	return &MockPipeliner_ClusterForget_Call{Call: _e.mock.On("ClusterForget", ctx, nodeID)}
}

func (_c *MockPipeliner_ClusterForget_Call) Run(run func(ctx context.Context, nodeID string)) *MockPipeliner_ClusterForget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterForget_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterForget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterForget_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_ClusterForget_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterGetKeysInSlot provides a mock function with given fields: ctx, slot, count
func (_m *MockPipeliner) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *StringSliceCmd {
	ret := _m.Called(ctx, slot, count)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGetKeysInSlot")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *StringSliceCmd); ok {
		r0 = rf(ctx, slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterGetKeysInSlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterGetKeysInSlot'
type MockPipeliner_ClusterGetKeysInSlot_Call struct {
	*mock.Call
}

// ClusterGetKeysInSlot is a helper method to define mock.On call
//   - ctx context.Context
//   - slot int
//   - count int
func (_e *MockPipeliner_Expecter) ClusterGetKeysInSlot(ctx interface{}, slot interface{}, count interface{}) *MockPipeliner_ClusterGetKeysInSlot_Call {
	return &MockPipeliner_ClusterGetKeysInSlot_Call{Call: _e.mock.On("ClusterGetKeysInSlot", ctx, slot, count)}
}

func (_c *MockPipeliner_ClusterGetKeysInSlot_Call) Run(run func(ctx context.Context, slot int, count int)) *MockPipeliner_ClusterGetKeysInSlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_ClusterGetKeysInSlot_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ClusterGetKeysInSlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterGetKeysInSlot_Call) RunAndReturn(run func(context.Context, int, int) *StringSliceCmd) *MockPipeliner_ClusterGetKeysInSlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterInfo provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterInfo(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterInfo")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterInfo'
type MockPipeliner_ClusterInfo_Call struct {
	*mock.Call
}

// ClusterInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterInfo(ctx interface{}) *MockPipeliner_ClusterInfo_Call {
	return &MockPipeliner_ClusterInfo_Call{Call: _e.mock.On("ClusterInfo", ctx)}
}

func (_c *MockPipeliner_ClusterInfo_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterInfo_Call) Return(_a0 *StringCmd) *MockPipeliner_ClusterInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterInfo_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClusterInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterKeySlot provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ClusterKeySlot(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ClusterKeySlot")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterKeySlot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterKeySlot'
type MockPipeliner_ClusterKeySlot_Call struct {
	*mock.Call
}

// ClusterKeySlot is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ClusterKeySlot(ctx interface{}, key interface{}) *MockPipeliner_ClusterKeySlot_Call {
	return &MockPipeliner_ClusterKeySlot_Call{Call: _e.mock.On("ClusterKeySlot", ctx, key)}
}

func (_c *MockPipeliner_ClusterKeySlot_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ClusterKeySlot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterKeySlot_Call) Return(_a0 *IntCmd) *MockPipeliner_ClusterKeySlot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterKeySlot_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ClusterKeySlot_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterLinks provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterLinks(ctx context.Context) *ClusterLinksCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterLinks")
	}

	var r0 *ClusterLinksCmd
	if rf, ok := ret.Get(0).(func(context.Context) *ClusterLinksCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ClusterLinksCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterLinks'
type MockPipeliner_ClusterLinks_Call struct {
	*mock.Call
}

// ClusterLinks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterLinks(ctx interface{}) *MockPipeliner_ClusterLinks_Call {
	return &MockPipeliner_ClusterLinks_Call{Call: _e.mock.On("ClusterLinks", ctx)}
}

func (_c *MockPipeliner_ClusterLinks_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterLinks_Call) Return(_a0 *ClusterLinksCmd) *MockPipeliner_ClusterLinks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterLinks_Call) RunAndReturn(run func(context.Context) *ClusterLinksCmd) *MockPipeliner_ClusterLinks_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterMeet provides a mock function with given fields: ctx, host, port
func (_m *MockPipeliner) ClusterMeet(ctx context.Context, host string, port string) *StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMeet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterMeet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterMeet'
type MockPipeliner_ClusterMeet_Call struct {
	*mock.Call
}

// ClusterMeet is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
func (_e *MockPipeliner_Expecter) ClusterMeet(ctx interface{}, host interface{}, port interface{}) *MockPipeliner_ClusterMeet_Call {
	return &MockPipeliner_ClusterMeet_Call{Call: _e.mock.On("ClusterMeet", ctx, host, port)}
}

func (_c *MockPipeliner_ClusterMeet_Call) Run(run func(ctx context.Context, host string, port string)) *MockPipeliner_ClusterMeet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterMeet_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterMeet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterMeet_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_ClusterMeet_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterMyID provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterMyID(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMyID")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterMyID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterMyID'
type MockPipeliner_ClusterMyID_Call struct {
	*mock.Call
}

// ClusterMyID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterMyID(ctx interface{}) *MockPipeliner_ClusterMyID_Call {
	return &MockPipeliner_ClusterMyID_Call{Call: _e.mock.On("ClusterMyID", ctx)}
}

func (_c *MockPipeliner_ClusterMyID_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterMyID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterMyID_Call) Return(_a0 *StringCmd) *MockPipeliner_ClusterMyID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterMyID_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClusterMyID_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterMyShardID provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterMyShardID(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMyShardID")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterMyShardID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterMyShardID'
type MockPipeliner_ClusterMyShardID_Call struct {
	*mock.Call
}

// ClusterMyShardID is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterMyShardID(ctx interface{}) *MockPipeliner_ClusterMyShardID_Call {
	return &MockPipeliner_ClusterMyShardID_Call{Call: _e.mock.On("ClusterMyShardID", ctx)}
}

func (_c *MockPipeliner_ClusterMyShardID_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterMyShardID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterMyShardID_Call) Return(_a0 *StringCmd) *MockPipeliner_ClusterMyShardID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterMyShardID_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClusterMyShardID_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterNodes provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterNodes(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterNodes")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterNodes'
type MockPipeliner_ClusterNodes_Call struct {
	*mock.Call
}

// ClusterNodes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterNodes(ctx interface{}) *MockPipeliner_ClusterNodes_Call {
	return &MockPipeliner_ClusterNodes_Call{Call: _e.mock.On("ClusterNodes", ctx)}
}

func (_c *MockPipeliner_ClusterNodes_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterNodes_Call) Return(_a0 *StringCmd) *MockPipeliner_ClusterNodes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterNodes_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_ClusterNodes_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterReplicate provides a mock function with given fields: ctx, nodeID
func (_m *MockPipeliner) ClusterReplicate(ctx context.Context, nodeID string) *StatusCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterReplicate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterReplicate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterReplicate'
type MockPipeliner_ClusterReplicate_Call struct {
	*mock.Call
}

// ClusterReplicate is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockPipeliner_Expecter) ClusterReplicate(ctx interface{}, nodeID interface{}) *MockPipeliner_ClusterReplicate_Call {
	return &MockPipeliner_ClusterReplicate_Call{Call: _e.mock.On("ClusterReplicate", ctx, nodeID)}
}

func (_c *MockPipeliner_ClusterReplicate_Call) Run(run func(ctx context.Context, nodeID string)) *MockPipeliner_ClusterReplicate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterReplicate_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterReplicate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterReplicate_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_ClusterReplicate_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterResetHard provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterResetHard(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetHard")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterResetHard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterResetHard'
type MockPipeliner_ClusterResetHard_Call struct {
	*mock.Call
}

// ClusterResetHard is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterResetHard(ctx interface{}) *MockPipeliner_ClusterResetHard_Call {
	return &MockPipeliner_ClusterResetHard_Call{Call: _e.mock.On("ClusterResetHard", ctx)}
}

func (_c *MockPipeliner_ClusterResetHard_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterResetHard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterResetHard_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterResetHard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterResetHard_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ClusterResetHard_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterResetSoft provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterResetSoft(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetSoft")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterResetSoft_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterResetSoft'
type MockPipeliner_ClusterResetSoft_Call struct {
	*mock.Call
}

// ClusterResetSoft is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterResetSoft(ctx interface{}) *MockPipeliner_ClusterResetSoft_Call {
	return &MockPipeliner_ClusterResetSoft_Call{Call: _e.mock.On("ClusterResetSoft", ctx)}
}

func (_c *MockPipeliner_ClusterResetSoft_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterResetSoft_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterResetSoft_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterResetSoft_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterResetSoft_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ClusterResetSoft_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSaveConfig provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterSaveConfig(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSaveConfig")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterSaveConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSaveConfig'
type MockPipeliner_ClusterSaveConfig_Call struct {
	*mock.Call
}

// ClusterSaveConfig is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterSaveConfig(ctx interface{}) *MockPipeliner_ClusterSaveConfig_Call {
	return &MockPipeliner_ClusterSaveConfig_Call{Call: _e.mock.On("ClusterSaveConfig", ctx)}
}

func (_c *MockPipeliner_ClusterSaveConfig_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterSaveConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterSaveConfig_Call) Return(_a0 *StatusCmd) *MockPipeliner_ClusterSaveConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterSaveConfig_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ClusterSaveConfig_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterShards provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterShards(ctx context.Context) *ClusterShardsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterShards")
	}

	var r0 *ClusterShardsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *ClusterShardsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ClusterShardsCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterShards_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterShards'
type MockPipeliner_ClusterShards_Call struct {
	*mock.Call
}

// ClusterShards is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterShards(ctx interface{}) *MockPipeliner_ClusterShards_Call {
	return &MockPipeliner_ClusterShards_Call{Call: _e.mock.On("ClusterShards", ctx)}
}

func (_c *MockPipeliner_ClusterShards_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterShards_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterShards_Call) Return(_a0 *ClusterShardsCmd) *MockPipeliner_ClusterShards_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterShards_Call) RunAndReturn(run func(context.Context) *ClusterShardsCmd) *MockPipeliner_ClusterShards_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSlaves provides a mock function with given fields: ctx, nodeID
func (_m *MockPipeliner) ClusterSlaves(ctx context.Context, nodeID string) *StringSliceCmd {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlaves")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterSlaves_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSlaves'
type MockPipeliner_ClusterSlaves_Call struct {
	*mock.Call
}

// ClusterSlaves is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID string
func (_e *MockPipeliner_Expecter) ClusterSlaves(ctx interface{}, nodeID interface{}) *MockPipeliner_ClusterSlaves_Call {
	return &MockPipeliner_ClusterSlaves_Call{Call: _e.mock.On("ClusterSlaves", ctx, nodeID)}
}

func (_c *MockPipeliner_ClusterSlaves_Call) Run(run func(ctx context.Context, nodeID string)) *MockPipeliner_ClusterSlaves_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ClusterSlaves_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ClusterSlaves_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterSlaves_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_ClusterSlaves_Call {
	_c.Call.Return(run)
	return _c
}

// ClusterSlots provides a mock function with given fields: ctx
func (_m *MockPipeliner) ClusterSlots(ctx context.Context) *ClusterSlotsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlots")
	}

	var r0 *ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *ClusterSlotsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ClusterSlotsCmd)
		}
	}

	return r0
}

// MockPipeliner_ClusterSlots_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClusterSlots'
type MockPipeliner_ClusterSlots_Call struct {
	*mock.Call
}

// ClusterSlots is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ClusterSlots(ctx interface{}) *MockPipeliner_ClusterSlots_Call {
	return &MockPipeliner_ClusterSlots_Call{Call: _e.mock.On("ClusterSlots", ctx)}
}

func (_c *MockPipeliner_ClusterSlots_Call) Run(run func(ctx context.Context)) *MockPipeliner_ClusterSlots_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ClusterSlots_Call) Return(_a0 *ClusterSlotsCmd) *MockPipeliner_ClusterSlots_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ClusterSlots_Call) RunAndReturn(run func(context.Context) *ClusterSlotsCmd) *MockPipeliner_ClusterSlots_Call {
	_c.Call.Return(run)
	return _c
}

// Command provides a mock function with given fields: ctx
func (_m *MockPipeliner) Command(ctx context.Context) *CommandsInfoCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 *CommandsInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context) *CommandsInfoCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*CommandsInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_Command_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Command'
type MockPipeliner_Command_Call struct {
	*mock.Call
}

// Command is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Command(ctx interface{}) *MockPipeliner_Command_Call {
	return &MockPipeliner_Command_Call{Call: _e.mock.On("Command", ctx)}
}

func (_c *MockPipeliner_Command_Call) Run(run func(ctx context.Context)) *MockPipeliner_Command_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Command_Call) Return(_a0 *CommandsInfoCmd) *MockPipeliner_Command_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Command_Call) RunAndReturn(run func(context.Context) *CommandsInfoCmd) *MockPipeliner_Command_Call {
	_c.Call.Return(run)
	return _c
}

// CommandGetKeys provides a mock function with given fields: ctx, commands
func (_m *MockPipeliner) CommandGetKeys(ctx context.Context, commands ...interface{}) *StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, commands...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommandGetKeys")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *StringSliceCmd); ok {
		r0 = rf(ctx, commands...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CommandGetKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommandGetKeys'
type MockPipeliner_CommandGetKeys_Call struct {
	*mock.Call
}

// CommandGetKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - commands ...interface{}
func (_e *MockPipeliner_Expecter) CommandGetKeys(ctx interface{}, commands ...interface{}) *MockPipeliner_CommandGetKeys_Call {
	return &MockPipeliner_CommandGetKeys_Call{Call: _e.mock.On("CommandGetKeys",
		append([]interface{}{ctx}, commands...)...)}
}

func (_c *MockPipeliner_CommandGetKeys_Call) Run(run func(ctx context.Context, commands ...interface{})) *MockPipeliner_CommandGetKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CommandGetKeys_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_CommandGetKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CommandGetKeys_Call) RunAndReturn(run func(context.Context, ...interface{}) *StringSliceCmd) *MockPipeliner_CommandGetKeys_Call {
	_c.Call.Return(run)
	return _c
}

// CommandGetKeysAndFlags provides a mock function with given fields: ctx, commands
func (_m *MockPipeliner) CommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *KeyFlagsCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, commands...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommandGetKeysAndFlags")
	}

	var r0 *KeyFlagsCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *KeyFlagsCmd); ok {
		r0 = rf(ctx, commands...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyFlagsCmd)
		}
	}

	return r0
}

// MockPipeliner_CommandGetKeysAndFlags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommandGetKeysAndFlags'
type MockPipeliner_CommandGetKeysAndFlags_Call struct {
	*mock.Call
}

// CommandGetKeysAndFlags is a helper method to define mock.On call
//   - ctx context.Context
//   - commands ...interface{}
func (_e *MockPipeliner_Expecter) CommandGetKeysAndFlags(ctx interface{}, commands ...interface{}) *MockPipeliner_CommandGetKeysAndFlags_Call {
	return &MockPipeliner_CommandGetKeysAndFlags_Call{Call: _e.mock.On("CommandGetKeysAndFlags",
		append([]interface{}{ctx}, commands...)...)}
}

func (_c *MockPipeliner_CommandGetKeysAndFlags_Call) Run(run func(ctx context.Context, commands ...interface{})) *MockPipeliner_CommandGetKeysAndFlags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_CommandGetKeysAndFlags_Call) Return(_a0 *KeyFlagsCmd) *MockPipeliner_CommandGetKeysAndFlags_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CommandGetKeysAndFlags_Call) RunAndReturn(run func(context.Context, ...interface{}) *KeyFlagsCmd) *MockPipeliner_CommandGetKeysAndFlags_Call {
	_c.Call.Return(run)
	return _c
}

// CommandList provides a mock function with given fields: ctx, filter
func (_m *MockPipeliner) CommandList(ctx context.Context, filter *FilterBy) *StringSliceCmd {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for CommandList")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *FilterBy) *StringSliceCmd); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_CommandList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommandList'
type MockPipeliner_CommandList_Call struct {
	*mock.Call
}

// CommandList is a helper method to define mock.On call
//   - ctx context.Context
//   - filter *FilterBy
func (_e *MockPipeliner_Expecter) CommandList(ctx interface{}, filter interface{}) *MockPipeliner_CommandList_Call {
	return &MockPipeliner_CommandList_Call{Call: _e.mock.On("CommandList", ctx, filter)}
}

func (_c *MockPipeliner_CommandList_Call) Run(run func(ctx context.Context, filter *FilterBy)) *MockPipeliner_CommandList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*FilterBy))
	})
	return _c
}

func (_c *MockPipeliner_CommandList_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_CommandList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_CommandList_Call) RunAndReturn(run func(context.Context, *FilterBy) *StringSliceCmd) *MockPipeliner_CommandList_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigGet provides a mock function with given fields: ctx, parameter
func (_m *MockPipeliner) ConfigGet(ctx context.Context, parameter string) *MapStringStringCmd {
	ret := _m.Called(ctx, parameter)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGet")
	}

	var r0 *MapStringStringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapStringStringCmd); ok {
		r0 = rf(ctx, parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringStringCmd)
		}
	}

	return r0
}

// MockPipeliner_ConfigGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigGet'
type MockPipeliner_ConfigGet_Call struct {
	*mock.Call
}

// ConfigGet is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter string
func (_e *MockPipeliner_Expecter) ConfigGet(ctx interface{}, parameter interface{}) *MockPipeliner_ConfigGet_Call {
	return &MockPipeliner_ConfigGet_Call{Call: _e.mock.On("ConfigGet", ctx, parameter)}
}

func (_c *MockPipeliner_ConfigGet_Call) Run(run func(ctx context.Context, parameter string)) *MockPipeliner_ConfigGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ConfigGet_Call) Return(_a0 *MapStringStringCmd) *MockPipeliner_ConfigGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ConfigGet_Call) RunAndReturn(run func(context.Context, string) *MapStringStringCmd) *MockPipeliner_ConfigGet_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigResetStat provides a mock function with given fields: ctx
func (_m *MockPipeliner) ConfigResetStat(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigResetStat")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ConfigResetStat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigResetStat'
type MockPipeliner_ConfigResetStat_Call struct {
	*mock.Call
}

// ConfigResetStat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ConfigResetStat(ctx interface{}) *MockPipeliner_ConfigResetStat_Call {
	return &MockPipeliner_ConfigResetStat_Call{Call: _e.mock.On("ConfigResetStat", ctx)}
}

func (_c *MockPipeliner_ConfigResetStat_Call) Run(run func(ctx context.Context)) *MockPipeliner_ConfigResetStat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ConfigResetStat_Call) Return(_a0 *StatusCmd) *MockPipeliner_ConfigResetStat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ConfigResetStat_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ConfigResetStat_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigRewrite provides a mock function with given fields: ctx
func (_m *MockPipeliner) ConfigRewrite(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ConfigRewrite")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ConfigRewrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigRewrite'
type MockPipeliner_ConfigRewrite_Call struct {
	*mock.Call
}

// ConfigRewrite is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ConfigRewrite(ctx interface{}) *MockPipeliner_ConfigRewrite_Call {
	return &MockPipeliner_ConfigRewrite_Call{Call: _e.mock.On("ConfigRewrite", ctx)}
}

func (_c *MockPipeliner_ConfigRewrite_Call) Run(run func(ctx context.Context)) *MockPipeliner_ConfigRewrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ConfigRewrite_Call) Return(_a0 *StatusCmd) *MockPipeliner_ConfigRewrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ConfigRewrite_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ConfigRewrite_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigSet provides a mock function with given fields: ctx, parameter, value
func (_m *MockPipeliner) ConfigSet(ctx context.Context, parameter string, value string) *StatusCmd {
	ret := _m.Called(ctx, parameter, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigSet'
type MockPipeliner_ConfigSet_Call struct {
	*mock.Call
}

// ConfigSet is a helper method to define mock.On call
//   - ctx context.Context
//   - parameter string
//   - value string
func (_e *MockPipeliner_Expecter) ConfigSet(ctx interface{}, parameter interface{}, value interface{}) *MockPipeliner_ConfigSet_Call {
	return &MockPipeliner_ConfigSet_Call{Call: _e.mock.On("ConfigSet", ctx, parameter, value)}
}

func (_c *MockPipeliner_ConfigSet_Call) Run(run func(ctx context.Context, parameter string, value string)) *MockPipeliner_ConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ConfigSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_ConfigSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ConfigSet_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_ConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// Copy provides a mock function with given fields: ctx, sourceKey, destKey, db, replace
func (_m *MockPipeliner) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *IntCmd {
	ret := _m.Called(ctx, sourceKey, destKey, db, replace)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, bool) *IntCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, db, replace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type MockPipeliner_Copy_Call struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
//   - db int
//   - replace bool
func (_e *MockPipeliner_Expecter) Copy(ctx interface{}, sourceKey interface{}, destKey interface{}, db interface{}, replace interface{}) *MockPipeliner_Copy_Call {
	return &MockPipeliner_Copy_Call{Call: _e.mock.On("Copy", ctx, sourceKey, destKey, db, replace)}
}

func (_c *MockPipeliner_Copy_Call) Run(run func(ctx context.Context, sourceKey string, destKey string, db int, replace bool)) *MockPipeliner_Copy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockPipeliner_Copy_Call) Return(_a0 *IntCmd) *MockPipeliner_Copy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Copy_Call) RunAndReturn(run func(context.Context, string, string, int, bool) *IntCmd) *MockPipeliner_Copy_Call {
	_c.Call.Return(run)
	return _c
}

// DBSize provides a mock function with given fields: ctx
func (_m *MockPipeliner) DBSize(ctx context.Context) *IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DBSize")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_DBSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DBSize'
type MockPipeliner_DBSize_Call struct {
	*mock.Call
}

// DBSize is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) DBSize(ctx interface{}) *MockPipeliner_DBSize_Call {
	return &MockPipeliner_DBSize_Call{Call: _e.mock.On("DBSize", ctx)}
}

func (_c *MockPipeliner_DBSize_Call) Run(run func(ctx context.Context)) *MockPipeliner_DBSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_DBSize_Call) Return(_a0 *IntCmd) *MockPipeliner_DBSize_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_DBSize_Call) RunAndReturn(run func(context.Context) *IntCmd) *MockPipeliner_DBSize_Call {
	_c.Call.Return(run)
	return _c
}

// DebugObject provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) DebugObject(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for DebugObject")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_DebugObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DebugObject'
type MockPipeliner_DebugObject_Call struct {
	*mock.Call
}

// DebugObject is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) DebugObject(ctx interface{}, key interface{}) *MockPipeliner_DebugObject_Call {
	return &MockPipeliner_DebugObject_Call{Call: _e.mock.On("DebugObject", ctx, key)}
}

func (_c *MockPipeliner_DebugObject_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_DebugObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_DebugObject_Call) Return(_a0 *StringCmd) *MockPipeliner_DebugObject_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_DebugObject_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_DebugObject_Call {
	_c.Call.Return(run)
	return _c
}

// Decr provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Decr(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Decr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decr'
type MockPipeliner_Decr_Call struct {
	*mock.Call
}

// Decr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Decr(ctx interface{}, key interface{}) *MockPipeliner_Decr_Call {
	return &MockPipeliner_Decr_Call{Call: _e.mock.On("Decr", ctx, key)}
}

func (_c *MockPipeliner_Decr_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Decr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Decr_Call) Return(_a0 *IntCmd) *MockPipeliner_Decr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Decr_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_Decr_Call {
	_c.Call.Return(run)
	return _c
}

// DecrBy provides a mock function with given fields: ctx, key, decrement
func (_m *MockPipeliner) DecrBy(ctx context.Context, key string, decrement int64) *IntCmd {
	ret := _m.Called(ctx, key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_DecrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecrBy'
type MockPipeliner_DecrBy_Call struct {
	*mock.Call
}

// DecrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - decrement int64
func (_e *MockPipeliner_Expecter) DecrBy(ctx interface{}, key interface{}, decrement interface{}) *MockPipeliner_DecrBy_Call {
	return &MockPipeliner_DecrBy_Call{Call: _e.mock.On("DecrBy", ctx, key, decrement)}
}

func (_c *MockPipeliner_DecrBy_Call) Run(run func(ctx context.Context, key string, decrement int64)) *MockPipeliner_DecrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_DecrBy_Call) Return(_a0 *IntCmd) *MockPipeliner_DecrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_DecrBy_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockPipeliner_DecrBy_Call {
	_c.Call.Return(run)
	return _c
}

// Del provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) Del(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Del_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Del'
type MockPipeliner_Del_Call struct {
	*mock.Call
}

// Del is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) Del(ctx interface{}, keys ...interface{}) *MockPipeliner_Del_Call {
	return &MockPipeliner_Del_Call{Call: _e.mock.On("Del",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_Del_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_Del_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Del_Call) Return(_a0 *IntCmd) *MockPipeliner_Del_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Del_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_Del_Call {
	_c.Call.Return(run)
	return _c
}

// Discard provides a mock function with no fields
func (_m *MockPipeliner) Discard() {
	_m.Called()
}

// MockPipeliner_Discard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Discard'
type MockPipeliner_Discard_Call struct {
	*mock.Call
}

// Discard is a helper method to define mock.On call
func (_e *MockPipeliner_Expecter) Discard() *MockPipeliner_Discard_Call {
	return &MockPipeliner_Discard_Call{Call: _e.mock.On("Discard")}
}

func (_c *MockPipeliner_Discard_Call) Run(run func()) *MockPipeliner_Discard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPipeliner_Discard_Call) Return() *MockPipeliner_Discard_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockPipeliner_Discard_Call) RunAndReturn(run func()) *MockPipeliner_Discard_Call {
	_c.Run(run)
	return _c
}

// Do provides a mock function with given fields: ctx, args
func (_m *MockPipeliner) Do(ctx context.Context, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Do")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_Do_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Do'
type MockPipeliner_Do_Call struct {
	*mock.Call
}

// Do is a helper method to define mock.On call
//   - ctx context.Context
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) Do(ctx interface{}, args ...interface{}) *MockPipeliner_Do_Call {
	return &MockPipeliner_Do_Call{Call: _e.mock.On("Do",
		append([]interface{}{ctx}, args...)...)}
}

func (_c *MockPipeliner_Do_Call) Run(run func(ctx context.Context, args ...interface{})) *MockPipeliner_Do_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Do_Call) Return(_a0 *Cmd) *MockPipeliner_Do_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Do_Call) RunAndReturn(run func(context.Context, ...interface{}) *Cmd) *MockPipeliner_Do_Call {
	_c.Call.Return(run)
	return _c
}

// Dump provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Dump(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_Dump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dump'
type MockPipeliner_Dump_Call struct {
	*mock.Call
}

// Dump is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Dump(ctx interface{}, key interface{}) *MockPipeliner_Dump_Call {
	return &MockPipeliner_Dump_Call{Call: _e.mock.On("Dump", ctx, key)}
}

func (_c *MockPipeliner_Dump_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Dump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Dump_Call) Return(_a0 *StringCmd) *MockPipeliner_Dump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Dump_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_Dump_Call {
	_c.Call.Return(run)
	return _c
}

// Echo provides a mock function with given fields: ctx, message
func (_m *MockPipeliner) Echo(ctx context.Context, message interface{}) *StringCmd {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, interface{}) *StringCmd); ok {
		r0 = rf(ctx, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_Echo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Echo'
type MockPipeliner_Echo_Call struct {
	*mock.Call
}

// Echo is a helper method to define mock.On call
//   - ctx context.Context
//   - message interface{}
func (_e *MockPipeliner_Expecter) Echo(ctx interface{}, message interface{}) *MockPipeliner_Echo_Call {
	return &MockPipeliner_Echo_Call{Call: _e.mock.On("Echo", ctx, message)}
}

func (_c *MockPipeliner_Echo_Call) Run(run func(ctx context.Context, message interface{})) *MockPipeliner_Echo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_Echo_Call) Return(_a0 *StringCmd) *MockPipeliner_Echo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Echo_Call) RunAndReturn(run func(context.Context, interface{}) *StringCmd) *MockPipeliner_Echo_Call {
	_c.Call.Return(run)
	return _c
}

// Eval provides a mock function with given fields: ctx, script, keys, args
func (_m *MockPipeliner) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_Eval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Eval'
type MockPipeliner_Eval_Call struct {
	*mock.Call
}

// Eval is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) Eval(ctx interface{}, script interface{}, keys interface{}, args ...interface{}) *MockPipeliner_Eval_Call {
	return &MockPipeliner_Eval_Call{Call: _e.mock.On("Eval",
		append([]interface{}{ctx, script, keys}, args...)...)}
}

func (_c *MockPipeliner_Eval_Call) Run(run func(ctx context.Context, script string, keys []string, args ...interface{})) *MockPipeliner_Eval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Eval_Call) Return(_a0 *Cmd) *MockPipeliner_Eval_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Eval_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_Eval_Call {
	_c.Call.Return(run)
	return _c
}

// EvalRO provides a mock function with given fields: ctx, script, keys, args
func (_m *MockPipeliner) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_EvalRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalRO'
type MockPipeliner_EvalRO_Call struct {
	*mock.Call
}

// EvalRO is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) EvalRO(ctx interface{}, script interface{}, keys interface{}, args ...interface{}) *MockPipeliner_EvalRO_Call {
	return &MockPipeliner_EvalRO_Call{Call: _e.mock.On("EvalRO",
		append([]interface{}{ctx, script, keys}, args...)...)}
}

func (_c *MockPipeliner_EvalRO_Call) Run(run func(ctx context.Context, script string, keys []string, args ...interface{})) *MockPipeliner_EvalRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_EvalRO_Call) Return(_a0 *Cmd) *MockPipeliner_EvalRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_EvalRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_EvalRO_Call {
	_c.Call.Return(run)
	return _c
}

// EvalSha provides a mock function with given fields: ctx, sha1, keys, args
func (_m *MockPipeliner) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_EvalSha_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalSha'
type MockPipeliner_EvalSha_Call struct {
	*mock.Call
}

// EvalSha is a helper method to define mock.On call
//   - ctx context.Context
//   - sha1 string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) EvalSha(ctx interface{}, sha1 interface{}, keys interface{}, args ...interface{}) *MockPipeliner_EvalSha_Call {
	return &MockPipeliner_EvalSha_Call{Call: _e.mock.On("EvalSha",
		append([]interface{}{ctx, sha1, keys}, args...)...)}
}

func (_c *MockPipeliner_EvalSha_Call) Run(run func(ctx context.Context, sha1 string, keys []string, args ...interface{})) *MockPipeliner_EvalSha_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_EvalSha_Call) Return(_a0 *Cmd) *MockPipeliner_EvalSha_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_EvalSha_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_EvalSha_Call {
	_c.Call.Return(run)
	return _c
}

// EvalShaRO provides a mock function with given fields: ctx, sha1, keys, args
func (_m *MockPipeliner) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalShaRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_EvalShaRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalShaRO'
type MockPipeliner_EvalShaRO_Call struct {
	*mock.Call
}

// EvalShaRO is a helper method to define mock.On call
//   - ctx context.Context
//   - sha1 string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) EvalShaRO(ctx interface{}, sha1 interface{}, keys interface{}, args ...interface{}) *MockPipeliner_EvalShaRO_Call {
	return &MockPipeliner_EvalShaRO_Call{Call: _e.mock.On("EvalShaRO",
		append([]interface{}{ctx, sha1, keys}, args...)...)}
}

func (_c *MockPipeliner_EvalShaRO_Call) Run(run func(ctx context.Context, sha1 string, keys []string, args ...interface{})) *MockPipeliner_EvalShaRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_EvalShaRO_Call) Return(_a0 *Cmd) *MockPipeliner_EvalShaRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_EvalShaRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_EvalShaRO_Call {
	_c.Call.Return(run)
	return _c
}

// Exec provides a mock function with given fields: ctx
func (_m *MockPipeliner) Exec(ctx context.Context) ([]Cmder, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Exec")
	}

	var r0 []Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]Cmder, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []Cmder); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPipeliner_Exec_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exec'
type MockPipeliner_Exec_Call struct {
	*mock.Call
}

// Exec is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Exec(ctx interface{}) *MockPipeliner_Exec_Call {
	return &MockPipeliner_Exec_Call{Call: _e.mock.On("Exec", ctx)}
}

func (_c *MockPipeliner_Exec_Call) Run(run func(ctx context.Context)) *MockPipeliner_Exec_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Exec_Call) Return(_a0 []Cmder, _a1 error) *MockPipeliner_Exec_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPipeliner_Exec_Call) RunAndReturn(run func(context.Context) ([]Cmder, error)) *MockPipeliner_Exec_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) Exists(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockPipeliner_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) Exists(ctx interface{}, keys ...interface{}) *MockPipeliner_Exists_Call {
	return &MockPipeliner_Exists_Call{Call: _e.mock.On("Exists",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_Exists_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Exists_Call) Return(_a0 *IntCmd) *MockPipeliner_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Exists_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) Expire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_Expire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expire'
type MockPipeliner_Expire_Call struct {
	*mock.Call
}

// Expire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) Expire(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_Expire_Call {
	return &MockPipeliner_Expire_Call{Call: _e.mock.On("Expire", ctx, key, expiration)}
}

func (_c *MockPipeliner_Expire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_Expire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_Expire_Call) Return(_a0 *BoolCmd) *MockPipeliner_Expire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Expire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_Expire_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockPipeliner) ExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireAt'
type MockPipeliner_ExpireAt_Call struct {
	*mock.Call
}

// ExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockPipeliner_Expecter) ExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockPipeliner_ExpireAt_Call {
	return &MockPipeliner_ExpireAt_Call{Call: _e.mock.On("ExpireAt", ctx, key, tm)}
}

func (_c *MockPipeliner_ExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockPipeliner_ExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockPipeliner_ExpireAt_Call) Return(_a0 *BoolCmd) *MockPipeliner_ExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *BoolCmd) *MockPipeliner_ExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireGT provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) ExpireGT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireGT")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireGT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireGT'
type MockPipeliner_ExpireGT_Call struct {
	*mock.Call
}

// ExpireGT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) ExpireGT(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_ExpireGT_Call {
	return &MockPipeliner_ExpireGT_Call{Call: _e.mock.On("ExpireGT", ctx, key, expiration)}
}

func (_c *MockPipeliner_ExpireGT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_ExpireGT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_ExpireGT_Call) Return(_a0 *BoolCmd) *MockPipeliner_ExpireGT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireGT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_ExpireGT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireLT provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) ExpireLT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireLT")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireLT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireLT'
type MockPipeliner_ExpireLT_Call struct {
	*mock.Call
}

// ExpireLT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) ExpireLT(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_ExpireLT_Call {
	return &MockPipeliner_ExpireLT_Call{Call: _e.mock.On("ExpireLT", ctx, key, expiration)}
}

func (_c *MockPipeliner_ExpireLT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_ExpireLT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_ExpireLT_Call) Return(_a0 *BoolCmd) *MockPipeliner_ExpireLT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireLT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_ExpireLT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireNX provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) ExpireNX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireNX'
type MockPipeliner_ExpireNX_Call struct {
	*mock.Call
}

// ExpireNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) ExpireNX(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_ExpireNX_Call {
	return &MockPipeliner_ExpireNX_Call{Call: _e.mock.On("ExpireNX", ctx, key, expiration)}
}

func (_c *MockPipeliner_ExpireNX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_ExpireNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_ExpireNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_ExpireNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireNX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_ExpireNX_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireTime provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ExpireTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ExpireTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireTime'
type MockPipeliner_ExpireTime_Call struct {
	*mock.Call
}

// ExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ExpireTime(ctx interface{}, key interface{}) *MockPipeliner_ExpireTime_Call {
	return &MockPipeliner_ExpireTime_Call{Call: _e.mock.On("ExpireTime", ctx, key)}
}

func (_c *MockPipeliner_ExpireTime_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ExpireTime_Call) Return(_a0 *DurationCmd) *MockPipeliner_ExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockPipeliner_ExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireXX provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) ExpireXX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireXX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_ExpireXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireXX'
type MockPipeliner_ExpireXX_Call struct {
	*mock.Call
}

// ExpireXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) ExpireXX(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_ExpireXX_Call {
	return &MockPipeliner_ExpireXX_Call{Call: _e.mock.On("ExpireXX", ctx, key, expiration)}
}

func (_c *MockPipeliner_ExpireXX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_ExpireXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_ExpireXX_Call) Return(_a0 *BoolCmd) *MockPipeliner_ExpireXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ExpireXX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_ExpireXX_Call {
	_c.Call.Return(run)
	return _c
}

// FCall provides a mock function with given fields: ctx, function, keys, args
func (_m *MockPipeliner) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCall")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_FCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCall'
type MockPipeliner_FCall_Call struct {
	*mock.Call
}

// FCall is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) FCall(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockPipeliner_FCall_Call {
	return &MockPipeliner_FCall_Call{Call: _e.mock.On("FCall",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockPipeliner_FCall_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockPipeliner_FCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FCall_Call) Return(_a0 *Cmd) *MockPipeliner_FCall_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FCall_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_FCall_Call {
	_c.Call.Return(run)
	return _c
}

// FCallRO provides a mock function with given fields: ctx, function, keys, args
func (_m *MockPipeliner) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_FCallRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCallRO'
type MockPipeliner_FCallRO_Call struct {
	*mock.Call
}

// FCallRO is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) FCallRO(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockPipeliner_FCallRO_Call {
	return &MockPipeliner_FCallRO_Call{Call: _e.mock.On("FCallRO",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockPipeliner_FCallRO_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockPipeliner_FCallRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FCallRO_Call) Return(_a0 *Cmd) *MockPipeliner_FCallRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FCallRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_FCallRO_Call {
	_c.Call.Return(run)
	return _c
}

// FCallRo provides a mock function with given fields: ctx, function, keys, args
func (_m *MockPipeliner) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRo")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_FCallRo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCallRo'
type MockPipeliner_FCallRo_Call struct {
	*mock.Call
}

// FCallRo is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockPipeliner_Expecter) FCallRo(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockPipeliner_FCallRo_Call {
	return &MockPipeliner_FCallRo_Call{Call: _e.mock.On("FCallRo",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockPipeliner_FCallRo_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockPipeliner_FCallRo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FCallRo_Call) Return(_a0 *Cmd) *MockPipeliner_FCallRo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FCallRo_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockPipeliner_FCallRo_Call {
	_c.Call.Return(run)
	return _c
}

// FTAggregate provides a mock function with given fields: ctx, index, query
func (_m *MockPipeliner) FTAggregate(ctx context.Context, index string, query string) *MapStringInterfaceCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTAggregate")
	}

	var r0 *MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *MapStringInterfaceCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAggregate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAggregate'
type MockPipeliner_FTAggregate_Call struct {
	*mock.Call
}

// FTAggregate is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
func (_e *MockPipeliner_Expecter) FTAggregate(ctx interface{}, index interface{}, query interface{}) *MockPipeliner_FTAggregate_Call {
	return &MockPipeliner_FTAggregate_Call{Call: _e.mock.On("FTAggregate", ctx, index, query)}
}

func (_c *MockPipeliner_FTAggregate_Call) Run(run func(ctx context.Context, index string, query string)) *MockPipeliner_FTAggregate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTAggregate_Call) Return(_a0 *MapStringInterfaceCmd) *MockPipeliner_FTAggregate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAggregate_Call) RunAndReturn(run func(context.Context, string, string) *MapStringInterfaceCmd) *MockPipeliner_FTAggregate_Call {
	_c.Call.Return(run)
	return _c
}

// FTAggregateWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *MockPipeliner) FTAggregateWithArgs(ctx context.Context, index string, query string, options *FTAggregateOptions) *AggregateCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTAggregateWithArgs")
	}

	var r0 *AggregateCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *FTAggregateOptions) *AggregateCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AggregateCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAggregateWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAggregateWithArgs'
type MockPipeliner_FTAggregateWithArgs_Call struct {
	*mock.Call
}

// FTAggregateWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
//   - options *FTAggregateOptions
func (_e *MockPipeliner_Expecter) FTAggregateWithArgs(ctx interface{}, index interface{}, query interface{}, options interface{}) *MockPipeliner_FTAggregateWithArgs_Call {
	return &MockPipeliner_FTAggregateWithArgs_Call{Call: _e.mock.On("FTAggregateWithArgs", ctx, index, query, options)}
}

func (_c *MockPipeliner_FTAggregateWithArgs_Call) Run(run func(ctx context.Context, index string, query string, options *FTAggregateOptions)) *MockPipeliner_FTAggregateWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*FTAggregateOptions))
	})
	return _c
}

func (_c *MockPipeliner_FTAggregateWithArgs_Call) Return(_a0 *AggregateCmd) *MockPipeliner_FTAggregateWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAggregateWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *FTAggregateOptions) *AggregateCmd) *MockPipeliner_FTAggregateWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTAliasAdd provides a mock function with given fields: ctx, index, alias
func (_m *MockPipeliner) FTAliasAdd(ctx context.Context, index string, alias string) *StatusCmd {
	ret := _m.Called(ctx, index, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasAdd")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, index, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAliasAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAliasAdd'
type MockPipeliner_FTAliasAdd_Call struct {
	*mock.Call
}

// FTAliasAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - alias string
func (_e *MockPipeliner_Expecter) FTAliasAdd(ctx interface{}, index interface{}, alias interface{}) *MockPipeliner_FTAliasAdd_Call {
	return &MockPipeliner_FTAliasAdd_Call{Call: _e.mock.On("FTAliasAdd", ctx, index, alias)}
}

func (_c *MockPipeliner_FTAliasAdd_Call) Run(run func(ctx context.Context, index string, alias string)) *MockPipeliner_FTAliasAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTAliasAdd_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTAliasAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAliasAdd_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_FTAliasAdd_Call {
	_c.Call.Return(run)
	return _c
}

// FTAliasDel provides a mock function with given fields: ctx, alias
func (_m *MockPipeliner) FTAliasDel(ctx context.Context, alias string) *StatusCmd {
	ret := _m.Called(ctx, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasDel")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAliasDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAliasDel'
type MockPipeliner_FTAliasDel_Call struct {
	*mock.Call
}

// FTAliasDel is a helper method to define mock.On call
//   - ctx context.Context
//   - alias string
func (_e *MockPipeliner_Expecter) FTAliasDel(ctx interface{}, alias interface{}) *MockPipeliner_FTAliasDel_Call {
	return &MockPipeliner_FTAliasDel_Call{Call: _e.mock.On("FTAliasDel", ctx, alias)}
}

func (_c *MockPipeliner_FTAliasDel_Call) Run(run func(ctx context.Context, alias string)) *MockPipeliner_FTAliasDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTAliasDel_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTAliasDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAliasDel_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_FTAliasDel_Call {
	_c.Call.Return(run)
	return _c
}

// FTAliasUpdate provides a mock function with given fields: ctx, index, alias
func (_m *MockPipeliner) FTAliasUpdate(ctx context.Context, index string, alias string) *StatusCmd {
	ret := _m.Called(ctx, index, alias)

	if len(ret) == 0 {
		panic("no return value specified for FTAliasUpdate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, index, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAliasUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAliasUpdate'
type MockPipeliner_FTAliasUpdate_Call struct {
	*mock.Call
}

// FTAliasUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - alias string
func (_e *MockPipeliner_Expecter) FTAliasUpdate(ctx interface{}, index interface{}, alias interface{}) *MockPipeliner_FTAliasUpdate_Call {
	return &MockPipeliner_FTAliasUpdate_Call{Call: _e.mock.On("FTAliasUpdate", ctx, index, alias)}
}

func (_c *MockPipeliner_FTAliasUpdate_Call) Run(run func(ctx context.Context, index string, alias string)) *MockPipeliner_FTAliasUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTAliasUpdate_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTAliasUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAliasUpdate_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_FTAliasUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// FTAlter provides a mock function with given fields: ctx, index, skipInitialScan, definition
func (_m *MockPipeliner) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *StatusCmd {
	ret := _m.Called(ctx, index, skipInitialScan, definition)

	if len(ret) == 0 {
		panic("no return value specified for FTAlter")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, []interface{}) *StatusCmd); ok {
		r0 = rf(ctx, index, skipInitialScan, definition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTAlter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTAlter'
type MockPipeliner_FTAlter_Call struct {
	*mock.Call
}

// FTAlter is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - skipInitialScan bool
//   - definition []interface{}
func (_e *MockPipeliner_Expecter) FTAlter(ctx interface{}, index interface{}, skipInitialScan interface{}, definition interface{}) *MockPipeliner_FTAlter_Call {
	return &MockPipeliner_FTAlter_Call{Call: _e.mock.On("FTAlter", ctx, index, skipInitialScan, definition)}
}

func (_c *MockPipeliner_FTAlter_Call) Run(run func(ctx context.Context, index string, skipInitialScan bool, definition []interface{})) *MockPipeliner_FTAlter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].([]interface{}))
	})
	return _c
}

func (_c *MockPipeliner_FTAlter_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTAlter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTAlter_Call) RunAndReturn(run func(context.Context, string, bool, []interface{}) *StatusCmd) *MockPipeliner_FTAlter_Call {
	_c.Call.Return(run)
	return _c
}

// FTConfigGet provides a mock function with given fields: ctx, option
func (_m *MockPipeliner) FTConfigGet(ctx context.Context, option string) *MapMapStringInterfaceCmd {
	ret := _m.Called(ctx, option)

	if len(ret) == 0 {
		panic("no return value specified for FTConfigGet")
	}

	var r0 *MapMapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapMapStringInterfaceCmd); ok {
		r0 = rf(ctx, option)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapMapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_FTConfigGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTConfigGet'
type MockPipeliner_FTConfigGet_Call struct {
	*mock.Call
}

// FTConfigGet is a helper method to define mock.On call
//   - ctx context.Context
//   - option string
func (_e *MockPipeliner_Expecter) FTConfigGet(ctx interface{}, option interface{}) *MockPipeliner_FTConfigGet_Call {
	return &MockPipeliner_FTConfigGet_Call{Call: _e.mock.On("FTConfigGet", ctx, option)}
}

func (_c *MockPipeliner_FTConfigGet_Call) Run(run func(ctx context.Context, option string)) *MockPipeliner_FTConfigGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTConfigGet_Call) Return(_a0 *MapMapStringInterfaceCmd) *MockPipeliner_FTConfigGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTConfigGet_Call) RunAndReturn(run func(context.Context, string) *MapMapStringInterfaceCmd) *MockPipeliner_FTConfigGet_Call {
	_c.Call.Return(run)
	return _c
}

// FTConfigSet provides a mock function with given fields: ctx, option, value
func (_m *MockPipeliner) FTConfigSet(ctx context.Context, option string, value interface{}) *StatusCmd {
	ret := _m.Called(ctx, option, value)

	if len(ret) == 0 {
		panic("no return value specified for FTConfigSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, option, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTConfigSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTConfigSet'
type MockPipeliner_FTConfigSet_Call struct {
	*mock.Call
}

// FTConfigSet is a helper method to define mock.On call
//   - ctx context.Context
//   - option string
//   - value interface{}
func (_e *MockPipeliner_Expecter) FTConfigSet(ctx interface{}, option interface{}, value interface{}) *MockPipeliner_FTConfigSet_Call {
	return &MockPipeliner_FTConfigSet_Call{Call: _e.mock.On("FTConfigSet", ctx, option, value)}
}

func (_c *MockPipeliner_FTConfigSet_Call) Run(run func(ctx context.Context, option string, value interface{})) *MockPipeliner_FTConfigSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_FTConfigSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTConfigSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTConfigSet_Call) RunAndReturn(run func(context.Context, string, interface{}) *StatusCmd) *MockPipeliner_FTConfigSet_Call {
	_c.Call.Return(run)
	return _c
}

// FTCreate provides a mock function with given fields: ctx, index, options, schema
func (_m *MockPipeliner) FTCreate(ctx context.Context, index string, options *FTCreateOptions, schema ...*FieldSchema) *StatusCmd {
	_va := make([]interface{}, len(schema))
	for _i := range schema {
		_va[_i] = schema[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, index, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTCreate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *FTCreateOptions, ...*FieldSchema) *StatusCmd); ok {
		r0 = rf(ctx, index, options, schema...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTCreate'
type MockPipeliner_FTCreate_Call struct {
	*mock.Call
}

// FTCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - options *FTCreateOptions
//   - schema ...*FieldSchema
func (_e *MockPipeliner_Expecter) FTCreate(ctx interface{}, index interface{}, options interface{}, schema ...interface{}) *MockPipeliner_FTCreate_Call {
	return &MockPipeliner_FTCreate_Call{Call: _e.mock.On("FTCreate",
		append([]interface{}{ctx, index, options}, schema...)...)}
}

func (_c *MockPipeliner_FTCreate_Call) Run(run func(ctx context.Context, index string, options *FTCreateOptions, schema ...*FieldSchema)) *MockPipeliner_FTCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*FieldSchema, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(*FieldSchema)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*FTCreateOptions), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FTCreate_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTCreate_Call) RunAndReturn(run func(context.Context, string, *FTCreateOptions, ...*FieldSchema) *StatusCmd) *MockPipeliner_FTCreate_Call {
	_c.Call.Return(run)
	return _c
}

// FTCursorDel provides a mock function with given fields: ctx, index, cursorId
func (_m *MockPipeliner) FTCursorDel(ctx context.Context, index string, cursorId int) *StatusCmd {
	ret := _m.Called(ctx, index, cursorId)

	if len(ret) == 0 {
		panic("no return value specified for FTCursorDel")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StatusCmd); ok {
		r0 = rf(ctx, index, cursorId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTCursorDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTCursorDel'
type MockPipeliner_FTCursorDel_Call struct {
	*mock.Call
}

// FTCursorDel is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - cursorId int
func (_e *MockPipeliner_Expecter) FTCursorDel(ctx interface{}, index interface{}, cursorId interface{}) *MockPipeliner_FTCursorDel_Call {
	return &MockPipeliner_FTCursorDel_Call{Call: _e.mock.On("FTCursorDel", ctx, index, cursorId)}
}

func (_c *MockPipeliner_FTCursorDel_Call) Run(run func(ctx context.Context, index string, cursorId int)) *MockPipeliner_FTCursorDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_FTCursorDel_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTCursorDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTCursorDel_Call) RunAndReturn(run func(context.Context, string, int) *StatusCmd) *MockPipeliner_FTCursorDel_Call {
	_c.Call.Return(run)
	return _c
}

// FTCursorRead provides a mock function with given fields: ctx, index, cursorId, count
func (_m *MockPipeliner) FTCursorRead(ctx context.Context, index string, cursorId int, count int) *MapStringInterfaceCmd {
	ret := _m.Called(ctx, index, cursorId, count)

	if len(ret) == 0 {
		panic("no return value specified for FTCursorRead")
	}

	var r0 *MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *MapStringInterfaceCmd); ok {
		r0 = rf(ctx, index, cursorId, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_FTCursorRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTCursorRead'
type MockPipeliner_FTCursorRead_Call struct {
	*mock.Call
}

// FTCursorRead is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - cursorId int
//   - count int
func (_e *MockPipeliner_Expecter) FTCursorRead(ctx interface{}, index interface{}, cursorId interface{}, count interface{}) *MockPipeliner_FTCursorRead_Call {
	return &MockPipeliner_FTCursorRead_Call{Call: _e.mock.On("FTCursorRead", ctx, index, cursorId, count)}
}

func (_c *MockPipeliner_FTCursorRead_Call) Run(run func(ctx context.Context, index string, cursorId int, count int)) *MockPipeliner_FTCursorRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_FTCursorRead_Call) Return(_a0 *MapStringInterfaceCmd) *MockPipeliner_FTCursorRead_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTCursorRead_Call) RunAndReturn(run func(context.Context, string, int, int) *MapStringInterfaceCmd) *MockPipeliner_FTCursorRead_Call {
	_c.Call.Return(run)
	return _c
}

// FTDictAdd provides a mock function with given fields: ctx, dict, term
func (_m *MockPipeliner) FTDictAdd(ctx context.Context, dict string, term ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, dict)
	_ca = append(_ca, term...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTDictAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, dict, term...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_FTDictAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTDictAdd'
type MockPipeliner_FTDictAdd_Call struct {
	*mock.Call
}

// FTDictAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - dict string
//   - term ...interface{}
func (_e *MockPipeliner_Expecter) FTDictAdd(ctx interface{}, dict interface{}, term ...interface{}) *MockPipeliner_FTDictAdd_Call {
	return &MockPipeliner_FTDictAdd_Call{Call: _e.mock.On("FTDictAdd",
		append([]interface{}{ctx, dict}, term...)...)}
}

func (_c *MockPipeliner_FTDictAdd_Call) Run(run func(ctx context.Context, dict string, term ...interface{})) *MockPipeliner_FTDictAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FTDictAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_FTDictAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTDictAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_FTDictAdd_Call {
	_c.Call.Return(run)
	return _c
}

// FTDictDel provides a mock function with given fields: ctx, dict, term
func (_m *MockPipeliner) FTDictDel(ctx context.Context, dict string, term ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, dict)
	_ca = append(_ca, term...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FTDictDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, dict, term...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_FTDictDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTDictDel'
type MockPipeliner_FTDictDel_Call struct {
	*mock.Call
}

// FTDictDel is a helper method to define mock.On call
//   - ctx context.Context
//   - dict string
//   - term ...interface{}
func (_e *MockPipeliner_Expecter) FTDictDel(ctx interface{}, dict interface{}, term ...interface{}) *MockPipeliner_FTDictDel_Call {
	return &MockPipeliner_FTDictDel_Call{Call: _e.mock.On("FTDictDel",
		append([]interface{}{ctx, dict}, term...)...)}
}

func (_c *MockPipeliner_FTDictDel_Call) Run(run func(ctx context.Context, dict string, term ...interface{})) *MockPipeliner_FTDictDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_FTDictDel_Call) Return(_a0 *IntCmd) *MockPipeliner_FTDictDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTDictDel_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_FTDictDel_Call {
	_c.Call.Return(run)
	return _c
}

// FTDictDump provides a mock function with given fields: ctx, dict
func (_m *MockPipeliner) FTDictDump(ctx context.Context, dict string) *StringSliceCmd {
	ret := _m.Called(ctx, dict)

	if len(ret) == 0 {
		panic("no return value specified for FTDictDump")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, dict)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_FTDictDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTDictDump'
type MockPipeliner_FTDictDump_Call struct {
	*mock.Call
}

// FTDictDump is a helper method to define mock.On call
//   - ctx context.Context
//   - dict string
func (_e *MockPipeliner_Expecter) FTDictDump(ctx interface{}, dict interface{}) *MockPipeliner_FTDictDump_Call {
	return &MockPipeliner_FTDictDump_Call{Call: _e.mock.On("FTDictDump", ctx, dict)}
}

func (_c *MockPipeliner_FTDictDump_Call) Run(run func(ctx context.Context, dict string)) *MockPipeliner_FTDictDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTDictDump_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_FTDictDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTDictDump_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_FTDictDump_Call {
	_c.Call.Return(run)
	return _c
}

// FTDropIndex provides a mock function with given fields: ctx, index
func (_m *MockPipeliner) FTDropIndex(ctx context.Context, index string) *StatusCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTDropIndex")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTDropIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTDropIndex'
type MockPipeliner_FTDropIndex_Call struct {
	*mock.Call
}

// FTDropIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
func (_e *MockPipeliner_Expecter) FTDropIndex(ctx interface{}, index interface{}) *MockPipeliner_FTDropIndex_Call {
	return &MockPipeliner_FTDropIndex_Call{Call: _e.mock.On("FTDropIndex", ctx, index)}
}

func (_c *MockPipeliner_FTDropIndex_Call) Run(run func(ctx context.Context, index string)) *MockPipeliner_FTDropIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTDropIndex_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTDropIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTDropIndex_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_FTDropIndex_Call {
	_c.Call.Return(run)
	return _c
}

// FTDropIndexWithArgs provides a mock function with given fields: ctx, index, options
func (_m *MockPipeliner) FTDropIndexWithArgs(ctx context.Context, index string, options *FTDropIndexOptions) *StatusCmd {
	ret := _m.Called(ctx, index, options)

	if len(ret) == 0 {
		panic("no return value specified for FTDropIndexWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *FTDropIndexOptions) *StatusCmd); ok {
		r0 = rf(ctx, index, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTDropIndexWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTDropIndexWithArgs'
type MockPipeliner_FTDropIndexWithArgs_Call struct {
	*mock.Call
}

// FTDropIndexWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - options *FTDropIndexOptions
func (_e *MockPipeliner_Expecter) FTDropIndexWithArgs(ctx interface{}, index interface{}, options interface{}) *MockPipeliner_FTDropIndexWithArgs_Call {
	return &MockPipeliner_FTDropIndexWithArgs_Call{Call: _e.mock.On("FTDropIndexWithArgs", ctx, index, options)}
}

func (_c *MockPipeliner_FTDropIndexWithArgs_Call) Run(run func(ctx context.Context, index string, options *FTDropIndexOptions)) *MockPipeliner_FTDropIndexWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*FTDropIndexOptions))
	})
	return _c
}

func (_c *MockPipeliner_FTDropIndexWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTDropIndexWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTDropIndexWithArgs_Call) RunAndReturn(run func(context.Context, string, *FTDropIndexOptions) *StatusCmd) *MockPipeliner_FTDropIndexWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTExplain provides a mock function with given fields: ctx, index, query
func (_m *MockPipeliner) FTExplain(ctx context.Context, index string, query string) *StringCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTExplain")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FTExplain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTExplain'
type MockPipeliner_FTExplain_Call struct {
	*mock.Call
}

// FTExplain is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
func (_e *MockPipeliner_Expecter) FTExplain(ctx interface{}, index interface{}, query interface{}) *MockPipeliner_FTExplain_Call {
	return &MockPipeliner_FTExplain_Call{Call: _e.mock.On("FTExplain", ctx, index, query)}
}

func (_c *MockPipeliner_FTExplain_Call) Run(run func(ctx context.Context, index string, query string)) *MockPipeliner_FTExplain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTExplain_Call) Return(_a0 *StringCmd) *MockPipeliner_FTExplain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTExplain_Call) RunAndReturn(run func(context.Context, string, string) *StringCmd) *MockPipeliner_FTExplain_Call {
	_c.Call.Return(run)
	return _c
}

// FTExplainWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *MockPipeliner) FTExplainWithArgs(ctx context.Context, index string, query string, options *FTExplainOptions) *StringCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTExplainWithArgs")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *FTExplainOptions) *StringCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FTExplainWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTExplainWithArgs'
type MockPipeliner_FTExplainWithArgs_Call struct {
	*mock.Call
}

// FTExplainWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
//   - options *FTExplainOptions
func (_e *MockPipeliner_Expecter) FTExplainWithArgs(ctx interface{}, index interface{}, query interface{}, options interface{}) *MockPipeliner_FTExplainWithArgs_Call {
	return &MockPipeliner_FTExplainWithArgs_Call{Call: _e.mock.On("FTExplainWithArgs", ctx, index, query, options)}
}

func (_c *MockPipeliner_FTExplainWithArgs_Call) Run(run func(ctx context.Context, index string, query string, options *FTExplainOptions)) *MockPipeliner_FTExplainWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*FTExplainOptions))
	})
	return _c
}

func (_c *MockPipeliner_FTExplainWithArgs_Call) Return(_a0 *StringCmd) *MockPipeliner_FTExplainWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTExplainWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *FTExplainOptions) *StringCmd) *MockPipeliner_FTExplainWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTInfo provides a mock function with given fields: ctx, index
func (_m *MockPipeliner) FTInfo(ctx context.Context, index string) *FTInfoCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTInfo")
	}

	var r0 *FTInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *FTInfoCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_FTInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTInfo'
type MockPipeliner_FTInfo_Call struct {
	*mock.Call
}

// FTInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
func (_e *MockPipeliner_Expecter) FTInfo(ctx interface{}, index interface{}) *MockPipeliner_FTInfo_Call {
	return &MockPipeliner_FTInfo_Call{Call: _e.mock.On("FTInfo", ctx, index)}
}

func (_c *MockPipeliner_FTInfo_Call) Run(run func(ctx context.Context, index string)) *MockPipeliner_FTInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTInfo_Call) Return(_a0 *FTInfoCmd) *MockPipeliner_FTInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTInfo_Call) RunAndReturn(run func(context.Context, string) *FTInfoCmd) *MockPipeliner_FTInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FTSearch provides a mock function with given fields: ctx, index, query
func (_m *MockPipeliner) FTSearch(ctx context.Context, index string, query string) *FTSearchCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTSearch")
	}

	var r0 *FTSearchCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *FTSearchCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTSearchCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSearch'
type MockPipeliner_FTSearch_Call struct {
	*mock.Call
}

// FTSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
func (_e *MockPipeliner_Expecter) FTSearch(ctx interface{}, index interface{}, query interface{}) *MockPipeliner_FTSearch_Call {
	return &MockPipeliner_FTSearch_Call{Call: _e.mock.On("FTSearch", ctx, index, query)}
}

func (_c *MockPipeliner_FTSearch_Call) Run(run func(ctx context.Context, index string, query string)) *MockPipeliner_FTSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTSearch_Call) Return(_a0 *FTSearchCmd) *MockPipeliner_FTSearch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSearch_Call) RunAndReturn(run func(context.Context, string, string) *FTSearchCmd) *MockPipeliner_FTSearch_Call {
	_c.Call.Return(run)
	return _c
}

// FTSearchWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *MockPipeliner) FTSearchWithArgs(ctx context.Context, index string, query string, options *FTSearchOptions) *FTSearchCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTSearchWithArgs")
	}

	var r0 *FTSearchCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *FTSearchOptions) *FTSearchCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTSearchCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSearchWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSearchWithArgs'
type MockPipeliner_FTSearchWithArgs_Call struct {
	*mock.Call
}

// FTSearchWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
//   - options *FTSearchOptions
func (_e *MockPipeliner_Expecter) FTSearchWithArgs(ctx interface{}, index interface{}, query interface{}, options interface{}) *MockPipeliner_FTSearchWithArgs_Call {
	return &MockPipeliner_FTSearchWithArgs_Call{Call: _e.mock.On("FTSearchWithArgs", ctx, index, query, options)}
}

func (_c *MockPipeliner_FTSearchWithArgs_Call) Run(run func(ctx context.Context, index string, query string, options *FTSearchOptions)) *MockPipeliner_FTSearchWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*FTSearchOptions))
	})
	return _c
}

func (_c *MockPipeliner_FTSearchWithArgs_Call) Return(_a0 *FTSearchCmd) *MockPipeliner_FTSearchWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSearchWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *FTSearchOptions) *FTSearchCmd) *MockPipeliner_FTSearchWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTSpellCheck provides a mock function with given fields: ctx, index, query
func (_m *MockPipeliner) FTSpellCheck(ctx context.Context, index string, query string) *FTSpellCheckCmd {
	ret := _m.Called(ctx, index, query)

	if len(ret) == 0 {
		panic("no return value specified for FTSpellCheck")
	}

	var r0 *FTSpellCheckCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *FTSpellCheckCmd); ok {
		r0 = rf(ctx, index, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTSpellCheckCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSpellCheck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSpellCheck'
type MockPipeliner_FTSpellCheck_Call struct {
	*mock.Call
}

// FTSpellCheck is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
func (_e *MockPipeliner_Expecter) FTSpellCheck(ctx interface{}, index interface{}, query interface{}) *MockPipeliner_FTSpellCheck_Call {
	return &MockPipeliner_FTSpellCheck_Call{Call: _e.mock.On("FTSpellCheck", ctx, index, query)}
}

func (_c *MockPipeliner_FTSpellCheck_Call) Run(run func(ctx context.Context, index string, query string)) *MockPipeliner_FTSpellCheck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTSpellCheck_Call) Return(_a0 *FTSpellCheckCmd) *MockPipeliner_FTSpellCheck_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSpellCheck_Call) RunAndReturn(run func(context.Context, string, string) *FTSpellCheckCmd) *MockPipeliner_FTSpellCheck_Call {
	_c.Call.Return(run)
	return _c
}

// FTSpellCheckWithArgs provides a mock function with given fields: ctx, index, query, options
func (_m *MockPipeliner) FTSpellCheckWithArgs(ctx context.Context, index string, query string, options *FTSpellCheckOptions) *FTSpellCheckCmd {
	ret := _m.Called(ctx, index, query, options)

	if len(ret) == 0 {
		panic("no return value specified for FTSpellCheckWithArgs")
	}

	var r0 *FTSpellCheckCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *FTSpellCheckOptions) *FTSpellCheckCmd); ok {
		r0 = rf(ctx, index, query, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTSpellCheckCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSpellCheckWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSpellCheckWithArgs'
type MockPipeliner_FTSpellCheckWithArgs_Call struct {
	*mock.Call
}

// FTSpellCheckWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - query string
//   - options *FTSpellCheckOptions
func (_e *MockPipeliner_Expecter) FTSpellCheckWithArgs(ctx interface{}, index interface{}, query interface{}, options interface{}) *MockPipeliner_FTSpellCheckWithArgs_Call {
	return &MockPipeliner_FTSpellCheckWithArgs_Call{Call: _e.mock.On("FTSpellCheckWithArgs", ctx, index, query, options)}
}

func (_c *MockPipeliner_FTSpellCheckWithArgs_Call) Run(run func(ctx context.Context, index string, query string, options *FTSpellCheckOptions)) *MockPipeliner_FTSpellCheckWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*FTSpellCheckOptions))
	})
	return _c
}

func (_c *MockPipeliner_FTSpellCheckWithArgs_Call) Return(_a0 *FTSpellCheckCmd) *MockPipeliner_FTSpellCheckWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSpellCheckWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *FTSpellCheckOptions) *FTSpellCheckCmd) *MockPipeliner_FTSpellCheckWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTSynDump provides a mock function with given fields: ctx, index
func (_m *MockPipeliner) FTSynDump(ctx context.Context, index string) *FTSynDumpCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for FTSynDump")
	}

	var r0 *FTSynDumpCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *FTSynDumpCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FTSynDumpCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSynDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSynDump'
type MockPipeliner_FTSynDump_Call struct {
	*mock.Call
}

// FTSynDump is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
func (_e *MockPipeliner_Expecter) FTSynDump(ctx interface{}, index interface{}) *MockPipeliner_FTSynDump_Call {
	return &MockPipeliner_FTSynDump_Call{Call: _e.mock.On("FTSynDump", ctx, index)}
}

func (_c *MockPipeliner_FTSynDump_Call) Run(run func(ctx context.Context, index string)) *MockPipeliner_FTSynDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTSynDump_Call) Return(_a0 *FTSynDumpCmd) *MockPipeliner_FTSynDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSynDump_Call) RunAndReturn(run func(context.Context, string) *FTSynDumpCmd) *MockPipeliner_FTSynDump_Call {
	_c.Call.Return(run)
	return _c
}

// FTSynUpdate provides a mock function with given fields: ctx, index, synGroupId, terms
func (_m *MockPipeliner) FTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *StatusCmd {
	ret := _m.Called(ctx, index, synGroupId, terms)

	if len(ret) == 0 {
		panic("no return value specified for FTSynUpdate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, []interface{}) *StatusCmd); ok {
		r0 = rf(ctx, index, synGroupId, terms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSynUpdate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSynUpdate'
type MockPipeliner_FTSynUpdate_Call struct {
	*mock.Call
}

// FTSynUpdate is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - synGroupId interface{}
//   - terms []interface{}
func (_e *MockPipeliner_Expecter) FTSynUpdate(ctx interface{}, index interface{}, synGroupId interface{}, terms interface{}) *MockPipeliner_FTSynUpdate_Call {
	return &MockPipeliner_FTSynUpdate_Call{Call: _e.mock.On("FTSynUpdate", ctx, index, synGroupId, terms)}
}

func (_c *MockPipeliner_FTSynUpdate_Call) Run(run func(ctx context.Context, index string, synGroupId interface{}, terms []interface{})) *MockPipeliner_FTSynUpdate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].([]interface{}))
	})
	return _c
}

func (_c *MockPipeliner_FTSynUpdate_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTSynUpdate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSynUpdate_Call) RunAndReturn(run func(context.Context, string, interface{}, []interface{}) *StatusCmd) *MockPipeliner_FTSynUpdate_Call {
	_c.Call.Return(run)
	return _c
}

// FTSynUpdateWithArgs provides a mock function with given fields: ctx, index, synGroupId, options, terms
func (_m *MockPipeliner) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *FTSynUpdateOptions, terms []interface{}) *StatusCmd {
	ret := _m.Called(ctx, index, synGroupId, options, terms)

	if len(ret) == 0 {
		panic("no return value specified for FTSynUpdateWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, *FTSynUpdateOptions, []interface{}) *StatusCmd); ok {
		r0 = rf(ctx, index, synGroupId, options, terms)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FTSynUpdateWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTSynUpdateWithArgs'
type MockPipeliner_FTSynUpdateWithArgs_Call struct {
	*mock.Call
}

// FTSynUpdateWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - synGroupId interface{}
//   - options *FTSynUpdateOptions
//   - terms []interface{}
func (_e *MockPipeliner_Expecter) FTSynUpdateWithArgs(ctx interface{}, index interface{}, synGroupId interface{}, options interface{}, terms interface{}) *MockPipeliner_FTSynUpdateWithArgs_Call {
	return &MockPipeliner_FTSynUpdateWithArgs_Call{Call: _e.mock.On("FTSynUpdateWithArgs", ctx, index, synGroupId, options, terms)}
}

func (_c *MockPipeliner_FTSynUpdateWithArgs_Call) Run(run func(ctx context.Context, index string, synGroupId interface{}, options *FTSynUpdateOptions, terms []interface{})) *MockPipeliner_FTSynUpdateWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(*FTSynUpdateOptions), args[4].([]interface{}))
	})
	return _c
}

func (_c *MockPipeliner_FTSynUpdateWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_FTSynUpdateWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTSynUpdateWithArgs_Call) RunAndReturn(run func(context.Context, string, interface{}, *FTSynUpdateOptions, []interface{}) *StatusCmd) *MockPipeliner_FTSynUpdateWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// FTTagVals provides a mock function with given fields: ctx, index, field
func (_m *MockPipeliner) FTTagVals(ctx context.Context, index string, field string) *StringSliceCmd {
	ret := _m.Called(ctx, index, field)

	if len(ret) == 0 {
		panic("no return value specified for FTTagVals")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringSliceCmd); ok {
		r0 = rf(ctx, index, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_FTTagVals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FTTagVals'
type MockPipeliner_FTTagVals_Call struct {
	*mock.Call
}

// FTTagVals is a helper method to define mock.On call
//   - ctx context.Context
//   - index string
//   - field string
func (_e *MockPipeliner_Expecter) FTTagVals(ctx interface{}, index interface{}, field interface{}) *MockPipeliner_FTTagVals_Call {
	return &MockPipeliner_FTTagVals_Call{Call: _e.mock.On("FTTagVals", ctx, index, field)}
}

func (_c *MockPipeliner_FTTagVals_Call) Run(run func(ctx context.Context, index string, field string)) *MockPipeliner_FTTagVals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_FTTagVals_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_FTTagVals_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FTTagVals_Call) RunAndReturn(run func(context.Context, string, string) *StringSliceCmd) *MockPipeliner_FTTagVals_Call {
	_c.Call.Return(run)
	return _c
}

// FT_List provides a mock function with given fields: ctx
func (_m *MockPipeliner) FT_List(ctx context.Context) *StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FT_List")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_FT_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FT_List'
type MockPipeliner_FT_List_Call struct {
	*mock.Call
}

// FT_List is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FT_List(ctx interface{}) *MockPipeliner_FT_List_Call {
	return &MockPipeliner_FT_List_Call{Call: _e.mock.On("FT_List", ctx)}
}

func (_c *MockPipeliner_FT_List_Call) Run(run func(ctx context.Context)) *MockPipeliner_FT_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FT_List_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_FT_List_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FT_List_Call) RunAndReturn(run func(context.Context) *StringSliceCmd) *MockPipeliner_FT_List_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAll provides a mock function with given fields: ctx
func (_m *MockPipeliner) FlushAll(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FlushAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAll'
type MockPipeliner_FlushAll_Call struct {
	*mock.Call
}

// FlushAll is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FlushAll(ctx interface{}) *MockPipeliner_FlushAll_Call {
	return &MockPipeliner_FlushAll_Call{Call: _e.mock.On("FlushAll", ctx)}
}

func (_c *MockPipeliner_FlushAll_Call) Run(run func(ctx context.Context)) *MockPipeliner_FlushAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FlushAll_Call) Return(_a0 *StatusCmd) *MockPipeliner_FlushAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FlushAll_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_FlushAll_Call {
	_c.Call.Return(run)
	return _c
}

// FlushAllAsync provides a mock function with given fields: ctx
func (_m *MockPipeliner) FlushAllAsync(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushAllAsync")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FlushAllAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushAllAsync'
type MockPipeliner_FlushAllAsync_Call struct {
	*mock.Call
}

// FlushAllAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FlushAllAsync(ctx interface{}) *MockPipeliner_FlushAllAsync_Call {
	return &MockPipeliner_FlushAllAsync_Call{Call: _e.mock.On("FlushAllAsync", ctx)}
}

func (_c *MockPipeliner_FlushAllAsync_Call) Run(run func(ctx context.Context)) *MockPipeliner_FlushAllAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FlushAllAsync_Call) Return(_a0 *StatusCmd) *MockPipeliner_FlushAllAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FlushAllAsync_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_FlushAllAsync_Call {
	_c.Call.Return(run)
	return _c
}

// FlushDB provides a mock function with given fields: ctx
func (_m *MockPipeliner) FlushDB(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDB")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FlushDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushDB'
type MockPipeliner_FlushDB_Call struct {
	*mock.Call
}

// FlushDB is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FlushDB(ctx interface{}) *MockPipeliner_FlushDB_Call {
	return &MockPipeliner_FlushDB_Call{Call: _e.mock.On("FlushDB", ctx)}
}

func (_c *MockPipeliner_FlushDB_Call) Run(run func(ctx context.Context)) *MockPipeliner_FlushDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FlushDB_Call) Return(_a0 *StatusCmd) *MockPipeliner_FlushDB_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FlushDB_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_FlushDB_Call {
	_c.Call.Return(run)
	return _c
}

// FlushDBAsync provides a mock function with given fields: ctx
func (_m *MockPipeliner) FlushDBAsync(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FlushDBAsync")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_FlushDBAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FlushDBAsync'
type MockPipeliner_FlushDBAsync_Call struct {
	*mock.Call
}

// FlushDBAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FlushDBAsync(ctx interface{}) *MockPipeliner_FlushDBAsync_Call {
	return &MockPipeliner_FlushDBAsync_Call{Call: _e.mock.On("FlushDBAsync", ctx)}
}

func (_c *MockPipeliner_FlushDBAsync_Call) Run(run func(ctx context.Context)) *MockPipeliner_FlushDBAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FlushDBAsync_Call) Return(_a0 *StatusCmd) *MockPipeliner_FlushDBAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FlushDBAsync_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_FlushDBAsync_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionDelete provides a mock function with given fields: ctx, libName
func (_m *MockPipeliner) FunctionDelete(ctx context.Context, libName string) *StringCmd {
	ret := _m.Called(ctx, libName)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDelete")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, libName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionDelete'
type MockPipeliner_FunctionDelete_Call struct {
	*mock.Call
}

// FunctionDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
func (_e *MockPipeliner_Expecter) FunctionDelete(ctx interface{}, libName interface{}) *MockPipeliner_FunctionDelete_Call {
	return &MockPipeliner_FunctionDelete_Call{Call: _e.mock.On("FunctionDelete", ctx, libName)}
}

func (_c *MockPipeliner_FunctionDelete_Call) Run(run func(ctx context.Context, libName string)) *MockPipeliner_FunctionDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FunctionDelete_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionDelete_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_FunctionDelete_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionDump provides a mock function with given fields: ctx
func (_m *MockPipeliner) FunctionDump(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDump")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionDump'
type MockPipeliner_FunctionDump_Call struct {
	*mock.Call
}

// FunctionDump is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FunctionDump(ctx interface{}) *MockPipeliner_FunctionDump_Call {
	return &MockPipeliner_FunctionDump_Call{Call: _e.mock.On("FunctionDump", ctx)}
}

func (_c *MockPipeliner_FunctionDump_Call) Run(run func(ctx context.Context)) *MockPipeliner_FunctionDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FunctionDump_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionDump_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_FunctionDump_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionFlush provides a mock function with given fields: ctx
func (_m *MockPipeliner) FunctionFlush(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionFlush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionFlush'
type MockPipeliner_FunctionFlush_Call struct {
	*mock.Call
}

// FunctionFlush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FunctionFlush(ctx interface{}) *MockPipeliner_FunctionFlush_Call {
	return &MockPipeliner_FunctionFlush_Call{Call: _e.mock.On("FunctionFlush", ctx)}
}

func (_c *MockPipeliner_FunctionFlush_Call) Run(run func(ctx context.Context)) *MockPipeliner_FunctionFlush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FunctionFlush_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionFlush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionFlush_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_FunctionFlush_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionFlushAsync provides a mock function with given fields: ctx
func (_m *MockPipeliner) FunctionFlushAsync(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlushAsync")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionFlushAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionFlushAsync'
type MockPipeliner_FunctionFlushAsync_Call struct {
	*mock.Call
}

// FunctionFlushAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FunctionFlushAsync(ctx interface{}) *MockPipeliner_FunctionFlushAsync_Call {
	return &MockPipeliner_FunctionFlushAsync_Call{Call: _e.mock.On("FunctionFlushAsync", ctx)}
}

func (_c *MockPipeliner_FunctionFlushAsync_Call) Run(run func(ctx context.Context)) *MockPipeliner_FunctionFlushAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FunctionFlushAsync_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionFlushAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionFlushAsync_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_FunctionFlushAsync_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionKill provides a mock function with given fields: ctx
func (_m *MockPipeliner) FunctionKill(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionKill")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionKill'
type MockPipeliner_FunctionKill_Call struct {
	*mock.Call
}

// FunctionKill is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FunctionKill(ctx interface{}) *MockPipeliner_FunctionKill_Call {
	return &MockPipeliner_FunctionKill_Call{Call: _e.mock.On("FunctionKill", ctx)}
}

func (_c *MockPipeliner_FunctionKill_Call) Run(run func(ctx context.Context)) *MockPipeliner_FunctionKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FunctionKill_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionKill_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_FunctionKill_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionList provides a mock function with given fields: ctx, q
func (_m *MockPipeliner) FunctionList(ctx context.Context, q FunctionListQuery) *FunctionListCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for FunctionList")
	}

	var r0 *FunctionListCmd
	if rf, ok := ret.Get(0).(func(context.Context, FunctionListQuery) *FunctionListCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FunctionListCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionList'
type MockPipeliner_FunctionList_Call struct {
	*mock.Call
}

// FunctionList is a helper method to define mock.On call
//   - ctx context.Context
//   - q FunctionListQuery
func (_e *MockPipeliner_Expecter) FunctionList(ctx interface{}, q interface{}) *MockPipeliner_FunctionList_Call {
	return &MockPipeliner_FunctionList_Call{Call: _e.mock.On("FunctionList", ctx, q)}
}

func (_c *MockPipeliner_FunctionList_Call) Run(run func(ctx context.Context, q FunctionListQuery)) *MockPipeliner_FunctionList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(FunctionListQuery))
	})
	return _c
}

func (_c *MockPipeliner_FunctionList_Call) Return(_a0 *FunctionListCmd) *MockPipeliner_FunctionList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionList_Call) RunAndReturn(run func(context.Context, FunctionListQuery) *FunctionListCmd) *MockPipeliner_FunctionList_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionLoad provides a mock function with given fields: ctx, code
func (_m *MockPipeliner) FunctionLoad(ctx context.Context, code string) *StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoad")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionLoad'
type MockPipeliner_FunctionLoad_Call struct {
	*mock.Call
}

// FunctionLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *MockPipeliner_Expecter) FunctionLoad(ctx interface{}, code interface{}) *MockPipeliner_FunctionLoad_Call {
	return &MockPipeliner_FunctionLoad_Call{Call: _e.mock.On("FunctionLoad", ctx, code)}
}

func (_c *MockPipeliner_FunctionLoad_Call) Run(run func(ctx context.Context, code string)) *MockPipeliner_FunctionLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FunctionLoad_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionLoad_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_FunctionLoad_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionLoadReplace provides a mock function with given fields: ctx, code
func (_m *MockPipeliner) FunctionLoadReplace(ctx context.Context, code string) *StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoadReplace")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionLoadReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionLoadReplace'
type MockPipeliner_FunctionLoadReplace_Call struct {
	*mock.Call
}

// FunctionLoadReplace is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *MockPipeliner_Expecter) FunctionLoadReplace(ctx interface{}, code interface{}) *MockPipeliner_FunctionLoadReplace_Call {
	return &MockPipeliner_FunctionLoadReplace_Call{Call: _e.mock.On("FunctionLoadReplace", ctx, code)}
}

func (_c *MockPipeliner_FunctionLoadReplace_Call) Run(run func(ctx context.Context, code string)) *MockPipeliner_FunctionLoadReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FunctionLoadReplace_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionLoadReplace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionLoadReplace_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_FunctionLoadReplace_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionRestore provides a mock function with given fields: ctx, libDump
func (_m *MockPipeliner) FunctionRestore(ctx context.Context, libDump string) *StringCmd {
	ret := _m.Called(ctx, libDump)

	if len(ret) == 0 {
		panic("no return value specified for FunctionRestore")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, libDump)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionRestore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionRestore'
type MockPipeliner_FunctionRestore_Call struct {
	*mock.Call
}

// FunctionRestore is a helper method to define mock.On call
//   - ctx context.Context
//   - libDump string
func (_e *MockPipeliner_Expecter) FunctionRestore(ctx interface{}, libDump interface{}) *MockPipeliner_FunctionRestore_Call {
	return &MockPipeliner_FunctionRestore_Call{Call: _e.mock.On("FunctionRestore", ctx, libDump)}
}

func (_c *MockPipeliner_FunctionRestore_Call) Run(run func(ctx context.Context, libDump string)) *MockPipeliner_FunctionRestore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_FunctionRestore_Call) Return(_a0 *StringCmd) *MockPipeliner_FunctionRestore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionRestore_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_FunctionRestore_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionStats provides a mock function with given fields: ctx
func (_m *MockPipeliner) FunctionStats(ctx context.Context) *FunctionStatsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionStats")
	}

	var r0 *FunctionStatsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *FunctionStatsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FunctionStatsCmd)
		}
	}

	return r0
}

// MockPipeliner_FunctionStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionStats'
type MockPipeliner_FunctionStats_Call struct {
	*mock.Call
}

// FunctionStats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) FunctionStats(ctx interface{}) *MockPipeliner_FunctionStats_Call {
	return &MockPipeliner_FunctionStats_Call{Call: _e.mock.On("FunctionStats", ctx)}
}

func (_c *MockPipeliner_FunctionStats_Call) Run(run func(ctx context.Context)) *MockPipeliner_FunctionStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_FunctionStats_Call) Return(_a0 *FunctionStatsCmd) *MockPipeliner_FunctionStats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_FunctionStats_Call) RunAndReturn(run func(context.Context) *FunctionStatsCmd) *MockPipeliner_FunctionStats_Call {
	_c.Call.Return(run)
	return _c
}

// GeoAdd provides a mock function with given fields: ctx, key, geoLocation
func (_m *MockPipeliner) GeoAdd(ctx context.Context, key string, geoLocation ...*GeoLocation) *IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*GeoLocation) *IntCmd); ok {
		r0 = rf(ctx, key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoAdd'
type MockPipeliner_GeoAdd_Call struct {
	*mock.Call
}

// GeoAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - geoLocation ...*GeoLocation
func (_e *MockPipeliner_Expecter) GeoAdd(ctx interface{}, key interface{}, geoLocation ...interface{}) *MockPipeliner_GeoAdd_Call {
	return &MockPipeliner_GeoAdd_Call{Call: _e.mock.On("GeoAdd",
		append([]interface{}{ctx, key}, geoLocation...)...)}
}

func (_c *MockPipeliner_GeoAdd_Call) Run(run func(ctx context.Context, key string, geoLocation ...*GeoLocation)) *MockPipeliner_GeoAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*GeoLocation, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*GeoLocation)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_GeoAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_GeoAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoAdd_Call) RunAndReturn(run func(context.Context, string, ...*GeoLocation) *IntCmd) *MockPipeliner_GeoAdd_Call {
	_c.Call.Return(run)
	return _c
}

// GeoDist provides a mock function with given fields: ctx, key, member1, member2, unit
func (_m *MockPipeliner) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *FloatCmd {
	ret := _m.Called(ctx, key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *FloatCmd); ok {
		r0 = rf(ctx, key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoDist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoDist'
type MockPipeliner_GeoDist_Call struct {
	*mock.Call
}

// GeoDist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member1 string
//   - member2 string
//   - unit string
func (_e *MockPipeliner_Expecter) GeoDist(ctx interface{}, key interface{}, member1 interface{}, member2 interface{}, unit interface{}) *MockPipeliner_GeoDist_Call {
	return &MockPipeliner_GeoDist_Call{Call: _e.mock.On("GeoDist", ctx, key, member1, member2, unit)}
}

func (_c *MockPipeliner_GeoDist_Call) Run(run func(ctx context.Context, key string, member1 string, member2 string, unit string)) *MockPipeliner_GeoDist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockPipeliner_GeoDist_Call) Return(_a0 *FloatCmd) *MockPipeliner_GeoDist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoDist_Call) RunAndReturn(run func(context.Context, string, string, string, string) *FloatCmd) *MockPipeliner_GeoDist_Call {
	_c.Call.Return(run)
	return _c
}

// GeoHash provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) GeoHash(ctx context.Context, key string, members ...string) *StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoHash'
type MockPipeliner_GeoHash_Call struct {
	*mock.Call
}

// GeoHash is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockPipeliner_Expecter) GeoHash(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_GeoHash_Call {
	return &MockPipeliner_GeoHash_Call{Call: _e.mock.On("GeoHash",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_GeoHash_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockPipeliner_GeoHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_GeoHash_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_GeoHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoHash_Call) RunAndReturn(run func(context.Context, string, ...string) *StringSliceCmd) *MockPipeliner_GeoHash_Call {
	_c.Call.Return(run)
	return _c
}

// GeoPos provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) GeoPos(ctx context.Context, key string, members ...string) *GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *GeoPosCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *GeoPosCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoPosCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoPos'
type MockPipeliner_GeoPos_Call struct {
	*mock.Call
}

// GeoPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockPipeliner_Expecter) GeoPos(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_GeoPos_Call {
	return &MockPipeliner_GeoPos_Call{Call: _e.mock.On("GeoPos",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_GeoPos_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockPipeliner_GeoPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_GeoPos_Call) Return(_a0 *GeoPosCmd) *MockPipeliner_GeoPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoPos_Call) RunAndReturn(run func(context.Context, string, ...string) *GeoPosCmd) *MockPipeliner_GeoPos_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadius provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockPipeliner) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery) *GeoLocationCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *GeoRadiusQuery) *GeoLocationCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoLocationCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoRadius_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadius'
type MockPipeliner_GeoRadius_Call struct {
	*mock.Call
}

// GeoRadius is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *GeoRadiusQuery
func (_e *MockPipeliner_Expecter) GeoRadius(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockPipeliner_GeoRadius_Call {
	return &MockPipeliner_GeoRadius_Call{Call: _e.mock.On("GeoRadius", ctx, key, longitude, latitude, query)}
}

func (_c *MockPipeliner_GeoRadius_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery)) *MockPipeliner_GeoRadius_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoRadius_Call) Return(_a0 *GeoLocationCmd) *MockPipeliner_GeoRadius_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoRadius_Call) RunAndReturn(run func(context.Context, string, float64, float64, *GeoRadiusQuery) *GeoLocationCmd) *MockPipeliner_GeoRadius_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMember provides a mock function with given fields: ctx, key, member, query
func (_m *MockPipeliner) GeoRadiusByMember(ctx context.Context, key string, member string, query *GeoRadiusQuery) *GeoLocationCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoRadiusQuery) *GeoLocationCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoLocationCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoRadiusByMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMember'
type MockPipeliner_GeoRadiusByMember_Call struct {
	*mock.Call
}

// GeoRadiusByMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *GeoRadiusQuery
func (_e *MockPipeliner_Expecter) GeoRadiusByMember(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockPipeliner_GeoRadiusByMember_Call {
	return &MockPipeliner_GeoRadiusByMember_Call{Call: _e.mock.On("GeoRadiusByMember", ctx, key, member, query)}
}

func (_c *MockPipeliner_GeoRadiusByMember_Call) Run(run func(ctx context.Context, key string, member string, query *GeoRadiusQuery)) *MockPipeliner_GeoRadiusByMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoRadiusByMember_Call) Return(_a0 *GeoLocationCmd) *MockPipeliner_GeoRadiusByMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoRadiusByMember_Call) RunAndReturn(run func(context.Context, string, string, *GeoRadiusQuery) *GeoLocationCmd) *MockPipeliner_GeoRadiusByMember_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMemberStore provides a mock function with given fields: ctx, key, member, query
func (_m *MockPipeliner) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *GeoRadiusQuery) *IntCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoRadiusQuery) *IntCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoRadiusByMemberStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMemberStore'
type MockPipeliner_GeoRadiusByMemberStore_Call struct {
	*mock.Call
}

// GeoRadiusByMemberStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *GeoRadiusQuery
func (_e *MockPipeliner_Expecter) GeoRadiusByMemberStore(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockPipeliner_GeoRadiusByMemberStore_Call {
	return &MockPipeliner_GeoRadiusByMemberStore_Call{Call: _e.mock.On("GeoRadiusByMemberStore", ctx, key, member, query)}
}

func (_c *MockPipeliner_GeoRadiusByMemberStore_Call) Run(run func(ctx context.Context, key string, member string, query *GeoRadiusQuery)) *MockPipeliner_GeoRadiusByMemberStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoRadiusByMemberStore_Call) Return(_a0 *IntCmd) *MockPipeliner_GeoRadiusByMemberStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoRadiusByMemberStore_Call) RunAndReturn(run func(context.Context, string, string, *GeoRadiusQuery) *IntCmd) *MockPipeliner_GeoRadiusByMemberStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusStore provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockPipeliner) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery) *IntCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *GeoRadiusQuery) *IntCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoRadiusStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusStore'
type MockPipeliner_GeoRadiusStore_Call struct {
	*mock.Call
}

// GeoRadiusStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *GeoRadiusQuery
func (_e *MockPipeliner_Expecter) GeoRadiusStore(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockPipeliner_GeoRadiusStore_Call {
	return &MockPipeliner_GeoRadiusStore_Call{Call: _e.mock.On("GeoRadiusStore", ctx, key, longitude, latitude, query)}
}

func (_c *MockPipeliner_GeoRadiusStore_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery)) *MockPipeliner_GeoRadiusStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoRadiusStore_Call) Return(_a0 *IntCmd) *MockPipeliner_GeoRadiusStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoRadiusStore_Call) RunAndReturn(run func(context.Context, string, float64, float64, *GeoRadiusQuery) *IntCmd) *MockPipeliner_GeoRadiusStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearch provides a mock function with given fields: ctx, key, q
func (_m *MockPipeliner) GeoSearch(ctx context.Context, key string, q *GeoSearchQuery) *StringSliceCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *GeoSearchQuery) *StringSliceCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearch'
type MockPipeliner_GeoSearch_Call struct {
	*mock.Call
}

// GeoSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *GeoSearchQuery
func (_e *MockPipeliner_Expecter) GeoSearch(ctx interface{}, key interface{}, q interface{}) *MockPipeliner_GeoSearch_Call {
	return &MockPipeliner_GeoSearch_Call{Call: _e.mock.On("GeoSearch", ctx, key, q)}
}

func (_c *MockPipeliner_GeoSearch_Call) Run(run func(ctx context.Context, key string, q *GeoSearchQuery)) *MockPipeliner_GeoSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*GeoSearchQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoSearch_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_GeoSearch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoSearch_Call) RunAndReturn(run func(context.Context, string, *GeoSearchQuery) *StringSliceCmd) *MockPipeliner_GeoSearch_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchLocation provides a mock function with given fields: ctx, key, q
func (_m *MockPipeliner) GeoSearchLocation(ctx context.Context, key string, q *GeoSearchLocationQuery) *GeoSearchLocationCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchLocation")
	}

	var r0 *GeoSearchLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *GeoSearchLocationQuery) *GeoSearchLocationCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoSearchLocationCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoSearchLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchLocation'
type MockPipeliner_GeoSearchLocation_Call struct {
	*mock.Call
}

// GeoSearchLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *GeoSearchLocationQuery
func (_e *MockPipeliner_Expecter) GeoSearchLocation(ctx interface{}, key interface{}, q interface{}) *MockPipeliner_GeoSearchLocation_Call {
	return &MockPipeliner_GeoSearchLocation_Call{Call: _e.mock.On("GeoSearchLocation", ctx, key, q)}
}

func (_c *MockPipeliner_GeoSearchLocation_Call) Run(run func(ctx context.Context, key string, q *GeoSearchLocationQuery)) *MockPipeliner_GeoSearchLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*GeoSearchLocationQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoSearchLocation_Call) Return(_a0 *GeoSearchLocationCmd) *MockPipeliner_GeoSearchLocation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoSearchLocation_Call) RunAndReturn(run func(context.Context, string, *GeoSearchLocationQuery) *GeoSearchLocationCmd) *MockPipeliner_GeoSearchLocation_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchStore provides a mock function with given fields: ctx, key, store, q
func (_m *MockPipeliner) GeoSearchStore(ctx context.Context, key string, store string, q *GeoSearchStoreQuery) *IntCmd {
	ret := _m.Called(ctx, key, store, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoSearchStoreQuery) *IntCmd); ok {
		r0 = rf(ctx, key, store, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_GeoSearchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchStore'
type MockPipeliner_GeoSearchStore_Call struct {
	*mock.Call
}

// GeoSearchStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - q *GeoSearchStoreQuery
func (_e *MockPipeliner_Expecter) GeoSearchStore(ctx interface{}, key interface{}, store interface{}, q interface{}) *MockPipeliner_GeoSearchStore_Call {
	return &MockPipeliner_GeoSearchStore_Call{Call: _e.mock.On("GeoSearchStore", ctx, key, store, q)}
}

func (_c *MockPipeliner_GeoSearchStore_Call) Run(run func(ctx context.Context, key string, store string, q *GeoSearchStoreQuery)) *MockPipeliner_GeoSearchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoSearchStoreQuery))
	})
	return _c
}

func (_c *MockPipeliner_GeoSearchStore_Call) Return(_a0 *IntCmd) *MockPipeliner_GeoSearchStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GeoSearchStore_Call) RunAndReturn(run func(context.Context, string, string, *GeoSearchStoreQuery) *IntCmd) *MockPipeliner_GeoSearchStore_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Get(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockPipeliner_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Get(ctx interface{}, key interface{}) *MockPipeliner_Get_Call {
	return &MockPipeliner_Get_Call{Call: _e.mock.On("Get", ctx, key)}
}

func (_c *MockPipeliner_Get_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Get_Call) Return(_a0 *StringCmd) *MockPipeliner_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Get_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *MockPipeliner) GetBit(ctx context.Context, key string, offset int64) *IntCmd {
	ret := _m.Called(ctx, key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_GetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBit'
type MockPipeliner_GetBit_Call struct {
	*mock.Call
}

// GetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
func (_e *MockPipeliner_Expecter) GetBit(ctx interface{}, key interface{}, offset interface{}) *MockPipeliner_GetBit_Call {
	return &MockPipeliner_GetBit_Call{Call: _e.mock.On("GetBit", ctx, key, offset)}
}

func (_c *MockPipeliner_GetBit_Call) Run(run func(ctx context.Context, key string, offset int64)) *MockPipeliner_GetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_GetBit_Call) Return(_a0 *IntCmd) *MockPipeliner_GetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GetBit_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockPipeliner_GetBit_Call {
	_c.Call.Return(run)
	return _c
}

// GetDel provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) GetDel(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetDel")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_GetDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDel'
type MockPipeliner_GetDel_Call struct {
	*mock.Call
}

// GetDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) GetDel(ctx interface{}, key interface{}) *MockPipeliner_GetDel_Call {
	return &MockPipeliner_GetDel_Call{Call: _e.mock.On("GetDel", ctx, key)}
}

func (_c *MockPipeliner_GetDel_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_GetDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_GetDel_Call) Return(_a0 *StringCmd) *MockPipeliner_GetDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GetDel_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_GetDel_Call {
	_c.Call.Return(run)
	return _c
}

// GetEx provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) GetEx(ctx context.Context, key string, expiration time.Duration) *StringCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for GetEx")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_GetEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEx'
type MockPipeliner_GetEx_Call struct {
	*mock.Call
}

// GetEx is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) GetEx(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_GetEx_Call {
	return &MockPipeliner_GetEx_Call{Call: _e.mock.On("GetEx", ctx, key, expiration)}
}

func (_c *MockPipeliner_GetEx_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_GetEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_GetEx_Call) Return(_a0 *StringCmd) *MockPipeliner_GetEx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GetEx_Call) RunAndReturn(run func(context.Context, string, time.Duration) *StringCmd) *MockPipeliner_GetEx_Call {
	_c.Call.Return(run)
	return _c
}

// GetRange provides a mock function with given fields: ctx, key, start, end
func (_m *MockPipeliner) GetRange(ctx context.Context, key string, start int64, end int64) *StringCmd {
	ret := _m.Called(ctx, key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringCmd); ok {
		r0 = rf(ctx, key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_GetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRange'
type MockPipeliner_GetRange_Call struct {
	*mock.Call
}

// GetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - end int64
func (_e *MockPipeliner_Expecter) GetRange(ctx interface{}, key interface{}, start interface{}, end interface{}) *MockPipeliner_GetRange_Call {
	return &MockPipeliner_GetRange_Call{Call: _e.mock.On("GetRange", ctx, key, start, end)}
}

func (_c *MockPipeliner_GetRange_Call) Run(run func(ctx context.Context, key string, start int64, end int64)) *MockPipeliner_GetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_GetRange_Call) Return(_a0 *StringCmd) *MockPipeliner_GetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GetRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringCmd) *MockPipeliner_GetRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetSet provides a mock function with given fields: ctx, key, value
func (_m *MockPipeliner) GetSet(ctx context.Context, key string, value interface{}) *StringCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *StringCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_GetSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSet'
type MockPipeliner_GetSet_Call struct {
	*mock.Call
}

// GetSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *MockPipeliner_Expecter) GetSet(ctx interface{}, key interface{}, value interface{}) *MockPipeliner_GetSet_Call {
	return &MockPipeliner_GetSet_Call{Call: _e.mock.On("GetSet", ctx, key, value)}
}

func (_c *MockPipeliner_GetSet_Call) Run(run func(ctx context.Context, key string, value interface{})) *MockPipeliner_GetSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_GetSet_Call) Return(_a0 *StringCmd) *MockPipeliner_GetSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_GetSet_Call) RunAndReturn(run func(context.Context, string, interface{}) *StringCmd) *MockPipeliner_GetSet_Call {
	_c.Call.Return(run)
	return _c
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HDel(ctx context.Context, key string, fields ...string) *IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_HDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HDel'
type MockPipeliner_HDel_Call struct {
	*mock.Call
}

// HDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HDel(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HDel_Call {
	return &MockPipeliner_HDel_Call{Call: _e.mock.On("HDel",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HDel_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HDel_Call) Return(_a0 *IntCmd) *MockPipeliner_HDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HDel_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_HDel_Call {
	_c.Call.Return(run)
	return _c
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *MockPipeliner) HExists(ctx context.Context, key string, field string) *BoolCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *BoolCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_HExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExists'
type MockPipeliner_HExists_Call struct {
	*mock.Call
}

// HExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockPipeliner_Expecter) HExists(ctx interface{}, key interface{}, field interface{}) *MockPipeliner_HExists_Call {
	return &MockPipeliner_HExists_Call{Call: _e.mock.On("HExists", ctx, key, field)}
}

func (_c *MockPipeliner_HExists_Call) Run(run func(ctx context.Context, key string, field string)) *MockPipeliner_HExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_HExists_Call) Return(_a0 *BoolCmd) *MockPipeliner_HExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExists_Call) RunAndReturn(run func(context.Context, string, string) *BoolCmd) *MockPipeliner_HExists_Call {
	_c.Call.Return(run)
	return _c
}

// HExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *MockPipeliner) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpire")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpire'
type MockPipeliner_HExpire_Call struct {
	*mock.Call
}

// HExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - fields ...string
func (_e *MockPipeliner_Expecter) HExpire(ctx interface{}, key interface{}, expiration interface{}, fields ...interface{}) *MockPipeliner_HExpire_Call {
	return &MockPipeliner_HExpire_Call{Call: _e.mock.On("HExpire",
		append([]interface{}{ctx, key, expiration}, fields...)...)}
}

func (_c *MockPipeliner_HExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, fields ...string)) *MockPipeliner_HExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HExpire_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration, ...string) *IntSliceCmd) *MockPipeliner_HExpire_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *MockPipeliner) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAt")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireAt'
type MockPipeliner_HExpireAt_Call struct {
	*mock.Call
}

// HExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - fields ...string
func (_e *MockPipeliner_Expecter) HExpireAt(ctx interface{}, key interface{}, tm interface{}, fields ...interface{}) *MockPipeliner_HExpireAt_Call {
	return &MockPipeliner_HExpireAt_Call{Call: _e.mock.On("HExpireAt",
		append([]interface{}{ctx, key, tm}, fields...)...)}
}

func (_c *MockPipeliner_HExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time, fields ...string)) *MockPipeliner_HExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HExpireAt_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time, ...string) *IntSliceCmd) *MockPipeliner_HExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *MockPipeliner) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAtWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HExpireAtWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireAtWithArgs'
type MockPipeliner_HExpireAtWithArgs_Call struct {
	*mock.Call
}

// HExpireAtWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockPipeliner_Expecter) HExpireAtWithArgs(ctx interface{}, key interface{}, tm interface{}, expirationArgs interface{}, fields ...interface{}) *MockPipeliner_HExpireAtWithArgs_Call {
	return &MockPipeliner_HExpireAtWithArgs_Call{Call: _e.mock.On("HExpireAtWithArgs",
		append([]interface{}{ctx, key, tm, expirationArgs}, fields...)...)}
}

func (_c *MockPipeliner_HExpireAtWithArgs_Call) Run(run func(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string)) *MockPipeliner_HExpireAtWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HExpireAtWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HExpireAtWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExpireAtWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd) *MockPipeliner_HExpireAtWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireTime")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireTime'
type MockPipeliner_HExpireTime_Call struct {
	*mock.Call
}

// HExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HExpireTime(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HExpireTime_Call {
	return &MockPipeliner_HExpireTime_Call{Call: _e.mock.On("HExpireTime",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HExpireTime_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HExpireTime_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExpireTime_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockPipeliner_HExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *MockPipeliner) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HExpireWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireWithArgs'
type MockPipeliner_HExpireWithArgs_Call struct {
	*mock.Call
}

// HExpireWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockPipeliner_Expecter) HExpireWithArgs(ctx interface{}, key interface{}, expiration interface{}, expirationArgs interface{}, fields ...interface{}) *MockPipeliner_HExpireWithArgs_Call {
	return &MockPipeliner_HExpireWithArgs_Call{Call: _e.mock.On("HExpireWithArgs",
		append([]interface{}{ctx, key, expiration, expirationArgs}, fields...)...)}
}

func (_c *MockPipeliner_HExpireWithArgs_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string)) *MockPipeliner_HExpireWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HExpireWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HExpireWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HExpireWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd) *MockPipeliner_HExpireWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HGet provides a mock function with given fields: ctx, key, field
func (_m *MockPipeliner) HGet(ctx context.Context, key string, field string) *StringCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_HGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGet'
type MockPipeliner_HGet_Call struct {
	*mock.Call
}

// HGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockPipeliner_Expecter) HGet(ctx interface{}, key interface{}, field interface{}) *MockPipeliner_HGet_Call {
	return &MockPipeliner_HGet_Call{Call: _e.mock.On("HGet", ctx, key, field)}
}

func (_c *MockPipeliner_HGet_Call) Run(run func(ctx context.Context, key string, field string)) *MockPipeliner_HGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_HGet_Call) Return(_a0 *StringCmd) *MockPipeliner_HGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HGet_Call) RunAndReturn(run func(context.Context, string, string) *StringCmd) *MockPipeliner_HGet_Call {
	_c.Call.Return(run)
	return _c
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) HGetAll(ctx context.Context, key string) *MapStringStringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *MapStringStringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapStringStringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringStringCmd)
		}
	}

	return r0
}

// MockPipeliner_HGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGetAll'
type MockPipeliner_HGetAll_Call struct {
	*mock.Call
}

// HGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) HGetAll(ctx interface{}, key interface{}) *MockPipeliner_HGetAll_Call {
	return &MockPipeliner_HGetAll_Call{Call: _e.mock.On("HGetAll", ctx, key)}
}

func (_c *MockPipeliner_HGetAll_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_HGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_HGetAll_Call) Return(_a0 *MapStringStringCmd) *MockPipeliner_HGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HGetAll_Call) RunAndReturn(run func(context.Context, string) *MapStringStringCmd) *MockPipeliner_HGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *MockPipeliner) HIncrBy(ctx context.Context, key string, field string, incr int64) *IntCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_HIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrBy'
type MockPipeliner_HIncrBy_Call struct {
	*mock.Call
}

// HIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr int64
func (_e *MockPipeliner_Expecter) HIncrBy(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockPipeliner_HIncrBy_Call {
	return &MockPipeliner_HIncrBy_Call{Call: _e.mock.On("HIncrBy", ctx, key, field, incr)}
}

func (_c *MockPipeliner_HIncrBy_Call) Run(run func(ctx context.Context, key string, field string, incr int64)) *MockPipeliner_HIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_HIncrBy_Call) Return(_a0 *IntCmd) *MockPipeliner_HIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HIncrBy_Call) RunAndReturn(run func(context.Context, string, string, int64) *IntCmd) *MockPipeliner_HIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrByFloat provides a mock function with given fields: ctx, key, field, incr
func (_m *MockPipeliner) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *FloatCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *FloatCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_HIncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrByFloat'
type MockPipeliner_HIncrByFloat_Call struct {
	*mock.Call
}

// HIncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr float64
func (_e *MockPipeliner_Expecter) HIncrByFloat(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockPipeliner_HIncrByFloat_Call {
	return &MockPipeliner_HIncrByFloat_Call{Call: _e.mock.On("HIncrByFloat", ctx, key, field, incr)}
}

func (_c *MockPipeliner_HIncrByFloat_Call) Run(run func(ctx context.Context, key string, field string, incr float64)) *MockPipeliner_HIncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(float64))
	})
	return _c
}

func (_c *MockPipeliner_HIncrByFloat_Call) Return(_a0 *FloatCmd) *MockPipeliner_HIncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HIncrByFloat_Call) RunAndReturn(run func(context.Context, string, string, float64) *FloatCmd) *MockPipeliner_HIncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// HKeys provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) HKeys(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HKeys'
type MockPipeliner_HKeys_Call struct {
	*mock.Call
}

// HKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) HKeys(ctx interface{}, key interface{}) *MockPipeliner_HKeys_Call {
	return &MockPipeliner_HKeys_Call{Call: _e.mock.On("HKeys", ctx, key)}
}

func (_c *MockPipeliner_HKeys_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_HKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_HKeys_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_HKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HKeys_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_HKeys_Call {
	_c.Call.Return(run)
	return _c
}

// HLen provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) HLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_HLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HLen'
type MockPipeliner_HLen_Call struct {
	*mock.Call
}

// HLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) HLen(ctx interface{}, key interface{}) *MockPipeliner_HLen_Call {
	return &MockPipeliner_HLen_Call{Call: _e.mock.On("HLen", ctx, key)}
}

func (_c *MockPipeliner_HLen_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_HLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_HLen_Call) Return(_a0 *IntCmd) *MockPipeliner_HLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_HLen_Call {
	_c.Call.Return(run)
	return _c
}

// HMGet provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HMGet(ctx context.Context, key string, fields ...string) *SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *SliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMGet'
type MockPipeliner_HMGet_Call struct {
	*mock.Call
}

// HMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HMGet(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HMGet_Call {
	return &MockPipeliner_HMGet_Call{Call: _e.mock.On("HMGet",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HMGet_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HMGet_Call) Return(_a0 *SliceCmd) *MockPipeliner_HMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HMGet_Call) RunAndReturn(run func(context.Context, string, ...string) *SliceCmd) *MockPipeliner_HMGet_Call {
	_c.Call.Return(run)
	return _c
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) HMSet(ctx context.Context, key string, values ...interface{}) *BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_HMSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMSet'
type MockPipeliner_HMSet_Call struct {
	*mock.Call
}

// HMSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) HMSet(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_HMSet_Call {
	return &MockPipeliner_HMSet_Call{Call: _e.mock.On("HMSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_HMSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_HMSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HMSet_Call) Return(_a0 *BoolCmd) *MockPipeliner_HMSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HMSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolCmd) *MockPipeliner_HMSet_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *MockPipeliner) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpire")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpire'
type MockPipeliner_HPExpire_Call struct {
	*mock.Call
}

// HPExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPExpire(ctx interface{}, key interface{}, expiration interface{}, fields ...interface{}) *MockPipeliner_HPExpire_Call {
	return &MockPipeliner_HPExpire_Call{Call: _e.mock.On("HPExpire",
		append([]interface{}{ctx, key, expiration}, fields...)...)}
}

func (_c *MockPipeliner_HPExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, fields ...string)) *MockPipeliner_HPExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPExpire_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration, ...string) *IntSliceCmd) *MockPipeliner_HPExpire_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *MockPipeliner) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAt")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireAt'
type MockPipeliner_HPExpireAt_Call struct {
	*mock.Call
}

// HPExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPExpireAt(ctx interface{}, key interface{}, tm interface{}, fields ...interface{}) *MockPipeliner_HPExpireAt_Call {
	return &MockPipeliner_HPExpireAt_Call{Call: _e.mock.On("HPExpireAt",
		append([]interface{}{ctx, key, tm}, fields...)...)}
}

func (_c *MockPipeliner_HPExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time, fields ...string)) *MockPipeliner_HPExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPExpireAt_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time, ...string) *IntSliceCmd) *MockPipeliner_HPExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *MockPipeliner) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAtWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPExpireAtWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireAtWithArgs'
type MockPipeliner_HPExpireAtWithArgs_Call struct {
	*mock.Call
}

// HPExpireAtWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPExpireAtWithArgs(ctx interface{}, key interface{}, tm interface{}, expirationArgs interface{}, fields ...interface{}) *MockPipeliner_HPExpireAtWithArgs_Call {
	return &MockPipeliner_HPExpireAtWithArgs_Call{Call: _e.mock.On("HPExpireAtWithArgs",
		append([]interface{}{ctx, key, tm, expirationArgs}, fields...)...)}
}

func (_c *MockPipeliner_HPExpireAtWithArgs_Call) Run(run func(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string)) *MockPipeliner_HPExpireAtWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPExpireAtWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPExpireAtWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPExpireAtWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd) *MockPipeliner_HPExpireAtWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HPExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireTime")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireTime'
type MockPipeliner_HPExpireTime_Call struct {
	*mock.Call
}

// HPExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPExpireTime(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HPExpireTime_Call {
	return &MockPipeliner_HPExpireTime_Call{Call: _e.mock.On("HPExpireTime",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HPExpireTime_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HPExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPExpireTime_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPExpireTime_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockPipeliner_HPExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *MockPipeliner) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPExpireWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireWithArgs'
type MockPipeliner_HPExpireWithArgs_Call struct {
	*mock.Call
}

// HPExpireWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPExpireWithArgs(ctx interface{}, key interface{}, expiration interface{}, expirationArgs interface{}, fields ...interface{}) *MockPipeliner_HPExpireWithArgs_Call {
	return &MockPipeliner_HPExpireWithArgs_Call{Call: _e.mock.On("HPExpireWithArgs",
		append([]interface{}{ctx, key, expiration, expirationArgs}, fields...)...)}
}

func (_c *MockPipeliner_HPExpireWithArgs_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string)) *MockPipeliner_HPExpireWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPExpireWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPExpireWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPExpireWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd) *MockPipeliner_HPExpireWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HPTTL provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HPTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPTTL")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPTTL'
type MockPipeliner_HPTTL_Call struct {
	*mock.Call
}

// HPTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPTTL(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HPTTL_Call {
	return &MockPipeliner_HPTTL_Call{Call: _e.mock.On("HPTTL",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HPTTL_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HPTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPTTL_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPTTL_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockPipeliner_HPTTL_Call {
	_c.Call.Return(run)
	return _c
}

// HPersist provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HPersist(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPersist")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HPersist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPersist'
type MockPipeliner_HPersist_Call struct {
	*mock.Call
}

// HPersist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HPersist(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HPersist_Call {
	return &MockPipeliner_HPersist_Call{Call: _e.mock.On("HPersist",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HPersist_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HPersist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HPersist_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HPersist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HPersist_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockPipeliner_HPersist_Call {
	_c.Call.Return(run)
	return _c
}

// HRandField provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) HRandField(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandField")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HRandField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HRandField'
type MockPipeliner_HRandField_Call struct {
	*mock.Call
}

// HRandField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) HRandField(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_HRandField_Call {
	return &MockPipeliner_HRandField_Call{Call: _e.mock.On("HRandField", ctx, key, count)}
}

func (_c *MockPipeliner_HRandField_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_HRandField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_HRandField_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_HRandField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HRandField_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockPipeliner_HRandField_Call {
	_c.Call.Return(run)
	return _c
}

// HRandFieldWithValues provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) HRandFieldWithValues(ctx context.Context, key string, count int) *KeyValueSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandFieldWithValues")
	}

	var r0 *KeyValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *KeyValueSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValueSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HRandFieldWithValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HRandFieldWithValues'
type MockPipeliner_HRandFieldWithValues_Call struct {
	*mock.Call
}

// HRandFieldWithValues is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) HRandFieldWithValues(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_HRandFieldWithValues_Call {
	return &MockPipeliner_HRandFieldWithValues_Call{Call: _e.mock.On("HRandFieldWithValues", ctx, key, count)}
}

func (_c *MockPipeliner_HRandFieldWithValues_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_HRandFieldWithValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_HRandFieldWithValues_Call) Return(_a0 *KeyValueSliceCmd) *MockPipeliner_HRandFieldWithValues_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HRandFieldWithValues_Call) RunAndReturn(run func(context.Context, string, int) *KeyValueSliceCmd) *MockPipeliner_HRandFieldWithValues_Call {
	_c.Call.Return(run)
	return _c
}

// HScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockPipeliner) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_HScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HScan'
type MockPipeliner_HScan_Call struct {
	*mock.Call
}

// HScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockPipeliner_Expecter) HScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockPipeliner_HScan_Call {
	return &MockPipeliner_HScan_Call{Call: _e.mock.On("HScan", ctx, key, cursor, match, count)}
}

func (_c *MockPipeliner_HScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockPipeliner_HScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_HScan_Call) Return(_a0 *ScanCmd) *MockPipeliner_HScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockPipeliner_HScan_Call {
	_c.Call.Return(run)
	return _c
}

// HScanNoValues provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockPipeliner) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScanNoValues")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_HScanNoValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HScanNoValues'
type MockPipeliner_HScanNoValues_Call struct {
	*mock.Call
}

// HScanNoValues is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockPipeliner_Expecter) HScanNoValues(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockPipeliner_HScanNoValues_Call {
	return &MockPipeliner_HScanNoValues_Call{Call: _e.mock.On("HScanNoValues", ctx, key, cursor, match, count)}
}

func (_c *MockPipeliner_HScanNoValues_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockPipeliner_HScanNoValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_HScanNoValues_Call) Return(_a0 *ScanCmd) *MockPipeliner_HScanNoValues_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HScanNoValues_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockPipeliner_HScanNoValues_Call {
	_c.Call.Return(run)
	return _c
}

// HSet provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) HSet(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_HSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSet'
type MockPipeliner_HSet_Call struct {
	*mock.Call
}

// HSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) HSet(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_HSet_Call {
	return &MockPipeliner_HSet_Call{Call: _e.mock.On("HSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_HSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_HSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HSet_Call) Return(_a0 *IntCmd) *MockPipeliner_HSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_HSet_Call {
	_c.Call.Return(run)
	return _c
}

// HSetNX provides a mock function with given fields: ctx, key, field, value
func (_m *MockPipeliner) HSetNX(ctx context.Context, key string, field string, value interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_HSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSetNX'
type MockPipeliner_HSetNX_Call struct {
	*mock.Call
}

// HSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - value interface{}
func (_e *MockPipeliner_Expecter) HSetNX(ctx interface{}, key interface{}, field interface{}, value interface{}) *MockPipeliner_HSetNX_Call {
	return &MockPipeliner_HSetNX_Call{Call: _e.mock.On("HSetNX", ctx, key, field, value)}
}

func (_c *MockPipeliner_HSetNX_Call) Run(run func(ctx context.Context, key string, field string, value interface{})) *MockPipeliner_HSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_HSetNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_HSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HSetNX_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *BoolCmd) *MockPipeliner_HSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// HStrLen provides a mock function with given fields: ctx, key, field
func (_m *MockPipeliner) HStrLen(ctx context.Context, key string, field string) *IntCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HStrLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_HStrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HStrLen'
type MockPipeliner_HStrLen_Call struct {
	*mock.Call
}

// HStrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockPipeliner_Expecter) HStrLen(ctx interface{}, key interface{}, field interface{}) *MockPipeliner_HStrLen_Call {
	return &MockPipeliner_HStrLen_Call{Call: _e.mock.On("HStrLen", ctx, key, field)}
}

func (_c *MockPipeliner_HStrLen_Call) Run(run func(ctx context.Context, key string, field string)) *MockPipeliner_HStrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_HStrLen_Call) Return(_a0 *IntCmd) *MockPipeliner_HStrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HStrLen_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_HStrLen_Call {
	_c.Call.Return(run)
	return _c
}

// HTTL provides a mock function with given fields: ctx, key, fields
func (_m *MockPipeliner) HTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTL")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HTTL'
type MockPipeliner_HTTL_Call struct {
	*mock.Call
}

// HTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockPipeliner_Expecter) HTTL(ctx interface{}, key interface{}, fields ...interface{}) *MockPipeliner_HTTL_Call {
	return &MockPipeliner_HTTL_Call{Call: _e.mock.On("HTTL",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockPipeliner_HTTL_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockPipeliner_HTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_HTTL_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_HTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HTTL_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockPipeliner_HTTL_Call {
	_c.Call.Return(run)
	return _c
}

// HVals provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) HVals(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_HVals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HVals'
type MockPipeliner_HVals_Call struct {
	*mock.Call
}

// HVals is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) HVals(ctx interface{}, key interface{}) *MockPipeliner_HVals_Call {
	return &MockPipeliner_HVals_Call{Call: _e.mock.On("HVals", ctx, key)}
}

func (_c *MockPipeliner_HVals_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_HVals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_HVals_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_HVals_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_HVals_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_HVals_Call {
	_c.Call.Return(run)
	return _c
}

// Hello provides a mock function with given fields: ctx, ver, username, password, clientName
func (_m *MockPipeliner) Hello(ctx context.Context, ver int, username string, password string, clientName string) *MapStringInterfaceCmd {
	ret := _m.Called(ctx, ver, username, password, clientName)

	if len(ret) == 0 {
		panic("no return value specified for Hello")
	}

	var r0 *MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, string, string, string) *MapStringInterfaceCmd); ok {
		r0 = rf(ctx, ver, username, password, clientName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_Hello_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Hello'
type MockPipeliner_Hello_Call struct {
	*mock.Call
}

// Hello is a helper method to define mock.On call
//   - ctx context.Context
//   - ver int
//   - username string
//   - password string
//   - clientName string
func (_e *MockPipeliner_Expecter) Hello(ctx interface{}, ver interface{}, username interface{}, password interface{}, clientName interface{}) *MockPipeliner_Hello_Call {
	return &MockPipeliner_Hello_Call{Call: _e.mock.On("Hello", ctx, ver, username, password, clientName)}
}

func (_c *MockPipeliner_Hello_Call) Run(run func(ctx context.Context, ver int, username string, password string, clientName string)) *MockPipeliner_Hello_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockPipeliner_Hello_Call) Return(_a0 *MapStringInterfaceCmd) *MockPipeliner_Hello_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Hello_Call) RunAndReturn(run func(context.Context, int, string, string, string) *MapStringInterfaceCmd) *MockPipeliner_Hello_Call {
	_c.Call.Return(run)
	return _c
}

// Incr provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Incr(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Incr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Incr'
type MockPipeliner_Incr_Call struct {
	*mock.Call
}

// Incr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Incr(ctx interface{}, key interface{}) *MockPipeliner_Incr_Call {
	return &MockPipeliner_Incr_Call{Call: _e.mock.On("Incr", ctx, key)}
}

func (_c *MockPipeliner_Incr_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Incr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Incr_Call) Return(_a0 *IntCmd) *MockPipeliner_Incr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Incr_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_Incr_Call {
	_c.Call.Return(run)
	return _c
}

// IncrBy provides a mock function with given fields: ctx, key, value
func (_m *MockPipeliner) IncrBy(ctx context.Context, key string, value int64) *IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_IncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrBy'
type MockPipeliner_IncrBy_Call struct {
	*mock.Call
}

// IncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockPipeliner_Expecter) IncrBy(ctx interface{}, key interface{}, value interface{}) *MockPipeliner_IncrBy_Call {
	return &MockPipeliner_IncrBy_Call{Call: _e.mock.On("IncrBy", ctx, key, value)}
}

func (_c *MockPipeliner_IncrBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockPipeliner_IncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_IncrBy_Call) Return(_a0 *IntCmd) *MockPipeliner_IncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_IncrBy_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockPipeliner_IncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// IncrByFloat provides a mock function with given fields: ctx, key, value
func (_m *MockPipeliner) IncrByFloat(ctx context.Context, key string, value float64) *FloatCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *FloatCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_IncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrByFloat'
type MockPipeliner_IncrByFloat_Call struct {
	*mock.Call
}

// IncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
func (_e *MockPipeliner_Expecter) IncrByFloat(ctx interface{}, key interface{}, value interface{}) *MockPipeliner_IncrByFloat_Call {
	return &MockPipeliner_IncrByFloat_Call{Call: _e.mock.On("IncrByFloat", ctx, key, value)}
}

func (_c *MockPipeliner_IncrByFloat_Call) Run(run func(ctx context.Context, key string, value float64)) *MockPipeliner_IncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockPipeliner_IncrByFloat_Call) Return(_a0 *FloatCmd) *MockPipeliner_IncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_IncrByFloat_Call) RunAndReturn(run func(context.Context, string, float64) *FloatCmd) *MockPipeliner_IncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// Info provides a mock function with given fields: ctx, section
func (_m *MockPipeliner) Info(ctx context.Context, section ...string) *StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *StringCmd); ok {
		r0 = rf(ctx, section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_Info_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Info'
type MockPipeliner_Info_Call struct {
	*mock.Call
}

// Info is a helper method to define mock.On call
//   - ctx context.Context
//   - section ...string
func (_e *MockPipeliner_Expecter) Info(ctx interface{}, section ...interface{}) *MockPipeliner_Info_Call {
	return &MockPipeliner_Info_Call{Call: _e.mock.On("Info",
		append([]interface{}{ctx}, section...)...)}
}

func (_c *MockPipeliner_Info_Call) Run(run func(ctx context.Context, section ...string)) *MockPipeliner_Info_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Info_Call) Return(_a0 *StringCmd) *MockPipeliner_Info_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Info_Call) RunAndReturn(run func(context.Context, ...string) *StringCmd) *MockPipeliner_Info_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrAppend provides a mock function with given fields: ctx, key, path, values
func (_m *MockPipeliner) JSONArrAppend(ctx context.Context, key string, path string, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrAppend")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrAppend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrAppend'
type MockPipeliner_JSONArrAppend_Call struct {
	*mock.Call
}

// JSONArrAppend is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) JSONArrAppend(ctx interface{}, key interface{}, path interface{}, values ...interface{}) *MockPipeliner_JSONArrAppend_Call {
	return &MockPipeliner_JSONArrAppend_Call{Call: _e.mock.On("JSONArrAppend",
		append([]interface{}{ctx, key, path}, values...)...)}
}

func (_c *MockPipeliner_JSONArrAppend_Call) Run(run func(ctx context.Context, key string, path string, values ...interface{})) *MockPipeliner_JSONArrAppend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONArrAppend_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrAppend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrAppend_Call) RunAndReturn(run func(context.Context, string, string, ...interface{}) *IntSliceCmd) *MockPipeliner_JSONArrAppend_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrIndex provides a mock function with given fields: ctx, key, path, value
func (_m *MockPipeliner) JSONArrIndex(ctx context.Context, key string, path string, value ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrIndex")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrIndex'
type MockPipeliner_JSONArrIndex_Call struct {
	*mock.Call
}

// JSONArrIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value ...interface{}
func (_e *MockPipeliner_Expecter) JSONArrIndex(ctx interface{}, key interface{}, path interface{}, value ...interface{}) *MockPipeliner_JSONArrIndex_Call {
	return &MockPipeliner_JSONArrIndex_Call{Call: _e.mock.On("JSONArrIndex",
		append([]interface{}{ctx, key, path}, value...)...)}
}

func (_c *MockPipeliner_JSONArrIndex_Call) Run(run func(ctx context.Context, key string, path string, value ...interface{})) *MockPipeliner_JSONArrIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONArrIndex_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrIndex_Call) RunAndReturn(run func(context.Context, string, string, ...interface{}) *IntSliceCmd) *MockPipeliner_JSONArrIndex_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrIndexWithArgs provides a mock function with given fields: ctx, key, path, options, value
func (_m *MockPipeliner) JSONArrIndexWithArgs(ctx context.Context, key string, path string, options *JSONArrIndexArgs, value ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path, options)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrIndexWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *JSONArrIndexArgs, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path, options, value...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrIndexWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrIndexWithArgs'
type MockPipeliner_JSONArrIndexWithArgs_Call struct {
	*mock.Call
}

// JSONArrIndexWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - options *JSONArrIndexArgs
//   - value ...interface{}
func (_e *MockPipeliner_Expecter) JSONArrIndexWithArgs(ctx interface{}, key interface{}, path interface{}, options interface{}, value ...interface{}) *MockPipeliner_JSONArrIndexWithArgs_Call {
	return &MockPipeliner_JSONArrIndexWithArgs_Call{Call: _e.mock.On("JSONArrIndexWithArgs",
		append([]interface{}{ctx, key, path, options}, value...)...)}
}

func (_c *MockPipeliner_JSONArrIndexWithArgs_Call) Run(run func(ctx context.Context, key string, path string, options *JSONArrIndexArgs, value ...interface{})) *MockPipeliner_JSONArrIndexWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*JSONArrIndexArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONArrIndexWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrIndexWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrIndexWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *JSONArrIndexArgs, ...interface{}) *IntSliceCmd) *MockPipeliner_JSONArrIndexWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrInsert provides a mock function with given fields: ctx, key, path, index, values
func (_m *MockPipeliner) JSONArrInsert(ctx context.Context, key string, path string, index int64, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key, path, index)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrInsert")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path, index, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrInsert'
type MockPipeliner_JSONArrInsert_Call struct {
	*mock.Call
}

// JSONArrInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - index int64
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) JSONArrInsert(ctx interface{}, key interface{}, path interface{}, index interface{}, values ...interface{}) *MockPipeliner_JSONArrInsert_Call {
	return &MockPipeliner_JSONArrInsert_Call{Call: _e.mock.On("JSONArrInsert",
		append([]interface{}{ctx, key, path, index}, values...)...)}
}

func (_c *MockPipeliner_JSONArrInsert_Call) Run(run func(ctx context.Context, key string, path string, index int64, values ...interface{})) *MockPipeliner_JSONArrInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONArrInsert_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrInsert_Call) RunAndReturn(run func(context.Context, string, string, int64, ...interface{}) *IntSliceCmd) *MockPipeliner_JSONArrInsert_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrLen provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONArrLen(ctx context.Context, key string, path string) *IntSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrLen")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrLen'
type MockPipeliner_JSONArrLen_Call struct {
	*mock.Call
}

// JSONArrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONArrLen(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONArrLen_Call {
	return &MockPipeliner_JSONArrLen_Call{Call: _e.mock.On("JSONArrLen", ctx, key, path)}
}

func (_c *MockPipeliner_JSONArrLen_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONArrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONArrLen_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrLen_Call) RunAndReturn(run func(context.Context, string, string) *IntSliceCmd) *MockPipeliner_JSONArrLen_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrPop provides a mock function with given fields: ctx, key, path, index
func (_m *MockPipeliner) JSONArrPop(ctx context.Context, key string, path string, index int) *StringSliceCmd {
	ret := _m.Called(ctx, key, path, index)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrPop")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, path, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrPop'
type MockPipeliner_JSONArrPop_Call struct {
	*mock.Call
}

// JSONArrPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - index int
func (_e *MockPipeliner_Expecter) JSONArrPop(ctx interface{}, key interface{}, path interface{}, index interface{}) *MockPipeliner_JSONArrPop_Call {
	return &MockPipeliner_JSONArrPop_Call{Call: _e.mock.On("JSONArrPop", ctx, key, path, index)}
}

func (_c *MockPipeliner_JSONArrPop_Call) Run(run func(ctx context.Context, key string, path string, index int)) *MockPipeliner_JSONArrPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_JSONArrPop_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_JSONArrPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrPop_Call) RunAndReturn(run func(context.Context, string, string, int) *StringSliceCmd) *MockPipeliner_JSONArrPop_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrTrim provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONArrTrim(ctx context.Context, key string, path string) *IntSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrTrim")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrTrim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrTrim'
type MockPipeliner_JSONArrTrim_Call struct {
	*mock.Call
}

// JSONArrTrim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONArrTrim(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONArrTrim_Call {
	return &MockPipeliner_JSONArrTrim_Call{Call: _e.mock.On("JSONArrTrim", ctx, key, path)}
}

func (_c *MockPipeliner_JSONArrTrim_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONArrTrim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONArrTrim_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrTrim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrTrim_Call) RunAndReturn(run func(context.Context, string, string) *IntSliceCmd) *MockPipeliner_JSONArrTrim_Call {
	_c.Call.Return(run)
	return _c
}

// JSONArrTrimWithArgs provides a mock function with given fields: ctx, key, path, options
func (_m *MockPipeliner) JSONArrTrimWithArgs(ctx context.Context, key string, path string, options *JSONArrTrimArgs) *IntSliceCmd {
	ret := _m.Called(ctx, key, path, options)

	if len(ret) == 0 {
		panic("no return value specified for JSONArrTrimWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *JSONArrTrimArgs) *IntSliceCmd); ok {
		r0 = rf(ctx, key, path, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONArrTrimWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONArrTrimWithArgs'
type MockPipeliner_JSONArrTrimWithArgs_Call struct {
	*mock.Call
}

// JSONArrTrimWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - options *JSONArrTrimArgs
func (_e *MockPipeliner_Expecter) JSONArrTrimWithArgs(ctx interface{}, key interface{}, path interface{}, options interface{}) *MockPipeliner_JSONArrTrimWithArgs_Call {
	return &MockPipeliner_JSONArrTrimWithArgs_Call{Call: _e.mock.On("JSONArrTrimWithArgs", ctx, key, path, options)}
}

func (_c *MockPipeliner_JSONArrTrimWithArgs_Call) Run(run func(ctx context.Context, key string, path string, options *JSONArrTrimArgs)) *MockPipeliner_JSONArrTrimWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*JSONArrTrimArgs))
	})
	return _c
}

func (_c *MockPipeliner_JSONArrTrimWithArgs_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_JSONArrTrimWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONArrTrimWithArgs_Call) RunAndReturn(run func(context.Context, string, string, *JSONArrTrimArgs) *IntSliceCmd) *MockPipeliner_JSONArrTrimWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// JSONClear provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONClear(ctx context.Context, key string, path string) *IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONClear")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONClear_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONClear'
type MockPipeliner_JSONClear_Call struct {
	*mock.Call
}

// JSONClear is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONClear(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONClear_Call {
	return &MockPipeliner_JSONClear_Call{Call: _e.mock.On("JSONClear", ctx, key, path)}
}

func (_c *MockPipeliner_JSONClear_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONClear_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONClear_Call) Return(_a0 *IntCmd) *MockPipeliner_JSONClear_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONClear_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_JSONClear_Call {
	_c.Call.Return(run)
	return _c
}

// JSONDebugMemory provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONDebugMemory(ctx context.Context, key string, path string) *IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONDebugMemory")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONDebugMemory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONDebugMemory'
type MockPipeliner_JSONDebugMemory_Call struct {
	*mock.Call
}

// JSONDebugMemory is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONDebugMemory(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONDebugMemory_Call {
	return &MockPipeliner_JSONDebugMemory_Call{Call: _e.mock.On("JSONDebugMemory", ctx, key, path)}
}

func (_c *MockPipeliner_JSONDebugMemory_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONDebugMemory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONDebugMemory_Call) Return(_a0 *IntCmd) *MockPipeliner_JSONDebugMemory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONDebugMemory_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_JSONDebugMemory_Call {
	_c.Call.Return(run)
	return _c
}

// JSONDel provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONDel(ctx context.Context, key string, path string) *IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONDel'
type MockPipeliner_JSONDel_Call struct {
	*mock.Call
}

// JSONDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONDel(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONDel_Call {
	return &MockPipeliner_JSONDel_Call{Call: _e.mock.On("JSONDel", ctx, key, path)}
}

func (_c *MockPipeliner_JSONDel_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONDel_Call) Return(_a0 *IntCmd) *MockPipeliner_JSONDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONDel_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_JSONDel_Call {
	_c.Call.Return(run)
	return _c
}

// JSONForget provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONForget(ctx context.Context, key string, path string) *IntCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONForget")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONForget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONForget'
type MockPipeliner_JSONForget_Call struct {
	*mock.Call
}

// JSONForget is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONForget(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONForget_Call {
	return &MockPipeliner_JSONForget_Call{Call: _e.mock.On("JSONForget", ctx, key, path)}
}

func (_c *MockPipeliner_JSONForget_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONForget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONForget_Call) Return(_a0 *IntCmd) *MockPipeliner_JSONForget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONForget_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_JSONForget_Call {
	_c.Call.Return(run)
	return _c
}

// JSONGet provides a mock function with given fields: ctx, key, paths
func (_m *MockPipeliner) JSONGet(ctx context.Context, key string, paths ...string) *JSONCmd {
	_va := make([]interface{}, len(paths))
	for _i := range paths {
		_va[_i] = paths[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONGet")
	}

	var r0 *JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *JSONCmd); ok {
		r0 = rf(ctx, key, paths...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JSONCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONGet'
type MockPipeliner_JSONGet_Call struct {
	*mock.Call
}

// JSONGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - paths ...string
func (_e *MockPipeliner_Expecter) JSONGet(ctx interface{}, key interface{}, paths ...interface{}) *MockPipeliner_JSONGet_Call {
	return &MockPipeliner_JSONGet_Call{Call: _e.mock.On("JSONGet",
		append([]interface{}{ctx, key}, paths...)...)}
}

func (_c *MockPipeliner_JSONGet_Call) Run(run func(ctx context.Context, key string, paths ...string)) *MockPipeliner_JSONGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONGet_Call) Return(_a0 *JSONCmd) *MockPipeliner_JSONGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONGet_Call) RunAndReturn(run func(context.Context, string, ...string) *JSONCmd) *MockPipeliner_JSONGet_Call {
	_c.Call.Return(run)
	return _c
}

// JSONGetWithArgs provides a mock function with given fields: ctx, key, options, paths
func (_m *MockPipeliner) JSONGetWithArgs(ctx context.Context, key string, options *JSONGetArgs, paths ...string) *JSONCmd {
	_va := make([]interface{}, len(paths))
	for _i := range paths {
		_va[_i] = paths[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONGetWithArgs")
	}

	var r0 *JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *JSONGetArgs, ...string) *JSONCmd); ok {
		r0 = rf(ctx, key, options, paths...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JSONCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONGetWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONGetWithArgs'
type MockPipeliner_JSONGetWithArgs_Call struct {
	*mock.Call
}

// JSONGetWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *JSONGetArgs
//   - paths ...string
func (_e *MockPipeliner_Expecter) JSONGetWithArgs(ctx interface{}, key interface{}, options interface{}, paths ...interface{}) *MockPipeliner_JSONGetWithArgs_Call {
	return &MockPipeliner_JSONGetWithArgs_Call{Call: _e.mock.On("JSONGetWithArgs",
		append([]interface{}{ctx, key, options}, paths...)...)}
}

func (_c *MockPipeliner_JSONGetWithArgs_Call) Run(run func(ctx context.Context, key string, options *JSONGetArgs, paths ...string)) *MockPipeliner_JSONGetWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*JSONGetArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONGetWithArgs_Call) Return(_a0 *JSONCmd) *MockPipeliner_JSONGetWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONGetWithArgs_Call) RunAndReturn(run func(context.Context, string, *JSONGetArgs, ...string) *JSONCmd) *MockPipeliner_JSONGetWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// JSONMGet provides a mock function with given fields: ctx, path, keys
func (_m *MockPipeliner) JSONMGet(ctx context.Context, path string, keys ...string) *JSONSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, path)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONMGet")
	}

	var r0 *JSONSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *JSONSliceCmd); ok {
		r0 = rf(ctx, path, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JSONSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONMGet'
type MockPipeliner_JSONMGet_Call struct {
	*mock.Call
}

// JSONMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - keys ...string
func (_e *MockPipeliner_Expecter) JSONMGet(ctx interface{}, path interface{}, keys ...interface{}) *MockPipeliner_JSONMGet_Call {
	return &MockPipeliner_JSONMGet_Call{Call: _e.mock.On("JSONMGet",
		append([]interface{}{ctx, path}, keys...)...)}
}

func (_c *MockPipeliner_JSONMGet_Call) Run(run func(ctx context.Context, path string, keys ...string)) *MockPipeliner_JSONMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONMGet_Call) Return(_a0 *JSONSliceCmd) *MockPipeliner_JSONMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONMGet_Call) RunAndReturn(run func(context.Context, string, ...string) *JSONSliceCmd) *MockPipeliner_JSONMGet_Call {
	_c.Call.Return(run)
	return _c
}

// JSONMSet provides a mock function with given fields: ctx, params
func (_m *MockPipeliner) JSONMSet(ctx context.Context, params ...interface{}) *StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, params...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JSONMSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *StatusCmd); ok {
		r0 = rf(ctx, params...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONMSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONMSet'
type MockPipeliner_JSONMSet_Call struct {
	*mock.Call
}

// JSONMSet is a helper method to define mock.On call
//   - ctx context.Context
//   - params ...interface{}
func (_e *MockPipeliner_Expecter) JSONMSet(ctx interface{}, params ...interface{}) *MockPipeliner_JSONMSet_Call {
	return &MockPipeliner_JSONMSet_Call{Call: _e.mock.On("JSONMSet",
		append([]interface{}{ctx}, params...)...)}
}

func (_c *MockPipeliner_JSONMSet_Call) Run(run func(ctx context.Context, params ...interface{})) *MockPipeliner_JSONMSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_JSONMSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_JSONMSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONMSet_Call) RunAndReturn(run func(context.Context, ...interface{}) *StatusCmd) *MockPipeliner_JSONMSet_Call {
	_c.Call.Return(run)
	return _c
}

// JSONMSetArgs provides a mock function with given fields: ctx, docs
func (_m *MockPipeliner) JSONMSetArgs(ctx context.Context, docs []JSONSetArgs) *StatusCmd {
	ret := _m.Called(ctx, docs)

	if len(ret) == 0 {
		panic("no return value specified for JSONMSetArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, []JSONSetArgs) *StatusCmd); ok {
		r0 = rf(ctx, docs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONMSetArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONMSetArgs'
type MockPipeliner_JSONMSetArgs_Call struct {
	*mock.Call
}

// JSONMSetArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - docs []JSONSetArgs
func (_e *MockPipeliner_Expecter) JSONMSetArgs(ctx interface{}, docs interface{}) *MockPipeliner_JSONMSetArgs_Call {
	return &MockPipeliner_JSONMSetArgs_Call{Call: _e.mock.On("JSONMSetArgs", ctx, docs)}
}

func (_c *MockPipeliner_JSONMSetArgs_Call) Run(run func(ctx context.Context, docs []JSONSetArgs)) *MockPipeliner_JSONMSetArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]JSONSetArgs))
	})
	return _c
}

func (_c *MockPipeliner_JSONMSetArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_JSONMSetArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONMSetArgs_Call) RunAndReturn(run func(context.Context, []JSONSetArgs) *StatusCmd) *MockPipeliner_JSONMSetArgs_Call {
	_c.Call.Return(run)
	return _c
}

// JSONMerge provides a mock function with given fields: ctx, key, path, value
func (_m *MockPipeliner) JSONMerge(ctx context.Context, key string, path string, value string) *StatusCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONMerge")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *StatusCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONMerge'
type MockPipeliner_JSONMerge_Call struct {
	*mock.Call
}

// JSONMerge is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value string
func (_e *MockPipeliner_Expecter) JSONMerge(ctx interface{}, key interface{}, path interface{}, value interface{}) *MockPipeliner_JSONMerge_Call {
	return &MockPipeliner_JSONMerge_Call{Call: _e.mock.On("JSONMerge", ctx, key, path, value)}
}

func (_c *MockPipeliner_JSONMerge_Call) Run(run func(ctx context.Context, key string, path string, value string)) *MockPipeliner_JSONMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONMerge_Call) Return(_a0 *StatusCmd) *MockPipeliner_JSONMerge_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONMerge_Call) RunAndReturn(run func(context.Context, string, string, string) *StatusCmd) *MockPipeliner_JSONMerge_Call {
	_c.Call.Return(run)
	return _c
}

// JSONNumIncrBy provides a mock function with given fields: ctx, key, path, value
func (_m *MockPipeliner) JSONNumIncrBy(ctx context.Context, key string, path string, value float64) *JSONCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONNumIncrBy")
	}

	var r0 *JSONCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *JSONCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JSONCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONNumIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONNumIncrBy'
type MockPipeliner_JSONNumIncrBy_Call struct {
	*mock.Call
}

// JSONNumIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value float64
func (_e *MockPipeliner_Expecter) JSONNumIncrBy(ctx interface{}, key interface{}, path interface{}, value interface{}) *MockPipeliner_JSONNumIncrBy_Call {
	return &MockPipeliner_JSONNumIncrBy_Call{Call: _e.mock.On("JSONNumIncrBy", ctx, key, path, value)}
}

func (_c *MockPipeliner_JSONNumIncrBy_Call) Run(run func(ctx context.Context, key string, path string, value float64)) *MockPipeliner_JSONNumIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(float64))
	})
	return _c
}

func (_c *MockPipeliner_JSONNumIncrBy_Call) Return(_a0 *JSONCmd) *MockPipeliner_JSONNumIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONNumIncrBy_Call) RunAndReturn(run func(context.Context, string, string, float64) *JSONCmd) *MockPipeliner_JSONNumIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// JSONObjKeys provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONObjKeys(ctx context.Context, key string, path string) *SliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONObjKeys")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *SliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONObjKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONObjKeys'
type MockPipeliner_JSONObjKeys_Call struct {
	*mock.Call
}

// JSONObjKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONObjKeys(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONObjKeys_Call {
	return &MockPipeliner_JSONObjKeys_Call{Call: _e.mock.On("JSONObjKeys", ctx, key, path)}
}

func (_c *MockPipeliner_JSONObjKeys_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONObjKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONObjKeys_Call) Return(_a0 *SliceCmd) *MockPipeliner_JSONObjKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONObjKeys_Call) RunAndReturn(run func(context.Context, string, string) *SliceCmd) *MockPipeliner_JSONObjKeys_Call {
	_c.Call.Return(run)
	return _c
}

// JSONObjLen provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONObjLen(ctx context.Context, key string, path string) *IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONObjLen")
	}

	var r0 *IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntPointerSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONObjLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONObjLen'
type MockPipeliner_JSONObjLen_Call struct {
	*mock.Call
}

// JSONObjLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONObjLen(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONObjLen_Call {
	return &MockPipeliner_JSONObjLen_Call{Call: _e.mock.On("JSONObjLen", ctx, key, path)}
}

func (_c *MockPipeliner_JSONObjLen_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONObjLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONObjLen_Call) Return(_a0 *IntPointerSliceCmd) *MockPipeliner_JSONObjLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONObjLen_Call) RunAndReturn(run func(context.Context, string, string) *IntPointerSliceCmd) *MockPipeliner_JSONObjLen_Call {
	_c.Call.Return(run)
	return _c
}

// JSONSet provides a mock function with given fields: ctx, key, path, value
func (_m *MockPipeliner) JSONSet(ctx context.Context, key string, path string, value interface{}) *StatusCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONSet'
type MockPipeliner_JSONSet_Call struct {
	*mock.Call
}

// JSONSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value interface{}
func (_e *MockPipeliner_Expecter) JSONSet(ctx interface{}, key interface{}, path interface{}, value interface{}) *MockPipeliner_JSONSet_Call {
	return &MockPipeliner_JSONSet_Call{Call: _e.mock.On("JSONSet", ctx, key, path, value)}
}

func (_c *MockPipeliner_JSONSet_Call) Run(run func(ctx context.Context, key string, path string, value interface{})) *MockPipeliner_JSONSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_JSONSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_JSONSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONSet_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *StatusCmd) *MockPipeliner_JSONSet_Call {
	_c.Call.Return(run)
	return _c
}

// JSONSetMode provides a mock function with given fields: ctx, key, path, value, mode
func (_m *MockPipeliner) JSONSetMode(ctx context.Context, key string, path string, value interface{}, mode string) *StatusCmd {
	ret := _m.Called(ctx, key, path, value, mode)

	if len(ret) == 0 {
		panic("no return value specified for JSONSetMode")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, string) *StatusCmd); ok {
		r0 = rf(ctx, key, path, value, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONSetMode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONSetMode'
type MockPipeliner_JSONSetMode_Call struct {
	*mock.Call
}

// JSONSetMode is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value interface{}
//   - mode string
func (_e *MockPipeliner_Expecter) JSONSetMode(ctx interface{}, key interface{}, path interface{}, value interface{}, mode interface{}) *MockPipeliner_JSONSetMode_Call {
	return &MockPipeliner_JSONSetMode_Call{Call: _e.mock.On("JSONSetMode", ctx, key, path, value, mode)}
}

func (_c *MockPipeliner_JSONSetMode_Call) Run(run func(ctx context.Context, key string, path string, value interface{}, mode string)) *MockPipeliner_JSONSetMode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}), args[4].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONSetMode_Call) Return(_a0 *StatusCmd) *MockPipeliner_JSONSetMode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONSetMode_Call) RunAndReturn(run func(context.Context, string, string, interface{}, string) *StatusCmd) *MockPipeliner_JSONSetMode_Call {
	_c.Call.Return(run)
	return _c
}

// JSONStrAppend provides a mock function with given fields: ctx, key, path, value
func (_m *MockPipeliner) JSONStrAppend(ctx context.Context, key string, path string, value string) *IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path, value)

	if len(ret) == 0 {
		panic("no return value specified for JSONStrAppend")
	}

	var r0 *IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntPointerSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONStrAppend_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONStrAppend'
type MockPipeliner_JSONStrAppend_Call struct {
	*mock.Call
}

// JSONStrAppend is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
//   - value string
func (_e *MockPipeliner_Expecter) JSONStrAppend(ctx interface{}, key interface{}, path interface{}, value interface{}) *MockPipeliner_JSONStrAppend_Call {
	return &MockPipeliner_JSONStrAppend_Call{Call: _e.mock.On("JSONStrAppend", ctx, key, path, value)}
}

func (_c *MockPipeliner_JSONStrAppend_Call) Run(run func(ctx context.Context, key string, path string, value string)) *MockPipeliner_JSONStrAppend_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONStrAppend_Call) Return(_a0 *IntPointerSliceCmd) *MockPipeliner_JSONStrAppend_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONStrAppend_Call) RunAndReturn(run func(context.Context, string, string, string) *IntPointerSliceCmd) *MockPipeliner_JSONStrAppend_Call {
	_c.Call.Return(run)
	return _c
}

// JSONStrLen provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONStrLen(ctx context.Context, key string, path string) *IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONStrLen")
	}

	var r0 *IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntPointerSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONStrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONStrLen'
type MockPipeliner_JSONStrLen_Call struct {
	*mock.Call
}

// JSONStrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONStrLen(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONStrLen_Call {
	return &MockPipeliner_JSONStrLen_Call{Call: _e.mock.On("JSONStrLen", ctx, key, path)}
}

func (_c *MockPipeliner_JSONStrLen_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONStrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONStrLen_Call) Return(_a0 *IntPointerSliceCmd) *MockPipeliner_JSONStrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONStrLen_Call) RunAndReturn(run func(context.Context, string, string) *IntPointerSliceCmd) *MockPipeliner_JSONStrLen_Call {
	_c.Call.Return(run)
	return _c
}

// JSONToggle provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONToggle(ctx context.Context, key string, path string) *IntPointerSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONToggle")
	}

	var r0 *IntPointerSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntPointerSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntPointerSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONToggle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONToggle'
type MockPipeliner_JSONToggle_Call struct {
	*mock.Call
}

// JSONToggle is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONToggle(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONToggle_Call {
	return &MockPipeliner_JSONToggle_Call{Call: _e.mock.On("JSONToggle", ctx, key, path)}
}

func (_c *MockPipeliner_JSONToggle_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONToggle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONToggle_Call) Return(_a0 *IntPointerSliceCmd) *MockPipeliner_JSONToggle_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONToggle_Call) RunAndReturn(run func(context.Context, string, string) *IntPointerSliceCmd) *MockPipeliner_JSONToggle_Call {
	_c.Call.Return(run)
	return _c
}

// JSONType provides a mock function with given fields: ctx, key, path
func (_m *MockPipeliner) JSONType(ctx context.Context, key string, path string) *JSONSliceCmd {
	ret := _m.Called(ctx, key, path)

	if len(ret) == 0 {
		panic("no return value specified for JSONType")
	}

	var r0 *JSONSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *JSONSliceCmd); ok {
		r0 = rf(ctx, key, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*JSONSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_JSONType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JSONType'
type MockPipeliner_JSONType_Call struct {
	*mock.Call
}

// JSONType is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - path string
func (_e *MockPipeliner_Expecter) JSONType(ctx interface{}, key interface{}, path interface{}) *MockPipeliner_JSONType_Call {
	return &MockPipeliner_JSONType_Call{Call: _e.mock.On("JSONType", ctx, key, path)}
}

func (_c *MockPipeliner_JSONType_Call) Run(run func(ctx context.Context, key string, path string)) *MockPipeliner_JSONType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_JSONType_Call) Return(_a0 *JSONSliceCmd) *MockPipeliner_JSONType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_JSONType_Call) RunAndReturn(run func(context.Context, string, string) *JSONSliceCmd) *MockPipeliner_JSONType_Call {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *MockPipeliner) Keys(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type MockPipeliner_Keys_Call struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockPipeliner_Expecter) Keys(ctx interface{}, pattern interface{}) *MockPipeliner_Keys_Call {
	return &MockPipeliner_Keys_Call{Call: _e.mock.On("Keys", ctx, pattern)}
}

func (_c *MockPipeliner_Keys_Call) Run(run func(ctx context.Context, pattern string)) *MockPipeliner_Keys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Keys_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_Keys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Keys_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_Keys_Call {
	_c.Call.Return(run)
	return _c
}

// LCS provides a mock function with given fields: ctx, q
func (_m *MockPipeliner) LCS(ctx context.Context, q *LCSQuery) *LCSCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for LCS")
	}

	var r0 *LCSCmd
	if rf, ok := ret.Get(0).(func(context.Context, *LCSQuery) *LCSCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*LCSCmd)
		}
	}

	return r0
}

// MockPipeliner_LCS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LCS'
type MockPipeliner_LCS_Call struct {
	*mock.Call
}

// LCS is a helper method to define mock.On call
//   - ctx context.Context
//   - q *LCSQuery
func (_e *MockPipeliner_Expecter) LCS(ctx interface{}, q interface{}) *MockPipeliner_LCS_Call {
	return &MockPipeliner_LCS_Call{Call: _e.mock.On("LCS", ctx, q)}
}

func (_c *MockPipeliner_LCS_Call) Run(run func(ctx context.Context, q *LCSQuery)) *MockPipeliner_LCS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*LCSQuery))
	})
	return _c
}

func (_c *MockPipeliner_LCS_Call) Return(_a0 *LCSCmd) *MockPipeliner_LCS_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LCS_Call) RunAndReturn(run func(context.Context, *LCSQuery) *LCSCmd) *MockPipeliner_LCS_Call {
	_c.Call.Return(run)
	return _c
}

// LIndex provides a mock function with given fields: ctx, key, index
func (_m *MockPipeliner) LIndex(ctx context.Context, key string, index int64) *StringCmd {
	ret := _m.Called(ctx, key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StringCmd); ok {
		r0 = rf(ctx, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_LIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LIndex'
type MockPipeliner_LIndex_Call struct {
	*mock.Call
}

// LIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
func (_e *MockPipeliner_Expecter) LIndex(ctx interface{}, key interface{}, index interface{}) *MockPipeliner_LIndex_Call {
	return &MockPipeliner_LIndex_Call{Call: _e.mock.On("LIndex", ctx, key, index)}
}

func (_c *MockPipeliner_LIndex_Call) Run(run func(ctx context.Context, key string, index int64)) *MockPipeliner_LIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_LIndex_Call) Return(_a0 *StringCmd) *MockPipeliner_LIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LIndex_Call) RunAndReturn(run func(context.Context, string, int64) *StringCmd) *MockPipeliner_LIndex_Call {
	_c.Call.Return(run)
	return _c
}

// LInsert provides a mock function with given fields: ctx, key, op, pivot, value
func (_m *MockPipeliner) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsert'
type MockPipeliner_LInsert_Call struct {
	*mock.Call
}

// LInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - op string
//   - pivot interface{}
//   - value interface{}
func (_e *MockPipeliner_Expecter) LInsert(ctx interface{}, key interface{}, op interface{}, pivot interface{}, value interface{}) *MockPipeliner_LInsert_Call {
	return &MockPipeliner_LInsert_Call{Call: _e.mock.On("LInsert", ctx, key, op, pivot, value)}
}

func (_c *MockPipeliner_LInsert_Call) Run(run func(ctx context.Context, key string, op string, pivot interface{}, value interface{})) *MockPipeliner_LInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}), args[4].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_LInsert_Call) Return(_a0 *IntCmd) *MockPipeliner_LInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LInsert_Call) RunAndReturn(run func(context.Context, string, string, interface{}, interface{}) *IntCmd) *MockPipeliner_LInsert_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertAfter provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockPipeliner) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LInsertAfter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertAfter'
type MockPipeliner_LInsertAfter_Call struct {
	*mock.Call
}

// LInsertAfter is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockPipeliner_Expecter) LInsertAfter(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockPipeliner_LInsertAfter_Call {
	return &MockPipeliner_LInsertAfter_Call{Call: _e.mock.On("LInsertAfter", ctx, key, pivot, value)}
}

func (_c *MockPipeliner_LInsertAfter_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockPipeliner_LInsertAfter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_LInsertAfter_Call) Return(_a0 *IntCmd) *MockPipeliner_LInsertAfter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LInsertAfter_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *IntCmd) *MockPipeliner_LInsertAfter_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertBefore provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockPipeliner) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LInsertBefore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertBefore'
type MockPipeliner_LInsertBefore_Call struct {
	*mock.Call
}

// LInsertBefore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockPipeliner_Expecter) LInsertBefore(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockPipeliner_LInsertBefore_Call {
	return &MockPipeliner_LInsertBefore_Call{Call: _e.mock.On("LInsertBefore", ctx, key, pivot, value)}
}

func (_c *MockPipeliner_LInsertBefore_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockPipeliner_LInsertBefore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_LInsertBefore_Call) Return(_a0 *IntCmd) *MockPipeliner_LInsertBefore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LInsertBefore_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *IntCmd) *MockPipeliner_LInsertBefore_Call {
	_c.Call.Return(run)
	return _c
}

// LLen provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) LLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LLen'
type MockPipeliner_LLen_Call struct {
	*mock.Call
}

// LLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) LLen(ctx interface{}, key interface{}) *MockPipeliner_LLen_Call {
	return &MockPipeliner_LLen_Call{Call: _e.mock.On("LLen", ctx, key)}
}

func (_c *MockPipeliner_LLen_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_LLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_LLen_Call) Return(_a0 *IntCmd) *MockPipeliner_LLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_LLen_Call {
	_c.Call.Return(run)
	return _c
}

// LMPop provides a mock function with given fields: ctx, direction, count, keys
func (_m *MockPipeliner) LMPop(ctx context.Context, direction string, count int64, keys ...string) *KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LMPop")
	}

	var r0 *KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...string) *KeyValuesCmd); ok {
		r0 = rf(ctx, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValuesCmd)
		}
	}

	return r0
}

// MockPipeliner_LMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LMPop'
type MockPipeliner_LMPop_Call struct {
	*mock.Call
}

// LMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - direction string
//   - count int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) LMPop(ctx interface{}, direction interface{}, count interface{}, keys ...interface{}) *MockPipeliner_LMPop_Call {
	return &MockPipeliner_LMPop_Call{Call: _e.mock.On("LMPop",
		append([]interface{}{ctx, direction, count}, keys...)...)}
}

func (_c *MockPipeliner_LMPop_Call) Run(run func(ctx context.Context, direction string, count int64, keys ...string)) *MockPipeliner_LMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_LMPop_Call) Return(_a0 *KeyValuesCmd) *MockPipeliner_LMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LMPop_Call) RunAndReturn(run func(context.Context, string, int64, ...string) *KeyValuesCmd) *MockPipeliner_LMPop_Call {
	_c.Call.Return(run)
	return _c
}

// LMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos
func (_m *MockPipeliner) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos)

	if len(ret) == 0 {
		panic("no return value specified for LMove")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_LMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LMove'
type MockPipeliner_LMove_Call struct {
	*mock.Call
}

// LMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
func (_e *MockPipeliner_Expecter) LMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}) *MockPipeliner_LMove_Call {
	return &MockPipeliner_LMove_Call{Call: _e.mock.On("LMove", ctx, source, destination, srcpos, destpos)}
}

func (_c *MockPipeliner_LMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string)) *MockPipeliner_LMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockPipeliner_LMove_Call) Return(_a0 *StringCmd) *MockPipeliner_LMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LMove_Call) RunAndReturn(run func(context.Context, string, string, string, string) *StringCmd) *MockPipeliner_LMove_Call {
	_c.Call.Return(run)
	return _c
}

// LPop provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) LPop(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_LPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPop'
type MockPipeliner_LPop_Call struct {
	*mock.Call
}

// LPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) LPop(ctx interface{}, key interface{}) *MockPipeliner_LPop_Call {
	return &MockPipeliner_LPop_Call{Call: _e.mock.On("LPop", ctx, key)}
}

func (_c *MockPipeliner_LPop_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_LPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_LPop_Call) Return(_a0 *StringCmd) *MockPipeliner_LPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPop_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_LPop_Call {
	_c.Call.Return(run)
	return _c
}

// LPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) LPopCount(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for LPopCount")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_LPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPopCount'
type MockPipeliner_LPopCount_Call struct {
	*mock.Call
}

// LPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) LPopCount(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_LPopCount_Call {
	return &MockPipeliner_LPopCount_Call{Call: _e.mock.On("LPopCount", ctx, key, count)}
}

func (_c *MockPipeliner_LPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_LPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_LPopCount_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_LPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPopCount_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockPipeliner_LPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPos provides a mock function with given fields: ctx, key, value, args
func (_m *MockPipeliner) LPos(ctx context.Context, key string, value string, args LPosArgs) *IntCmd {
	ret := _m.Called(ctx, key, value, args)

	if len(ret) == 0 {
		panic("no return value specified for LPos")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, LPosArgs) *IntCmd); ok {
		r0 = rf(ctx, key, value, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPos'
type MockPipeliner_LPos_Call struct {
	*mock.Call
}

// LPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - args LPosArgs
func (_e *MockPipeliner_Expecter) LPos(ctx interface{}, key interface{}, value interface{}, args interface{}) *MockPipeliner_LPos_Call {
	return &MockPipeliner_LPos_Call{Call: _e.mock.On("LPos", ctx, key, value, args)}
}

func (_c *MockPipeliner_LPos_Call) Run(run func(ctx context.Context, key string, value string, args LPosArgs)) *MockPipeliner_LPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(LPosArgs))
	})
	return _c
}

func (_c *MockPipeliner_LPos_Call) Return(_a0 *IntCmd) *MockPipeliner_LPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPos_Call) RunAndReturn(run func(context.Context, string, string, LPosArgs) *IntCmd) *MockPipeliner_LPos_Call {
	_c.Call.Return(run)
	return _c
}

// LPosCount provides a mock function with given fields: ctx, key, value, count, args
func (_m *MockPipeliner) LPosCount(ctx context.Context, key string, value string, count int64, args LPosArgs) *IntSliceCmd {
	ret := _m.Called(ctx, key, value, count, args)

	if len(ret) == 0 {
		panic("no return value specified for LPosCount")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, LPosArgs) *IntSliceCmd); ok {
		r0 = rf(ctx, key, value, count, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_LPosCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPosCount'
type MockPipeliner_LPosCount_Call struct {
	*mock.Call
}

// LPosCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - count int64
//   - args LPosArgs
func (_e *MockPipeliner_Expecter) LPosCount(ctx interface{}, key interface{}, value interface{}, count interface{}, args interface{}) *MockPipeliner_LPosCount_Call {
	return &MockPipeliner_LPosCount_Call{Call: _e.mock.On("LPosCount", ctx, key, value, count, args)}
}

func (_c *MockPipeliner_LPosCount_Call) Run(run func(ctx context.Context, key string, value string, count int64, args LPosArgs)) *MockPipeliner_LPosCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), args[4].(LPosArgs))
	})
	return _c
}

func (_c *MockPipeliner_LPosCount_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_LPosCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPosCount_Call) RunAndReturn(run func(context.Context, string, string, int64, LPosArgs) *IntSliceCmd) *MockPipeliner_LPosCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPush provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) LPush(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPush'
type MockPipeliner_LPush_Call struct {
	*mock.Call
}

// LPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) LPush(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_LPush_Call {
	return &MockPipeliner_LPush_Call{Call: _e.mock.On("LPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_LPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_LPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_LPush_Call) Return(_a0 *IntCmd) *MockPipeliner_LPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_LPush_Call {
	_c.Call.Return(run)
	return _c
}

// LPushX provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) LPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPushX'
type MockPipeliner_LPushX_Call struct {
	*mock.Call
}

// LPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) LPushX(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_LPushX_Call {
	return &MockPipeliner_LPushX_Call{Call: _e.mock.On("LPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_LPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_LPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_LPushX_Call) Return(_a0 *IntCmd) *MockPipeliner_LPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_LPushX_Call {
	_c.Call.Return(run)
	return _c
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) LRange(ctx context.Context, key string, start int64, stop int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_LRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRange'
type MockPipeliner_LRange_Call struct {
	*mock.Call
}

// LRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) LRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_LRange_Call {
	return &MockPipeliner_LRange_Call{Call: _e.mock.On("LRange", ctx, key, start, stop)}
}

func (_c *MockPipeliner_LRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_LRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_LRange_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_LRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringSliceCmd) *MockPipeliner_LRange_Call {
	_c.Call.Return(run)
	return _c
}

// LRem provides a mock function with given fields: ctx, key, count, value
func (_m *MockPipeliner) LRem(ctx context.Context, key string, count int64, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRem'
type MockPipeliner_LRem_Call struct {
	*mock.Call
}

// LRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
//   - value interface{}
func (_e *MockPipeliner_Expecter) LRem(ctx interface{}, key interface{}, count interface{}, value interface{}) *MockPipeliner_LRem_Call {
	return &MockPipeliner_LRem_Call{Call: _e.mock.On("LRem", ctx, key, count, value)}
}

func (_c *MockPipeliner_LRem_Call) Run(run func(ctx context.Context, key string, count int64, value interface{})) *MockPipeliner_LRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_LRem_Call) Return(_a0 *IntCmd) *MockPipeliner_LRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LRem_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *IntCmd) *MockPipeliner_LRem_Call {
	_c.Call.Return(run)
	return _c
}

// LSet provides a mock function with given fields: ctx, key, index, value
func (_m *MockPipeliner) LSet(ctx context.Context, key string, index int64, value interface{}) *StatusCmd {
	ret := _m.Called(ctx, key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_LSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LSet'
type MockPipeliner_LSet_Call struct {
	*mock.Call
}

// LSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
//   - value interface{}
func (_e *MockPipeliner_Expecter) LSet(ctx interface{}, key interface{}, index interface{}, value interface{}) *MockPipeliner_LSet_Call {
	return &MockPipeliner_LSet_Call{Call: _e.mock.On("LSet", ctx, key, index, value)}
}

func (_c *MockPipeliner_LSet_Call) Run(run func(ctx context.Context, key string, index int64, value interface{})) *MockPipeliner_LSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_LSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_LSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LSet_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *StatusCmd) *MockPipeliner_LSet_Call {
	_c.Call.Return(run)
	return _c
}

// LTrim provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) LTrim(ctx context.Context, key string, start int64, stop int64) *StatusCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_LTrim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LTrim'
type MockPipeliner_LTrim_Call struct {
	*mock.Call
}

// LTrim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) LTrim(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_LTrim_Call {
	return &MockPipeliner_LTrim_Call{Call: _e.mock.On("LTrim", ctx, key, start, stop)}
}

func (_c *MockPipeliner_LTrim_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_LTrim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_LTrim_Call) Return(_a0 *StatusCmd) *MockPipeliner_LTrim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LTrim_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockPipeliner_LTrim_Call {
	_c.Call.Return(run)
	return _c
}

// LastSave provides a mock function with given fields: ctx
func (_m *MockPipeliner) LastSave(ctx context.Context) *IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LastSave")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_LastSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LastSave'
type MockPipeliner_LastSave_Call struct {
	*mock.Call
}

// LastSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) LastSave(ctx interface{}) *MockPipeliner_LastSave_Call {
	return &MockPipeliner_LastSave_Call{Call: _e.mock.On("LastSave", ctx)}
}

func (_c *MockPipeliner_LastSave_Call) Run(run func(ctx context.Context)) *MockPipeliner_LastSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_LastSave_Call) Return(_a0 *IntCmd) *MockPipeliner_LastSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_LastSave_Call) RunAndReturn(run func(context.Context) *IntCmd) *MockPipeliner_LastSave_Call {
	_c.Call.Return(run)
	return _c
}

// Len provides a mock function with no fields
func (_m *MockPipeliner) Len() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Len")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// MockPipeliner_Len_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Len'
type MockPipeliner_Len_Call struct {
	*mock.Call
}

// Len is a helper method to define mock.On call
func (_e *MockPipeliner_Expecter) Len() *MockPipeliner_Len_Call {
	return &MockPipeliner_Len_Call{Call: _e.mock.On("Len")}
}

func (_c *MockPipeliner_Len_Call) Run(run func()) *MockPipeliner_Len_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPipeliner_Len_Call) Return(_a0 int) *MockPipeliner_Len_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Len_Call) RunAndReturn(run func() int) *MockPipeliner_Len_Call {
	_c.Call.Return(run)
	return _c
}

// MGet provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) MGet(ctx context.Context, keys ...string) *SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *SliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockPipeliner_MGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MGet'
type MockPipeliner_MGet_Call struct {
	*mock.Call
}

// MGet is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) MGet(ctx interface{}, keys ...interface{}) *MockPipeliner_MGet_Call {
	return &MockPipeliner_MGet_Call{Call: _e.mock.On("MGet",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_MGet_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_MGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_MGet_Call) Return(_a0 *SliceCmd) *MockPipeliner_MGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_MGet_Call) RunAndReturn(run func(context.Context, ...string) *SliceCmd) *MockPipeliner_MGet_Call {
	_c.Call.Return(run)
	return _c
}

// MSet provides a mock function with given fields: ctx, values
func (_m *MockPipeliner) MSet(ctx context.Context, values ...interface{}) *StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *StatusCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_MSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSet'
type MockPipeliner_MSet_Call struct {
	*mock.Call
}

// MSet is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) MSet(ctx interface{}, values ...interface{}) *MockPipeliner_MSet_Call {
	return &MockPipeliner_MSet_Call{Call: _e.mock.On("MSet",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockPipeliner_MSet_Call) Run(run func(ctx context.Context, values ...interface{})) *MockPipeliner_MSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_MSet_Call) Return(_a0 *StatusCmd) *MockPipeliner_MSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_MSet_Call) RunAndReturn(run func(context.Context, ...interface{}) *StatusCmd) *MockPipeliner_MSet_Call {
	_c.Call.Return(run)
	return _c
}

// MSetNX provides a mock function with given fields: ctx, values
func (_m *MockPipeliner) MSetNX(ctx context.Context, values ...interface{}) *BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *BoolCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_MSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSetNX'
type MockPipeliner_MSetNX_Call struct {
	*mock.Call
}

// MSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) MSetNX(ctx interface{}, values ...interface{}) *MockPipeliner_MSetNX_Call {
	return &MockPipeliner_MSetNX_Call{Call: _e.mock.On("MSetNX",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockPipeliner_MSetNX_Call) Run(run func(ctx context.Context, values ...interface{})) *MockPipeliner_MSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_MSetNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_MSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_MSetNX_Call) RunAndReturn(run func(context.Context, ...interface{}) *BoolCmd) *MockPipeliner_MSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// MemoryUsage provides a mock function with given fields: ctx, key, samples
func (_m *MockPipeliner) MemoryUsage(ctx context.Context, key string, samples ...int) *IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsage")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int) *IntCmd); ok {
		r0 = rf(ctx, key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_MemoryUsage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MemoryUsage'
type MockPipeliner_MemoryUsage_Call struct {
	*mock.Call
}

// MemoryUsage is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - samples ...int
func (_e *MockPipeliner_Expecter) MemoryUsage(ctx interface{}, key interface{}, samples ...interface{}) *MockPipeliner_MemoryUsage_Call {
	return &MockPipeliner_MemoryUsage_Call{Call: _e.mock.On("MemoryUsage",
		append([]interface{}{ctx, key}, samples...)...)}
}

func (_c *MockPipeliner_MemoryUsage_Call) Run(run func(ctx context.Context, key string, samples ...int)) *MockPipeliner_MemoryUsage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_MemoryUsage_Call) Return(_a0 *IntCmd) *MockPipeliner_MemoryUsage_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_MemoryUsage_Call) RunAndReturn(run func(context.Context, string, ...int) *IntCmd) *MockPipeliner_MemoryUsage_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function with given fields: ctx, host, port, key, db, timeout
func (_m *MockPipeliner) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *StatusCmd {
	ret := _m.Called(ctx, host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockPipeliner_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
//   - key string
//   - db int
//   - timeout time.Duration
func (_e *MockPipeliner_Expecter) Migrate(ctx interface{}, host interface{}, port interface{}, key interface{}, db interface{}, timeout interface{}) *MockPipeliner_Migrate_Call {
	return &MockPipeliner_Migrate_Call{Call: _e.mock.On("Migrate", ctx, host, port, key, db, timeout)}
}

func (_c *MockPipeliner_Migrate_Call) Run(run func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration)) *MockPipeliner_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_Migrate_Call) Return(_a0 *StatusCmd) *MockPipeliner_Migrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Migrate_Call) RunAndReturn(run func(context.Context, string, string, string, int, time.Duration) *StatusCmd) *MockPipeliner_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// ModuleLoadex provides a mock function with given fields: ctx, conf
func (_m *MockPipeliner) ModuleLoadex(ctx context.Context, conf *ModuleLoadexConfig) *StringCmd {
	ret := _m.Called(ctx, conf)

	if len(ret) == 0 {
		panic("no return value specified for ModuleLoadex")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *ModuleLoadexConfig) *StringCmd); ok {
		r0 = rf(ctx, conf)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ModuleLoadex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModuleLoadex'
type MockPipeliner_ModuleLoadex_Call struct {
	*mock.Call
}

// ModuleLoadex is a helper method to define mock.On call
//   - ctx context.Context
//   - conf *ModuleLoadexConfig
func (_e *MockPipeliner_Expecter) ModuleLoadex(ctx interface{}, conf interface{}) *MockPipeliner_ModuleLoadex_Call {
	return &MockPipeliner_ModuleLoadex_Call{Call: _e.mock.On("ModuleLoadex", ctx, conf)}
}

func (_c *MockPipeliner_ModuleLoadex_Call) Run(run func(ctx context.Context, conf *ModuleLoadexConfig)) *MockPipeliner_ModuleLoadex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ModuleLoadexConfig))
	})
	return _c
}

func (_c *MockPipeliner_ModuleLoadex_Call) Return(_a0 *StringCmd) *MockPipeliner_ModuleLoadex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ModuleLoadex_Call) RunAndReturn(run func(context.Context, *ModuleLoadexConfig) *StringCmd) *MockPipeliner_ModuleLoadex_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function with given fields: ctx, key, db
func (_m *MockPipeliner) Move(ctx context.Context, key string, db int) *BoolCmd {
	ret := _m.Called(ctx, key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *BoolCmd); ok {
		r0 = rf(ctx, key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type MockPipeliner_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - db int
func (_e *MockPipeliner_Expecter) Move(ctx interface{}, key interface{}, db interface{}) *MockPipeliner_Move_Call {
	return &MockPipeliner_Move_Call{Call: _e.mock.On("Move", ctx, key, db)}
}

func (_c *MockPipeliner_Move_Call) Run(run func(ctx context.Context, key string, db int)) *MockPipeliner_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_Move_Call) Return(_a0 *BoolCmd) *MockPipeliner_Move_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Move_Call) RunAndReturn(run func(context.Context, string, int) *BoolCmd) *MockPipeliner_Move_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectEncoding provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ObjectEncoding(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ObjectEncoding_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectEncoding'
type MockPipeliner_ObjectEncoding_Call struct {
	*mock.Call
}

// ObjectEncoding is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ObjectEncoding(ctx interface{}, key interface{}) *MockPipeliner_ObjectEncoding_Call {
	return &MockPipeliner_ObjectEncoding_Call{Call: _e.mock.On("ObjectEncoding", ctx, key)}
}

func (_c *MockPipeliner_ObjectEncoding_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ObjectEncoding_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ObjectEncoding_Call) Return(_a0 *StringCmd) *MockPipeliner_ObjectEncoding_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ObjectEncoding_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_ObjectEncoding_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectFreq provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ObjectFreq(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectFreq")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ObjectFreq_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectFreq'
type MockPipeliner_ObjectFreq_Call struct {
	*mock.Call
}

// ObjectFreq is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ObjectFreq(ctx interface{}, key interface{}) *MockPipeliner_ObjectFreq_Call {
	return &MockPipeliner_ObjectFreq_Call{Call: _e.mock.On("ObjectFreq", ctx, key)}
}

func (_c *MockPipeliner_ObjectFreq_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ObjectFreq_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ObjectFreq_Call) Return(_a0 *IntCmd) *MockPipeliner_ObjectFreq_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ObjectFreq_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ObjectFreq_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectIdleTime provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ObjectIdleTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockPipeliner_ObjectIdleTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectIdleTime'
type MockPipeliner_ObjectIdleTime_Call struct {
	*mock.Call
}

// ObjectIdleTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ObjectIdleTime(ctx interface{}, key interface{}) *MockPipeliner_ObjectIdleTime_Call {
	return &MockPipeliner_ObjectIdleTime_Call{Call: _e.mock.On("ObjectIdleTime", ctx, key)}
}

func (_c *MockPipeliner_ObjectIdleTime_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ObjectIdleTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ObjectIdleTime_Call) Return(_a0 *DurationCmd) *MockPipeliner_ObjectIdleTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ObjectIdleTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockPipeliner_ObjectIdleTime_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectRefCount provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ObjectRefCount(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ObjectRefCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectRefCount'
type MockPipeliner_ObjectRefCount_Call struct {
	*mock.Call
}

// ObjectRefCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ObjectRefCount(ctx interface{}, key interface{}) *MockPipeliner_ObjectRefCount_Call {
	return &MockPipeliner_ObjectRefCount_Call{Call: _e.mock.On("ObjectRefCount", ctx, key)}
}

func (_c *MockPipeliner_ObjectRefCount_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ObjectRefCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ObjectRefCount_Call) Return(_a0 *IntCmd) *MockPipeliner_ObjectRefCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ObjectRefCount_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ObjectRefCount_Call {
	_c.Call.Return(run)
	return _c
}

// PExpire provides a mock function with given fields: ctx, key, expiration
func (_m *MockPipeliner) PExpire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_PExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpire'
type MockPipeliner_PExpire_Call struct {
	*mock.Call
}

// PExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) PExpire(ctx interface{}, key interface{}, expiration interface{}) *MockPipeliner_PExpire_Call {
	return &MockPipeliner_PExpire_Call{Call: _e.mock.On("PExpire", ctx, key, expiration)}
}

func (_c *MockPipeliner_PExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockPipeliner_PExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_PExpire_Call) Return(_a0 *BoolCmd) *MockPipeliner_PExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockPipeliner_PExpire_Call {
	_c.Call.Return(run)
	return _c
}

// PExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockPipeliner) PExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_PExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpireAt'
type MockPipeliner_PExpireAt_Call struct {
	*mock.Call
}

// PExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockPipeliner_Expecter) PExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockPipeliner_PExpireAt_Call {
	return &MockPipeliner_PExpireAt_Call{Call: _e.mock.On("PExpireAt", ctx, key, tm)}
}

func (_c *MockPipeliner_PExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockPipeliner_PExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockPipeliner_PExpireAt_Call) Return(_a0 *BoolCmd) *MockPipeliner_PExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *BoolCmd) *MockPipeliner_PExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// PExpireTime provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) PExpireTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PExpireTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockPipeliner_PExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpireTime'
type MockPipeliner_PExpireTime_Call struct {
	*mock.Call
}

// PExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) PExpireTime(ctx interface{}, key interface{}) *MockPipeliner_PExpireTime_Call {
	return &MockPipeliner_PExpireTime_Call{Call: _e.mock.On("PExpireTime", ctx, key)}
}

func (_c *MockPipeliner_PExpireTime_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_PExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_PExpireTime_Call) Return(_a0 *DurationCmd) *MockPipeliner_PExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PExpireTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockPipeliner_PExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// PFAdd provides a mock function with given fields: ctx, key, els
func (_m *MockPipeliner) PFAdd(ctx context.Context, key string, els ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_PFAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFAdd'
type MockPipeliner_PFAdd_Call struct {
	*mock.Call
}

// PFAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - els ...interface{}
func (_e *MockPipeliner_Expecter) PFAdd(ctx interface{}, key interface{}, els ...interface{}) *MockPipeliner_PFAdd_Call {
	return &MockPipeliner_PFAdd_Call{Call: _e.mock.On("PFAdd",
		append([]interface{}{ctx, key}, els...)...)}
}

func (_c *MockPipeliner_PFAdd_Call) Run(run func(ctx context.Context, key string, els ...interface{})) *MockPipeliner_PFAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_PFAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_PFAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PFAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_PFAdd_Call {
	_c.Call.Return(run)
	return _c
}

// PFCount provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) PFCount(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_PFCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFCount'
type MockPipeliner_PFCount_Call struct {
	*mock.Call
}

// PFCount is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) PFCount(ctx interface{}, keys ...interface{}) *MockPipeliner_PFCount_Call {
	return &MockPipeliner_PFCount_Call{Call: _e.mock.On("PFCount",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_PFCount_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_PFCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_PFCount_Call) Return(_a0 *IntCmd) *MockPipeliner_PFCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PFCount_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_PFCount_Call {
	_c.Call.Return(run)
	return _c
}

// PFMerge provides a mock function with given fields: ctx, dest, keys
func (_m *MockPipeliner) PFMerge(ctx context.Context, dest string, keys ...string) *StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFMerge")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StatusCmd); ok {
		r0 = rf(ctx, dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_PFMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PFMerge'
type MockPipeliner_PFMerge_Call struct {
	*mock.Call
}

// PFMerge is a helper method to define mock.On call
//   - ctx context.Context
//   - dest string
//   - keys ...string
func (_e *MockPipeliner_Expecter) PFMerge(ctx interface{}, dest interface{}, keys ...interface{}) *MockPipeliner_PFMerge_Call {
	return &MockPipeliner_PFMerge_Call{Call: _e.mock.On("PFMerge",
		append([]interface{}{ctx, dest}, keys...)...)}
}

func (_c *MockPipeliner_PFMerge_Call) Run(run func(ctx context.Context, dest string, keys ...string)) *MockPipeliner_PFMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_PFMerge_Call) Return(_a0 *StatusCmd) *MockPipeliner_PFMerge_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PFMerge_Call) RunAndReturn(run func(context.Context, string, ...string) *StatusCmd) *MockPipeliner_PFMerge_Call {
	_c.Call.Return(run)
	return _c
}

// PTTL provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) PTTL(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockPipeliner_PTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PTTL'
type MockPipeliner_PTTL_Call struct {
	*mock.Call
}

// PTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) PTTL(ctx interface{}, key interface{}) *MockPipeliner_PTTL_Call {
	return &MockPipeliner_PTTL_Call{Call: _e.mock.On("PTTL", ctx, key)}
}

func (_c *MockPipeliner_PTTL_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_PTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_PTTL_Call) Return(_a0 *DurationCmd) *MockPipeliner_PTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PTTL_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockPipeliner_PTTL_Call {
	_c.Call.Return(run)
	return _c
}

// Persist provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Persist(ctx context.Context, key string) *BoolCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BoolCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_Persist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Persist'
type MockPipeliner_Persist_Call struct {
	*mock.Call
}

// Persist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Persist(ctx interface{}, key interface{}) *MockPipeliner_Persist_Call {
	return &MockPipeliner_Persist_Call{Call: _e.mock.On("Persist", ctx, key)}
}

func (_c *MockPipeliner_Persist_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Persist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Persist_Call) Return(_a0 *BoolCmd) *MockPipeliner_Persist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Persist_Call) RunAndReturn(run func(context.Context, string) *BoolCmd) *MockPipeliner_Persist_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields: ctx
func (_m *MockPipeliner) Ping(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type MockPipeliner_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Ping(ctx interface{}) *MockPipeliner_Ping_Call {
	return &MockPipeliner_Ping_Call{Call: _e.mock.On("Ping", ctx)}
}

func (_c *MockPipeliner_Ping_Call) Run(run func(ctx context.Context)) *MockPipeliner_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Ping_Call) Return(_a0 *StatusCmd) *MockPipeliner_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Ping_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// Pipeline provides a mock function with no fields
func (_m *MockPipeliner) Pipeline() Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pipeline")
	}

	var r0 Pipeliner
	if rf, ok := ret.Get(0).(func() Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Pipeliner)
		}
	}

	return r0
}

// MockPipeliner_Pipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pipeline'
type MockPipeliner_Pipeline_Call struct {
	*mock.Call
}

// Pipeline is a helper method to define mock.On call
func (_e *MockPipeliner_Expecter) Pipeline() *MockPipeliner_Pipeline_Call {
	return &MockPipeliner_Pipeline_Call{Call: _e.mock.On("Pipeline")}
}

func (_c *MockPipeliner_Pipeline_Call) Run(run func()) *MockPipeliner_Pipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPipeliner_Pipeline_Call) Return(_a0 Pipeliner) *MockPipeliner_Pipeline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Pipeline_Call) RunAndReturn(run func() Pipeliner) *MockPipeliner_Pipeline_Call {
	_c.Call.Return(run)
	return _c
}

// Pipelined provides a mock function with given fields: ctx, fn
func (_m *MockPipeliner) Pipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Pipelined")
	}

	var r0 []Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(Pipeliner) error) ([]Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(Pipeliner) error) []Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPipeliner_Pipelined_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Pipelined'
type MockPipeliner_Pipelined_Call struct {
	*mock.Call
}

// Pipelined is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(Pipeliner) error
func (_e *MockPipeliner_Expecter) Pipelined(ctx interface{}, fn interface{}) *MockPipeliner_Pipelined_Call {
	return &MockPipeliner_Pipelined_Call{Call: _e.mock.On("Pipelined", ctx, fn)}
}

func (_c *MockPipeliner_Pipelined_Call) Run(run func(ctx context.Context, fn func(Pipeliner) error)) *MockPipeliner_Pipelined_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(Pipeliner) error))
	})
	return _c
}

func (_c *MockPipeliner_Pipelined_Call) Return(_a0 []Cmder, _a1 error) *MockPipeliner_Pipelined_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPipeliner_Pipelined_Call) RunAndReturn(run func(context.Context, func(Pipeliner) error) ([]Cmder, error)) *MockPipeliner_Pipelined_Call {
	_c.Call.Return(run)
	return _c
}

// Process provides a mock function with given fields: ctx, cmd
func (_m *MockPipeliner) Process(ctx context.Context, cmd Cmder) error {
	ret := _m.Called(ctx, cmd)

	if len(ret) == 0 {
		panic("no return value specified for Process")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Cmder) error); ok {
		r0 = rf(ctx, cmd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockPipeliner_Process_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Process'
type MockPipeliner_Process_Call struct {
	*mock.Call
}

// Process is a helper method to define mock.On call
//   - ctx context.Context
//   - cmd Cmder
func (_e *MockPipeliner_Expecter) Process(ctx interface{}, cmd interface{}) *MockPipeliner_Process_Call {
	return &MockPipeliner_Process_Call{Call: _e.mock.On("Process", ctx, cmd)}
}

func (_c *MockPipeliner_Process_Call) Run(run func(ctx context.Context, cmd Cmder)) *MockPipeliner_Process_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(Cmder))
	})
	return _c
}

func (_c *MockPipeliner_Process_Call) Return(_a0 error) *MockPipeliner_Process_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Process_Call) RunAndReturn(run func(context.Context, Cmder) error) *MockPipeliner_Process_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubChannels provides a mock function with given fields: ctx, pattern
func (_m *MockPipeliner) PubSubChannels(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_PubSubChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubChannels'
type MockPipeliner_PubSubChannels_Call struct {
	*mock.Call
}

// PubSubChannels is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockPipeliner_Expecter) PubSubChannels(ctx interface{}, pattern interface{}) *MockPipeliner_PubSubChannels_Call {
	return &MockPipeliner_PubSubChannels_Call{Call: _e.mock.On("PubSubChannels", ctx, pattern)}
}

func (_c *MockPipeliner_PubSubChannels_Call) Run(run func(ctx context.Context, pattern string)) *MockPipeliner_PubSubChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_PubSubChannels_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_PubSubChannels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PubSubChannels_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_PubSubChannels_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumPat provides a mock function with given fields: ctx
func (_m *MockPipeliner) PubSubNumPat(ctx context.Context) *IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_PubSubNumPat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumPat'
type MockPipeliner_PubSubNumPat_Call struct {
	*mock.Call
}

// PubSubNumPat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) PubSubNumPat(ctx interface{}) *MockPipeliner_PubSubNumPat_Call {
	return &MockPipeliner_PubSubNumPat_Call{Call: _e.mock.On("PubSubNumPat", ctx)}
}

func (_c *MockPipeliner_PubSubNumPat_Call) Run(run func(ctx context.Context)) *MockPipeliner_PubSubNumPat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_PubSubNumPat_Call) Return(_a0 *IntCmd) *MockPipeliner_PubSubNumPat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PubSubNumPat_Call) RunAndReturn(run func(context.Context) *IntCmd) *MockPipeliner_PubSubNumPat_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumSub provides a mock function with given fields: ctx, channels
func (_m *MockPipeliner) PubSubNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringIntCmd)
		}
	}

	return r0
}

// MockPipeliner_PubSubNumSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumSub'
type MockPipeliner_PubSubNumSub_Call struct {
	*mock.Call
}

// PubSubNumSub is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockPipeliner_Expecter) PubSubNumSub(ctx interface{}, channels ...interface{}) *MockPipeliner_PubSubNumSub_Call {
	return &MockPipeliner_PubSubNumSub_Call{Call: _e.mock.On("PubSubNumSub",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockPipeliner_PubSubNumSub_Call) Run(run func(ctx context.Context, channels ...string)) *MockPipeliner_PubSubNumSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_PubSubNumSub_Call) Return(_a0 *MapStringIntCmd) *MockPipeliner_PubSubNumSub_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PubSubNumSub_Call) RunAndReturn(run func(context.Context, ...string) *MapStringIntCmd) *MockPipeliner_PubSubNumSub_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubShardChannels provides a mock function with given fields: ctx, pattern
func (_m *MockPipeliner) PubSubShardChannels(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardChannels")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_PubSubShardChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubShardChannels'
type MockPipeliner_PubSubShardChannels_Call struct {
	*mock.Call
}

// PubSubShardChannels is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockPipeliner_Expecter) PubSubShardChannels(ctx interface{}, pattern interface{}) *MockPipeliner_PubSubShardChannels_Call {
	return &MockPipeliner_PubSubShardChannels_Call{Call: _e.mock.On("PubSubShardChannels", ctx, pattern)}
}

func (_c *MockPipeliner_PubSubShardChannels_Call) Run(run func(ctx context.Context, pattern string)) *MockPipeliner_PubSubShardChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_PubSubShardChannels_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_PubSubShardChannels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PubSubShardChannels_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_PubSubShardChannels_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubShardNumSub provides a mock function with given fields: ctx, channels
func (_m *MockPipeliner) PubSubShardNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardNumSub")
	}

	var r0 *MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringIntCmd)
		}
	}

	return r0
}

// MockPipeliner_PubSubShardNumSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubShardNumSub'
type MockPipeliner_PubSubShardNumSub_Call struct {
	*mock.Call
}

// PubSubShardNumSub is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockPipeliner_Expecter) PubSubShardNumSub(ctx interface{}, channels ...interface{}) *MockPipeliner_PubSubShardNumSub_Call {
	return &MockPipeliner_PubSubShardNumSub_Call{Call: _e.mock.On("PubSubShardNumSub",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockPipeliner_PubSubShardNumSub_Call) Run(run func(ctx context.Context, channels ...string)) *MockPipeliner_PubSubShardNumSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_PubSubShardNumSub_Call) Return(_a0 *MapStringIntCmd) *MockPipeliner_PubSubShardNumSub_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_PubSubShardNumSub_Call) RunAndReturn(run func(context.Context, ...string) *MapStringIntCmd) *MockPipeliner_PubSubShardNumSub_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, channel, message
func (_m *MockPipeliner) Publish(ctx context.Context, channel string, message interface{}) *IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockPipeliner_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - message interface{}
func (_e *MockPipeliner_Expecter) Publish(ctx interface{}, channel interface{}, message interface{}) *MockPipeliner_Publish_Call {
	return &MockPipeliner_Publish_Call{Call: _e.mock.On("Publish", ctx, channel, message)}
}

func (_c *MockPipeliner_Publish_Call) Run(run func(ctx context.Context, channel string, message interface{})) *MockPipeliner_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_Publish_Call) Return(_a0 *IntCmd) *MockPipeliner_Publish_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Publish_Call) RunAndReturn(run func(context.Context, string, interface{}) *IntCmd) *MockPipeliner_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// Quit provides a mock function with given fields: ctx
func (_m *MockPipeliner) Quit(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Quit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Quit'
type MockPipeliner_Quit_Call struct {
	*mock.Call
}

// Quit is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Quit(ctx interface{}) *MockPipeliner_Quit_Call {
	return &MockPipeliner_Quit_Call{Call: _e.mock.On("Quit", ctx)}
}

func (_c *MockPipeliner_Quit_Call) Run(run func(ctx context.Context)) *MockPipeliner_Quit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Quit_Call) Return(_a0 *StatusCmd) *MockPipeliner_Quit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Quit_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_Quit_Call {
	_c.Call.Return(run)
	return _c
}

// RPop provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) RPop(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_RPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPop'
type MockPipeliner_RPop_Call struct {
	*mock.Call
}

// RPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) RPop(ctx interface{}, key interface{}) *MockPipeliner_RPop_Call {
	return &MockPipeliner_RPop_Call{Call: _e.mock.On("RPop", ctx, key)}
}

func (_c *MockPipeliner_RPop_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_RPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_RPop_Call) Return(_a0 *StringCmd) *MockPipeliner_RPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RPop_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_RPop_Call {
	_c.Call.Return(run)
	return _c
}

// RPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) RPopCount(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for RPopCount")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_RPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopCount'
type MockPipeliner_RPopCount_Call struct {
	*mock.Call
}

// RPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) RPopCount(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_RPopCount_Call {
	return &MockPipeliner_RPopCount_Call{Call: _e.mock.On("RPopCount", ctx, key, count)}
}

func (_c *MockPipeliner_RPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_RPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_RPopCount_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_RPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RPopCount_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockPipeliner_RPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// RPopLPush provides a mock function with given fields: ctx, source, destination
func (_m *MockPipeliner) RPopLPush(ctx context.Context, source string, destination string) *StringCmd {
	ret := _m.Called(ctx, source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringCmd); ok {
		r0 = rf(ctx, source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_RPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopLPush'
type MockPipeliner_RPopLPush_Call struct {
	*mock.Call
}

// RPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
func (_e *MockPipeliner_Expecter) RPopLPush(ctx interface{}, source interface{}, destination interface{}) *MockPipeliner_RPopLPush_Call {
	return &MockPipeliner_RPopLPush_Call{Call: _e.mock.On("RPopLPush", ctx, source, destination)}
}

func (_c *MockPipeliner_RPopLPush_Call) Run(run func(ctx context.Context, source string, destination string)) *MockPipeliner_RPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_RPopLPush_Call) Return(_a0 *StringCmd) *MockPipeliner_RPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RPopLPush_Call) RunAndReturn(run func(context.Context, string, string) *StringCmd) *MockPipeliner_RPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPush provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) RPush(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_RPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPush'
type MockPipeliner_RPush_Call struct {
	*mock.Call
}

// RPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) RPush(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_RPush_Call {
	return &MockPipeliner_RPush_Call{Call: _e.mock.On("RPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_RPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_RPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_RPush_Call) Return(_a0 *IntCmd) *MockPipeliner_RPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_RPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPushX provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) RPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_RPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPushX'
type MockPipeliner_RPushX_Call struct {
	*mock.Call
}

// RPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockPipeliner_Expecter) RPushX(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_RPushX_Call {
	return &MockPipeliner_RPushX_Call{Call: _e.mock.On("RPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_RPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockPipeliner_RPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_RPushX_Call) Return(_a0 *IntCmd) *MockPipeliner_RPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_RPushX_Call {
	_c.Call.Return(run)
	return _c
}

// RandomKey provides a mock function with given fields: ctx
func (_m *MockPipeliner) RandomKey(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_RandomKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomKey'
type MockPipeliner_RandomKey_Call struct {
	*mock.Call
}

// RandomKey is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) RandomKey(ctx interface{}) *MockPipeliner_RandomKey_Call {
	return &MockPipeliner_RandomKey_Call{Call: _e.mock.On("RandomKey", ctx)}
}

func (_c *MockPipeliner_RandomKey_Call) Run(run func(ctx context.Context)) *MockPipeliner_RandomKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_RandomKey_Call) Return(_a0 *StringCmd) *MockPipeliner_RandomKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RandomKey_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockPipeliner_RandomKey_Call {
	_c.Call.Return(run)
	return _c
}

// ReadOnly provides a mock function with given fields: ctx
func (_m *MockPipeliner) ReadOnly(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadOnly")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ReadOnly_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadOnly'
type MockPipeliner_ReadOnly_Call struct {
	*mock.Call
}

// ReadOnly is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ReadOnly(ctx interface{}) *MockPipeliner_ReadOnly_Call {
	return &MockPipeliner_ReadOnly_Call{Call: _e.mock.On("ReadOnly", ctx)}
}

func (_c *MockPipeliner_ReadOnly_Call) Run(run func(ctx context.Context)) *MockPipeliner_ReadOnly_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ReadOnly_Call) Return(_a0 *StatusCmd) *MockPipeliner_ReadOnly_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ReadOnly_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ReadOnly_Call {
	_c.Call.Return(run)
	return _c
}

// ReadWrite provides a mock function with given fields: ctx
func (_m *MockPipeliner) ReadWrite(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ReadWrite")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ReadWrite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadWrite'
type MockPipeliner_ReadWrite_Call struct {
	*mock.Call
}

// ReadWrite is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ReadWrite(ctx interface{}) *MockPipeliner_ReadWrite_Call {
	return &MockPipeliner_ReadWrite_Call{Call: _e.mock.On("ReadWrite", ctx)}
}

func (_c *MockPipeliner_ReadWrite_Call) Run(run func(ctx context.Context)) *MockPipeliner_ReadWrite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ReadWrite_Call) Return(_a0 *StatusCmd) *MockPipeliner_ReadWrite_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ReadWrite_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ReadWrite_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: ctx, key, newkey
func (_m *MockPipeliner) Rename(ctx context.Context, key string, newkey string) *StatusCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type MockPipeliner_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockPipeliner_Expecter) Rename(ctx interface{}, key interface{}, newkey interface{}) *MockPipeliner_Rename_Call {
	return &MockPipeliner_Rename_Call{Call: _e.mock.On("Rename", ctx, key, newkey)}
}

func (_c *MockPipeliner_Rename_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockPipeliner_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_Rename_Call) Return(_a0 *StatusCmd) *MockPipeliner_Rename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Rename_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// RenameNX provides a mock function with given fields: ctx, key, newkey
func (_m *MockPipeliner) RenameNX(ctx context.Context, key string, newkey string) *BoolCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *BoolCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_RenameNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameNX'
type MockPipeliner_RenameNX_Call struct {
	*mock.Call
}

// RenameNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockPipeliner_Expecter) RenameNX(ctx interface{}, key interface{}, newkey interface{}) *MockPipeliner_RenameNX_Call {
	return &MockPipeliner_RenameNX_Call{Call: _e.mock.On("RenameNX", ctx, key, newkey)}
}

func (_c *MockPipeliner_RenameNX_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockPipeliner_RenameNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_RenameNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_RenameNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RenameNX_Call) RunAndReturn(run func(context.Context, string, string) *BoolCmd) *MockPipeliner_RenameNX_Call {
	_c.Call.Return(run)
	return _c
}

// Restore provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockPipeliner) Restore(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Restore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Restore'
type MockPipeliner_Restore_Call struct {
	*mock.Call
}

// Restore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockPipeliner_Expecter) Restore(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockPipeliner_Restore_Call {
	return &MockPipeliner_Restore_Call{Call: _e.mock.On("Restore", ctx, key, ttl, value)}
}

func (_c *MockPipeliner_Restore_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockPipeliner_Restore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_Restore_Call) Return(_a0 *StatusCmd) *MockPipeliner_Restore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Restore_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *StatusCmd) *MockPipeliner_Restore_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreReplace provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockPipeliner) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_RestoreReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreReplace'
type MockPipeliner_RestoreReplace_Call struct {
	*mock.Call
}

// RestoreReplace is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockPipeliner_Expecter) RestoreReplace(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockPipeliner_RestoreReplace_Call {
	return &MockPipeliner_RestoreReplace_Call{Call: _e.mock.On("RestoreReplace", ctx, key, ttl, value)}
}

func (_c *MockPipeliner_RestoreReplace_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockPipeliner_RestoreReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_RestoreReplace_Call) Return(_a0 *StatusCmd) *MockPipeliner_RestoreReplace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_RestoreReplace_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *StatusCmd) *MockPipeliner_RestoreReplace_Call {
	_c.Call.Return(run)
	return _c
}

// SAdd provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) SAdd(ctx context.Context, key string, members ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SAdd'
type MockPipeliner_SAdd_Call struct {
	*mock.Call
}

// SAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockPipeliner_Expecter) SAdd(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_SAdd_Call {
	return &MockPipeliner_SAdd_Call{Call: _e.mock.On("SAdd",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_SAdd_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockPipeliner_SAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_SAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_SAdd_Call {
	_c.Call.Return(run)
	return _c
}

// SCard provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) SCard(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SCard")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SCard'
type MockPipeliner_SCard_Call struct {
	*mock.Call
}

// SCard is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) SCard(ctx interface{}, key interface{}) *MockPipeliner_SCard_Call {
	return &MockPipeliner_SCard_Call{Call: _e.mock.On("SCard", ctx, key)}
}

func (_c *MockPipeliner_SCard_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_SCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_SCard_Call) Return(_a0 *IntCmd) *MockPipeliner_SCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SCard_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_SCard_Call {
	_c.Call.Return(run)
	return _c
}

// SDiff provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) SDiff(ctx context.Context, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiff")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SDiff'
type MockPipeliner_SDiff_Call struct {
	*mock.Call
}

// SDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) SDiff(ctx interface{}, keys ...interface{}) *MockPipeliner_SDiff_Call {
	return &MockPipeliner_SDiff_Call{Call: _e.mock.On("SDiff",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_SDiff_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_SDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SDiff_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SDiff_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SDiff_Call) RunAndReturn(run func(context.Context, ...string) *StringSliceCmd) *MockPipeliner_SDiff_Call {
	_c.Call.Return(run)
	return _c
}

// SDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockPipeliner) SDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiffStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SDiffStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SDiffStore'
type MockPipeliner_SDiffStore_Call struct {
	*mock.Call
}

// SDiffStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockPipeliner_Expecter) SDiffStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockPipeliner_SDiffStore_Call {
	return &MockPipeliner_SDiffStore_Call{Call: _e.mock.On("SDiffStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockPipeliner_SDiffStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockPipeliner_SDiffStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SDiffStore_Call) Return(_a0 *IntCmd) *MockPipeliner_SDiffStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SDiffStore_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_SDiffStore_Call {
	_c.Call.Return(run)
	return _c
}

// SInter provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) SInter(ctx context.Context, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInter")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SInter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SInter'
type MockPipeliner_SInter_Call struct {
	*mock.Call
}

// SInter is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) SInter(ctx interface{}, keys ...interface{}) *MockPipeliner_SInter_Call {
	return &MockPipeliner_SInter_Call{Call: _e.mock.On("SInter",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_SInter_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_SInter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SInter_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SInter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SInter_Call) RunAndReturn(run func(context.Context, ...string) *StringSliceCmd) *MockPipeliner_SInter_Call {
	_c.Call.Return(run)
	return _c
}

// SInterCard provides a mock function with given fields: ctx, limit, keys
func (_m *MockPipeliner) SInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterCard")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...string) *IntCmd); ok {
		r0 = rf(ctx, limit, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SInterCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SInterCard'
type MockPipeliner_SInterCard_Call struct {
	*mock.Call
}

// SInterCard is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) SInterCard(ctx interface{}, limit interface{}, keys ...interface{}) *MockPipeliner_SInterCard_Call {
	return &MockPipeliner_SInterCard_Call{Call: _e.mock.On("SInterCard",
		append([]interface{}{ctx, limit}, keys...)...)}
}

func (_c *MockPipeliner_SInterCard_Call) Run(run func(ctx context.Context, limit int64, keys ...string)) *MockPipeliner_SInterCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SInterCard_Call) Return(_a0 *IntCmd) *MockPipeliner_SInterCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SInterCard_Call) RunAndReturn(run func(context.Context, int64, ...string) *IntCmd) *MockPipeliner_SInterCard_Call {
	_c.Call.Return(run)
	return _c
}

// SInterStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockPipeliner) SInterStore(ctx context.Context, destination string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SInterStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SInterStore'
type MockPipeliner_SInterStore_Call struct {
	*mock.Call
}

// SInterStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockPipeliner_Expecter) SInterStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockPipeliner_SInterStore_Call {
	return &MockPipeliner_SInterStore_Call{Call: _e.mock.On("SInterStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockPipeliner_SInterStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockPipeliner_SInterStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SInterStore_Call) Return(_a0 *IntCmd) *MockPipeliner_SInterStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SInterStore_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_SInterStore_Call {
	_c.Call.Return(run)
	return _c
}

// SIsMember provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) SIsMember(ctx context.Context, key string, member interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for SIsMember")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_SIsMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SIsMember'
type MockPipeliner_SIsMember_Call struct {
	*mock.Call
}

// SIsMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member interface{}
func (_e *MockPipeliner_Expecter) SIsMember(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_SIsMember_Call {
	return &MockPipeliner_SIsMember_Call{Call: _e.mock.On("SIsMember", ctx, key, member)}
}

func (_c *MockPipeliner_SIsMember_Call) Run(run func(ctx context.Context, key string, member interface{})) *MockPipeliner_SIsMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_SIsMember_Call) Return(_a0 *BoolCmd) *MockPipeliner_SIsMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SIsMember_Call) RunAndReturn(run func(context.Context, string, interface{}) *BoolCmd) *MockPipeliner_SIsMember_Call {
	_c.Call.Return(run)
	return _c
}

// SMIsMember provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) SMIsMember(ctx context.Context, key string, members ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SMIsMember")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SMIsMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMIsMember'
type MockPipeliner_SMIsMember_Call struct {
	*mock.Call
}

// SMIsMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockPipeliner_Expecter) SMIsMember(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_SMIsMember_Call {
	return &MockPipeliner_SMIsMember_Call{Call: _e.mock.On("SMIsMember",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_SMIsMember_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockPipeliner_SMIsMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SMIsMember_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_SMIsMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SMIsMember_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolSliceCmd) *MockPipeliner_SMIsMember_Call {
	_c.Call.Return(run)
	return _c
}

// SMembers provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) SMembers(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembers")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMembers'
type MockPipeliner_SMembers_Call struct {
	*mock.Call
}

// SMembers is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) SMembers(ctx interface{}, key interface{}) *MockPipeliner_SMembers_Call {
	return &MockPipeliner_SMembers_Call{Call: _e.mock.On("SMembers", ctx, key)}
}

func (_c *MockPipeliner_SMembers_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_SMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_SMembers_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SMembers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SMembers_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_SMembers_Call {
	_c.Call.Return(run)
	return _c
}

// SMembersMap provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) SMembersMap(ctx context.Context, key string) *StringStructMapCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SMembersMap")
	}

	var r0 *StringStructMapCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringStructMapCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringStructMapCmd)
		}
	}

	return r0
}

// MockPipeliner_SMembersMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMembersMap'
type MockPipeliner_SMembersMap_Call struct {
	*mock.Call
}

// SMembersMap is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) SMembersMap(ctx interface{}, key interface{}) *MockPipeliner_SMembersMap_Call {
	return &MockPipeliner_SMembersMap_Call{Call: _e.mock.On("SMembersMap", ctx, key)}
}

func (_c *MockPipeliner_SMembersMap_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_SMembersMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_SMembersMap_Call) Return(_a0 *StringStructMapCmd) *MockPipeliner_SMembersMap_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SMembersMap_Call) RunAndReturn(run func(context.Context, string) *StringStructMapCmd) *MockPipeliner_SMembersMap_Call {
	_c.Call.Return(run)
	return _c
}

// SMove provides a mock function with given fields: ctx, source, destination, member
func (_m *MockPipeliner) SMove(ctx context.Context, source string, destination string, member interface{}) *BoolCmd {
	ret := _m.Called(ctx, source, destination, member)

	if len(ret) == 0 {
		panic("no return value specified for SMove")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_SMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SMove'
type MockPipeliner_SMove_Call struct {
	*mock.Call
}

// SMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - member interface{}
func (_e *MockPipeliner_Expecter) SMove(ctx interface{}, source interface{}, destination interface{}, member interface{}) *MockPipeliner_SMove_Call {
	return &MockPipeliner_SMove_Call{Call: _e.mock.On("SMove", ctx, source, destination, member)}
}

func (_c *MockPipeliner_SMove_Call) Run(run func(ctx context.Context, source string, destination string, member interface{})) *MockPipeliner_SMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_SMove_Call) Return(_a0 *BoolCmd) *MockPipeliner_SMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SMove_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *BoolCmd) *MockPipeliner_SMove_Call {
	_c.Call.Return(run)
	return _c
}

// SPop provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) SPop(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SPop")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_SPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPop'
type MockPipeliner_SPop_Call struct {
	*mock.Call
}

// SPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) SPop(ctx interface{}, key interface{}) *MockPipeliner_SPop_Call {
	return &MockPipeliner_SPop_Call{Call: _e.mock.On("SPop", ctx, key)}
}

func (_c *MockPipeliner_SPop_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_SPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_SPop_Call) Return(_a0 *StringCmd) *MockPipeliner_SPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SPop_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_SPop_Call {
	_c.Call.Return(run)
	return _c
}

// SPopN provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) SPopN(ctx context.Context, key string, count int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SPopN")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SPopN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPopN'
type MockPipeliner_SPopN_Call struct {
	*mock.Call
}

// SPopN is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
func (_e *MockPipeliner_Expecter) SPopN(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_SPopN_Call {
	return &MockPipeliner_SPopN_Call{Call: _e.mock.On("SPopN", ctx, key, count)}
}

func (_c *MockPipeliner_SPopN_Call) Run(run func(ctx context.Context, key string, count int64)) *MockPipeliner_SPopN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_SPopN_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SPopN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SPopN_Call) RunAndReturn(run func(context.Context, string, int64) *StringSliceCmd) *MockPipeliner_SPopN_Call {
	_c.Call.Return(run)
	return _c
}

// SPublish provides a mock function with given fields: ctx, channel, message
func (_m *MockPipeliner) SPublish(ctx context.Context, channel string, message interface{}) *IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for SPublish")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SPublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPublish'
type MockPipeliner_SPublish_Call struct {
	*mock.Call
}

// SPublish is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - message interface{}
func (_e *MockPipeliner_Expecter) SPublish(ctx interface{}, channel interface{}, message interface{}) *MockPipeliner_SPublish_Call {
	return &MockPipeliner_SPublish_Call{Call: _e.mock.On("SPublish", ctx, channel, message)}
}

func (_c *MockPipeliner_SPublish_Call) Run(run func(ctx context.Context, channel string, message interface{})) *MockPipeliner_SPublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPipeliner_SPublish_Call) Return(_a0 *IntCmd) *MockPipeliner_SPublish_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SPublish_Call) RunAndReturn(run func(context.Context, string, interface{}) *IntCmd) *MockPipeliner_SPublish_Call {
	_c.Call.Return(run)
	return _c
}

// SRandMember provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) SRandMember(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for SRandMember")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_SRandMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRandMember'
type MockPipeliner_SRandMember_Call struct {
	*mock.Call
}

// SRandMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) SRandMember(ctx interface{}, key interface{}) *MockPipeliner_SRandMember_Call {
	return &MockPipeliner_SRandMember_Call{Call: _e.mock.On("SRandMember", ctx, key)}
}

func (_c *MockPipeliner_SRandMember_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_SRandMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_SRandMember_Call) Return(_a0 *StringCmd) *MockPipeliner_SRandMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SRandMember_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_SRandMember_Call {
	_c.Call.Return(run)
	return _c
}

// SRandMemberN provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) SRandMemberN(ctx context.Context, key string, count int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for SRandMemberN")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SRandMemberN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRandMemberN'
type MockPipeliner_SRandMemberN_Call struct {
	*mock.Call
}

// SRandMemberN is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
func (_e *MockPipeliner_Expecter) SRandMemberN(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_SRandMemberN_Call {
	return &MockPipeliner_SRandMemberN_Call{Call: _e.mock.On("SRandMemberN", ctx, key, count)}
}

func (_c *MockPipeliner_SRandMemberN_Call) Run(run func(ctx context.Context, key string, count int64)) *MockPipeliner_SRandMemberN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_SRandMemberN_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SRandMemberN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SRandMemberN_Call) RunAndReturn(run func(context.Context, string, int64) *StringSliceCmd) *MockPipeliner_SRandMemberN_Call {
	_c.Call.Return(run)
	return _c
}

// SRem provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) SRem(ctx context.Context, key string, members ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SRem")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SRem'
type MockPipeliner_SRem_Call struct {
	*mock.Call
}

// SRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockPipeliner_Expecter) SRem(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_SRem_Call {
	return &MockPipeliner_SRem_Call{Call: _e.mock.On("SRem",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_SRem_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockPipeliner_SRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SRem_Call) Return(_a0 *IntCmd) *MockPipeliner_SRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SRem_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_SRem_Call {
	_c.Call.Return(run)
	return _c
}

// SScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockPipeliner) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for SScan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_SScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SScan'
type MockPipeliner_SScan_Call struct {
	*mock.Call
}

// SScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockPipeliner_Expecter) SScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockPipeliner_SScan_Call {
	return &MockPipeliner_SScan_Call{Call: _e.mock.On("SScan", ctx, key, cursor, match, count)}
}

func (_c *MockPipeliner_SScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockPipeliner_SScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_SScan_Call) Return(_a0 *ScanCmd) *MockPipeliner_SScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockPipeliner_SScan_Call {
	_c.Call.Return(run)
	return _c
}

// SUnion provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) SUnion(ctx context.Context, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnion")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SUnion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SUnion'
type MockPipeliner_SUnion_Call struct {
	*mock.Call
}

// SUnion is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) SUnion(ctx interface{}, keys ...interface{}) *MockPipeliner_SUnion_Call {
	return &MockPipeliner_SUnion_Call{Call: _e.mock.On("SUnion",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_SUnion_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_SUnion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SUnion_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SUnion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SUnion_Call) RunAndReturn(run func(context.Context, ...string) *StringSliceCmd) *MockPipeliner_SUnion_Call {
	_c.Call.Return(run)
	return _c
}

// SUnionStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockPipeliner) SUnionStore(ctx context.Context, destination string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnionStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SUnionStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SUnionStore'
type MockPipeliner_SUnionStore_Call struct {
	*mock.Call
}

// SUnionStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockPipeliner_Expecter) SUnionStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockPipeliner_SUnionStore_Call {
	return &MockPipeliner_SUnionStore_Call{Call: _e.mock.On("SUnionStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockPipeliner_SUnionStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockPipeliner_SUnionStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_SUnionStore_Call) Return(_a0 *IntCmd) *MockPipeliner_SUnionStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SUnionStore_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_SUnionStore_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx
func (_m *MockPipeliner) Save(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockPipeliner_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Save(ctx interface{}) *MockPipeliner_Save_Call {
	return &MockPipeliner_Save_Call{Call: _e.mock.On("Save", ctx)}
}

func (_c *MockPipeliner_Save_Call) Run(run func(ctx context.Context)) *MockPipeliner_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Save_Call) Return(_a0 *StatusCmd) *MockPipeliner_Save_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Save_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_Save_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: ctx, cursor, match, count
func (_m *MockPipeliner) Scan(ctx context.Context, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type MockPipeliner_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockPipeliner_Expecter) Scan(ctx interface{}, cursor interface{}, match interface{}, count interface{}) *MockPipeliner_Scan_Call {
	return &MockPipeliner_Scan_Call{Call: _e.mock.On("Scan", ctx, cursor, match, count)}
}

func (_c *MockPipeliner_Scan_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64)) *MockPipeliner_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_Scan_Call) Return(_a0 *ScanCmd) *MockPipeliner_Scan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Scan_Call) RunAndReturn(run func(context.Context, uint64, string, int64) *ScanCmd) *MockPipeliner_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanType provides a mock function with given fields: ctx, cursor, match, count, keyType
func (_m *MockPipeliner) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *ScanCmd {
	ret := _m.Called(ctx, cursor, match, count, keyType)

	if len(ret) == 0 {
		panic("no return value specified for ScanType")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64, string) *ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count, keyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_ScanType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanType'
type MockPipeliner_ScanType_Call struct {
	*mock.Call
}

// ScanType is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
//   - keyType string
func (_e *MockPipeliner_Expecter) ScanType(ctx interface{}, cursor interface{}, match interface{}, count interface{}, keyType interface{}) *MockPipeliner_ScanType_Call {
	return &MockPipeliner_ScanType_Call{Call: _e.mock.On("ScanType", ctx, cursor, match, count, keyType)}
}

func (_c *MockPipeliner_ScanType_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64, keyType string)) *MockPipeliner_ScanType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64), args[4].(string))
	})
	return _c
}

func (_c *MockPipeliner_ScanType_Call) Return(_a0 *ScanCmd) *MockPipeliner_ScanType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ScanType_Call) RunAndReturn(run func(context.Context, uint64, string, int64, string) *ScanCmd) *MockPipeliner_ScanType_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptExists provides a mock function with given fields: ctx, hashes
func (_m *MockPipeliner) ScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *BoolSliceCmd); ok {
		r0 = rf(ctx, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ScriptExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptExists'
type MockPipeliner_ScriptExists_Call struct {
	*mock.Call
}

// ScriptExists is a helper method to define mock.On call
//   - ctx context.Context
//   - hashes ...string
func (_e *MockPipeliner_Expecter) ScriptExists(ctx interface{}, hashes ...interface{}) *MockPipeliner_ScriptExists_Call {
	return &MockPipeliner_ScriptExists_Call{Call: _e.mock.On("ScriptExists",
		append([]interface{}{ctx}, hashes...)...)}
}

func (_c *MockPipeliner_ScriptExists_Call) Run(run func(ctx context.Context, hashes ...string)) *MockPipeliner_ScriptExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ScriptExists_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_ScriptExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ScriptExists_Call) RunAndReturn(run func(context.Context, ...string) *BoolSliceCmd) *MockPipeliner_ScriptExists_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptFlush provides a mock function with given fields: ctx
func (_m *MockPipeliner) ScriptFlush(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ScriptFlush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptFlush'
type MockPipeliner_ScriptFlush_Call struct {
	*mock.Call
}

// ScriptFlush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ScriptFlush(ctx interface{}) *MockPipeliner_ScriptFlush_Call {
	return &MockPipeliner_ScriptFlush_Call{Call: _e.mock.On("ScriptFlush", ctx)}
}

func (_c *MockPipeliner_ScriptFlush_Call) Run(run func(ctx context.Context)) *MockPipeliner_ScriptFlush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ScriptFlush_Call) Return(_a0 *StatusCmd) *MockPipeliner_ScriptFlush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ScriptFlush_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ScriptFlush_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptKill provides a mock function with given fields: ctx
func (_m *MockPipeliner) ScriptKill(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ScriptKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptKill'
type MockPipeliner_ScriptKill_Call struct {
	*mock.Call
}

// ScriptKill is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ScriptKill(ctx interface{}) *MockPipeliner_ScriptKill_Call {
	return &MockPipeliner_ScriptKill_Call{Call: _e.mock.On("ScriptKill", ctx)}
}

func (_c *MockPipeliner_ScriptKill_Call) Run(run func(ctx context.Context)) *MockPipeliner_ScriptKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ScriptKill_Call) Return(_a0 *StatusCmd) *MockPipeliner_ScriptKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ScriptKill_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ScriptKill_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptLoad provides a mock function with given fields: ctx, script
func (_m *MockPipeliner) ScriptLoad(ctx context.Context, script string) *StringCmd {
	ret := _m.Called(ctx, script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_ScriptLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptLoad'
type MockPipeliner_ScriptLoad_Call struct {
	*mock.Call
}

// ScriptLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
func (_e *MockPipeliner_Expecter) ScriptLoad(ctx interface{}, script interface{}) *MockPipeliner_ScriptLoad_Call {
	return &MockPipeliner_ScriptLoad_Call{Call: _e.mock.On("ScriptLoad", ctx, script)}
}

func (_c *MockPipeliner_ScriptLoad_Call) Run(run func(ctx context.Context, script string)) *MockPipeliner_ScriptLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ScriptLoad_Call) Return(_a0 *StringCmd) *MockPipeliner_ScriptLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ScriptLoad_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockPipeliner_ScriptLoad_Call {
	_c.Call.Return(run)
	return _c
}

// Select provides a mock function with given fields: ctx, index
func (_m *MockPipeliner) Select(ctx context.Context, index int) *StatusCmd {
	ret := _m.Called(ctx, index)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int) *StatusCmd); ok {
		r0 = rf(ctx, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Select_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Select'
type MockPipeliner_Select_Call struct {
	*mock.Call
}

// Select is a helper method to define mock.On call
//   - ctx context.Context
//   - index int
func (_e *MockPipeliner_Expecter) Select(ctx interface{}, index interface{}) *MockPipeliner_Select_Call {
	return &MockPipeliner_Select_Call{Call: _e.mock.On("Select", ctx, index)}
}

func (_c *MockPipeliner_Select_Call) Run(run func(ctx context.Context, index int)) *MockPipeliner_Select_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockPipeliner_Select_Call) Return(_a0 *StatusCmd) *MockPipeliner_Select_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Select_Call) RunAndReturn(run func(context.Context, int) *StatusCmd) *MockPipeliner_Select_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockPipeliner) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockPipeliner_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) Set(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockPipeliner_Set_Call {
	return &MockPipeliner_Set_Call{Call: _e.mock.On("Set", ctx, key, value, expiration)}
}

func (_c *MockPipeliner_Set_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockPipeliner_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_Set_Call) Return(_a0 *StatusCmd) *MockPipeliner_Set_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Set_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *StatusCmd) *MockPipeliner_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetArgs provides a mock function with given fields: ctx, key, value, a
func (_m *MockPipeliner) SetArgs(ctx context.Context, key string, value interface{}, a SetArgs) *StatusCmd {
	ret := _m.Called(ctx, key, value, a)

	if len(ret) == 0 {
		panic("no return value specified for SetArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, SetArgs) *StatusCmd); ok {
		r0 = rf(ctx, key, value, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_SetArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetArgs'
type MockPipeliner_SetArgs_Call struct {
	*mock.Call
}

// SetArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - a SetArgs
func (_e *MockPipeliner_Expecter) SetArgs(ctx interface{}, key interface{}, value interface{}, a interface{}) *MockPipeliner_SetArgs_Call {
	return &MockPipeliner_SetArgs_Call{Call: _e.mock.On("SetArgs", ctx, key, value, a)}
}

func (_c *MockPipeliner_SetArgs_Call) Run(run func(ctx context.Context, key string, value interface{}, a SetArgs)) *MockPipeliner_SetArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(SetArgs))
	})
	return _c
}

func (_c *MockPipeliner_SetArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_SetArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetArgs_Call) RunAndReturn(run func(context.Context, string, interface{}, SetArgs) *StatusCmd) *MockPipeliner_SetArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *MockPipeliner) SetBit(ctx context.Context, key string, offset int64, value int) *IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) *IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetBit'
type MockPipeliner_SetBit_Call struct {
	*mock.Call
}

// SetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value int
func (_e *MockPipeliner_Expecter) SetBit(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockPipeliner_SetBit_Call {
	return &MockPipeliner_SetBit_Call{Call: _e.mock.On("SetBit", ctx, key, offset, value)}
}

func (_c *MockPipeliner_SetBit_Call) Run(run func(ctx context.Context, key string, offset int64, value int)) *MockPipeliner_SetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_SetBit_Call) Return(_a0 *IntCmd) *MockPipeliner_SetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetBit_Call) RunAndReturn(run func(context.Context, string, int64, int) *IntCmd) *MockPipeliner_SetBit_Call {
	_c.Call.Return(run)
	return _c
}

// SetEx provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockPipeliner) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetEx")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_SetEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEx'
type MockPipeliner_SetEx_Call struct {
	*mock.Call
}

// SetEx is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) SetEx(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockPipeliner_SetEx_Call {
	return &MockPipeliner_SetEx_Call{Call: _e.mock.On("SetEx", ctx, key, value, expiration)}
}

func (_c *MockPipeliner_SetEx_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockPipeliner_SetEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_SetEx_Call) Return(_a0 *StatusCmd) *MockPipeliner_SetEx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetEx_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *StatusCmd) *MockPipeliner_SetEx_Call {
	_c.Call.Return(run)
	return _c
}

// SetNX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockPipeliner) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_SetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNX'
type MockPipeliner_SetNX_Call struct {
	*mock.Call
}

// SetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) SetNX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockPipeliner_SetNX_Call {
	return &MockPipeliner_SetNX_Call{Call: _e.mock.On("SetNX", ctx, key, value, expiration)}
}

func (_c *MockPipeliner_SetNX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockPipeliner_SetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_SetNX_Call) Return(_a0 *BoolCmd) *MockPipeliner_SetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetNX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *BoolCmd) *MockPipeliner_SetNX_Call {
	_c.Call.Return(run)
	return _c
}

// SetRange provides a mock function with given fields: ctx, key, offset, value
func (_m *MockPipeliner) SetRange(ctx context.Context, key string, offset int64, value string) *IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, string) *IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRange'
type MockPipeliner_SetRange_Call struct {
	*mock.Call
}

// SetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value string
func (_e *MockPipeliner_Expecter) SetRange(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockPipeliner_SetRange_Call {
	return &MockPipeliner_SetRange_Call{Call: _e.mock.On("SetRange", ctx, key, offset, value)}
}

func (_c *MockPipeliner_SetRange_Call) Run(run func(ctx context.Context, key string, offset int64, value string)) *MockPipeliner_SetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_SetRange_Call) Return(_a0 *IntCmd) *MockPipeliner_SetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetRange_Call) RunAndReturn(run func(context.Context, string, int64, string) *IntCmd) *MockPipeliner_SetRange_Call {
	_c.Call.Return(run)
	return _c
}

// SetXX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockPipeliner) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockPipeliner_SetXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetXX'
type MockPipeliner_SetXX_Call struct {
	*mock.Call
}

// SetXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockPipeliner_Expecter) SetXX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockPipeliner_SetXX_Call {
	return &MockPipeliner_SetXX_Call{Call: _e.mock.On("SetXX", ctx, key, value, expiration)}
}

func (_c *MockPipeliner_SetXX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockPipeliner_SetXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockPipeliner_SetXX_Call) Return(_a0 *BoolCmd) *MockPipeliner_SetXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SetXX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *BoolCmd) *MockPipeliner_SetXX_Call {
	_c.Call.Return(run)
	return _c
}

// Shutdown provides a mock function with given fields: ctx
func (_m *MockPipeliner) Shutdown(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Shutdown_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shutdown'
type MockPipeliner_Shutdown_Call struct {
	*mock.Call
}

// Shutdown is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Shutdown(ctx interface{}) *MockPipeliner_Shutdown_Call {
	return &MockPipeliner_Shutdown_Call{Call: _e.mock.On("Shutdown", ctx)}
}

func (_c *MockPipeliner_Shutdown_Call) Run(run func(ctx context.Context)) *MockPipeliner_Shutdown_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Shutdown_Call) Return(_a0 *StatusCmd) *MockPipeliner_Shutdown_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Shutdown_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_Shutdown_Call {
	_c.Call.Return(run)
	return _c
}

// ShutdownNoSave provides a mock function with given fields: ctx
func (_m *MockPipeliner) ShutdownNoSave(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownNoSave")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ShutdownNoSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutdownNoSave'
type MockPipeliner_ShutdownNoSave_Call struct {
	*mock.Call
}

// ShutdownNoSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ShutdownNoSave(ctx interface{}) *MockPipeliner_ShutdownNoSave_Call {
	return &MockPipeliner_ShutdownNoSave_Call{Call: _e.mock.On("ShutdownNoSave", ctx)}
}

func (_c *MockPipeliner_ShutdownNoSave_Call) Run(run func(ctx context.Context)) *MockPipeliner_ShutdownNoSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ShutdownNoSave_Call) Return(_a0 *StatusCmd) *MockPipeliner_ShutdownNoSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ShutdownNoSave_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ShutdownNoSave_Call {
	_c.Call.Return(run)
	return _c
}

// ShutdownSave provides a mock function with given fields: ctx
func (_m *MockPipeliner) ShutdownSave(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ShutdownSave")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_ShutdownSave_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShutdownSave'
type MockPipeliner_ShutdownSave_Call struct {
	*mock.Call
}

// ShutdownSave is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) ShutdownSave(ctx interface{}) *MockPipeliner_ShutdownSave_Call {
	return &MockPipeliner_ShutdownSave_Call{Call: _e.mock.On("ShutdownSave", ctx)}
}

func (_c *MockPipeliner_ShutdownSave_Call) Run(run func(ctx context.Context)) *MockPipeliner_ShutdownSave_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_ShutdownSave_Call) Return(_a0 *StatusCmd) *MockPipeliner_ShutdownSave_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ShutdownSave_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockPipeliner_ShutdownSave_Call {
	_c.Call.Return(run)
	return _c
}

// SlaveOf provides a mock function with given fields: ctx, host, port
func (_m *MockPipeliner) SlaveOf(ctx context.Context, host string, port string) *StatusCmd {
	ret := _m.Called(ctx, host, port)

	if len(ret) == 0 {
		panic("no return value specified for SlaveOf")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_SlaveOf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SlaveOf'
type MockPipeliner_SlaveOf_Call struct {
	*mock.Call
}

// SlaveOf is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
func (_e *MockPipeliner_Expecter) SlaveOf(ctx interface{}, host interface{}, port interface{}) *MockPipeliner_SlaveOf_Call {
	return &MockPipeliner_SlaveOf_Call{Call: _e.mock.On("SlaveOf", ctx, host, port)}
}

func (_c *MockPipeliner_SlaveOf_Call) Run(run func(ctx context.Context, host string, port string)) *MockPipeliner_SlaveOf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_SlaveOf_Call) Return(_a0 *StatusCmd) *MockPipeliner_SlaveOf_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SlaveOf_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_SlaveOf_Call {
	_c.Call.Return(run)
	return _c
}

// SlowLogGet provides a mock function with given fields: ctx, num
func (_m *MockPipeliner) SlowLogGet(ctx context.Context, num int64) *SlowLogCmd {
	ret := _m.Called(ctx, num)

	if len(ret) == 0 {
		panic("no return value specified for SlowLogGet")
	}

	var r0 *SlowLogCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *SlowLogCmd); ok {
		r0 = rf(ctx, num)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SlowLogCmd)
		}
	}

	return r0
}

// MockPipeliner_SlowLogGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SlowLogGet'
type MockPipeliner_SlowLogGet_Call struct {
	*mock.Call
}

// SlowLogGet is a helper method to define mock.On call
//   - ctx context.Context
//   - num int64
func (_e *MockPipeliner_Expecter) SlowLogGet(ctx interface{}, num interface{}) *MockPipeliner_SlowLogGet_Call {
	return &MockPipeliner_SlowLogGet_Call{Call: _e.mock.On("SlowLogGet", ctx, num)}
}

func (_c *MockPipeliner_SlowLogGet_Call) Run(run func(ctx context.Context, num int64)) *MockPipeliner_SlowLogGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockPipeliner_SlowLogGet_Call) Return(_a0 *SlowLogCmd) *MockPipeliner_SlowLogGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SlowLogGet_Call) RunAndReturn(run func(context.Context, int64) *SlowLogCmd) *MockPipeliner_SlowLogGet_Call {
	_c.Call.Return(run)
	return _c
}

// Sort provides a mock function with given fields: ctx, key, sort
func (_m *MockPipeliner) Sort(ctx context.Context, key string, sort *Sort) *StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_Sort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sort'
type MockPipeliner_Sort_Call struct {
	*mock.Call
}

// Sort is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockPipeliner_Expecter) Sort(ctx interface{}, key interface{}, sort interface{}) *MockPipeliner_Sort_Call {
	return &MockPipeliner_Sort_Call{Call: _e.mock.On("Sort", ctx, key, sort)}
}

func (_c *MockPipeliner_Sort_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockPipeliner_Sort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockPipeliner_Sort_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_Sort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Sort_Call) RunAndReturn(run func(context.Context, string, *Sort) *StringSliceCmd) *MockPipeliner_Sort_Call {
	_c.Call.Return(run)
	return _c
}

// SortInterfaces provides a mock function with given fields: ctx, key, sort
func (_m *MockPipeliner) SortInterfaces(ctx context.Context, key string, sort *Sort) *SliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *SliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SortInterfaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortInterfaces'
type MockPipeliner_SortInterfaces_Call struct {
	*mock.Call
}

// SortInterfaces is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockPipeliner_Expecter) SortInterfaces(ctx interface{}, key interface{}, sort interface{}) *MockPipeliner_SortInterfaces_Call {
	return &MockPipeliner_SortInterfaces_Call{Call: _e.mock.On("SortInterfaces", ctx, key, sort)}
}

func (_c *MockPipeliner_SortInterfaces_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockPipeliner_SortInterfaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockPipeliner_SortInterfaces_Call) Return(_a0 *SliceCmd) *MockPipeliner_SortInterfaces_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SortInterfaces_Call) RunAndReturn(run func(context.Context, string, *Sort) *SliceCmd) *MockPipeliner_SortInterfaces_Call {
	_c.Call.Return(run)
	return _c
}

// SortRO provides a mock function with given fields: ctx, key, sort
func (_m *MockPipeliner) SortRO(ctx context.Context, key string, sort *Sort) *StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortRO")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_SortRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortRO'
type MockPipeliner_SortRO_Call struct {
	*mock.Call
}

// SortRO is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockPipeliner_Expecter) SortRO(ctx interface{}, key interface{}, sort interface{}) *MockPipeliner_SortRO_Call {
	return &MockPipeliner_SortRO_Call{Call: _e.mock.On("SortRO", ctx, key, sort)}
}

func (_c *MockPipeliner_SortRO_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockPipeliner_SortRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockPipeliner_SortRO_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_SortRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SortRO_Call) RunAndReturn(run func(context.Context, string, *Sort) *StringSliceCmd) *MockPipeliner_SortRO_Call {
	_c.Call.Return(run)
	return _c
}

// SortStore provides a mock function with given fields: ctx, key, store, sort
func (_m *MockPipeliner) SortStore(ctx context.Context, key string, store string, sort *Sort) *IntCmd {
	ret := _m.Called(ctx, key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *Sort) *IntCmd); ok {
		r0 = rf(ctx, key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_SortStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortStore'
type MockPipeliner_SortStore_Call struct {
	*mock.Call
}

// SortStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - sort *Sort
func (_e *MockPipeliner_Expecter) SortStore(ctx interface{}, key interface{}, store interface{}, sort interface{}) *MockPipeliner_SortStore_Call {
	return &MockPipeliner_SortStore_Call{Call: _e.mock.On("SortStore", ctx, key, store, sort)}
}

func (_c *MockPipeliner_SortStore_Call) Run(run func(ctx context.Context, key string, store string, sort *Sort)) *MockPipeliner_SortStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*Sort))
	})
	return _c
}

func (_c *MockPipeliner_SortStore_Call) Return(_a0 *IntCmd) *MockPipeliner_SortStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SortStore_Call) RunAndReturn(run func(context.Context, string, string, *Sort) *IntCmd) *MockPipeliner_SortStore_Call {
	_c.Call.Return(run)
	return _c
}

// StrLen provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) StrLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_StrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StrLen'
type MockPipeliner_StrLen_Call struct {
	*mock.Call
}

// StrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) StrLen(ctx interface{}, key interface{}) *MockPipeliner_StrLen_Call {
	return &MockPipeliner_StrLen_Call{Call: _e.mock.On("StrLen", ctx, key)}
}

func (_c *MockPipeliner_StrLen_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_StrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_StrLen_Call) Return(_a0 *IntCmd) *MockPipeliner_StrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_StrLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_StrLen_Call {
	_c.Call.Return(run)
	return _c
}

// SwapDB provides a mock function with given fields: ctx, index1, index2
func (_m *MockPipeliner) SwapDB(ctx context.Context, index1 int, index2 int) *StatusCmd {
	ret := _m.Called(ctx, index1, index2)

	if len(ret) == 0 {
		panic("no return value specified for SwapDB")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *StatusCmd); ok {
		r0 = rf(ctx, index1, index2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_SwapDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SwapDB'
type MockPipeliner_SwapDB_Call struct {
	*mock.Call
}

// SwapDB is a helper method to define mock.On call
//   - ctx context.Context
//   - index1 int
//   - index2 int
func (_e *MockPipeliner_Expecter) SwapDB(ctx interface{}, index1 interface{}, index2 interface{}) *MockPipeliner_SwapDB_Call {
	return &MockPipeliner_SwapDB_Call{Call: _e.mock.On("SwapDB", ctx, index1, index2)}
}

func (_c *MockPipeliner_SwapDB_Call) Run(run func(ctx context.Context, index1 int, index2 int)) *MockPipeliner_SwapDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_SwapDB_Call) Return(_a0 *StatusCmd) *MockPipeliner_SwapDB_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_SwapDB_Call) RunAndReturn(run func(context.Context, int, int) *StatusCmd) *MockPipeliner_SwapDB_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestAdd provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TDigestAdd(ctx context.Context, key string, elements ...float64) *StatusCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestAdd")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *StatusCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestAdd'
type MockPipeliner_TDigestAdd_Call struct {
	*mock.Call
}

// TDigestAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...float64
func (_e *MockPipeliner_Expecter) TDigestAdd(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TDigestAdd_Call {
	return &MockPipeliner_TDigestAdd_Call{Call: _e.mock.On("TDigestAdd",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TDigestAdd_Call) Run(run func(ctx context.Context, key string, elements ...float64)) *MockPipeliner_TDigestAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]float64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(float64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestAdd_Call) Return(_a0 *StatusCmd) *MockPipeliner_TDigestAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestAdd_Call) RunAndReturn(run func(context.Context, string, ...float64) *StatusCmd) *MockPipeliner_TDigestAdd_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestByRank provides a mock function with given fields: ctx, key, rank
func (_m *MockPipeliner) TDigestByRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd {
	_va := make([]interface{}, len(rank))
	for _i := range rank {
		_va[_i] = rank[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestByRank")
	}

	var r0 *FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...uint64) *FloatSliceCmd); ok {
		r0 = rf(ctx, key, rank...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestByRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestByRank'
type MockPipeliner_TDigestByRank_Call struct {
	*mock.Call
}

// TDigestByRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - rank ...uint64
func (_e *MockPipeliner_Expecter) TDigestByRank(ctx interface{}, key interface{}, rank ...interface{}) *MockPipeliner_TDigestByRank_Call {
	return &MockPipeliner_TDigestByRank_Call{Call: _e.mock.On("TDigestByRank",
		append([]interface{}{ctx, key}, rank...)...)}
}

func (_c *MockPipeliner_TDigestByRank_Call) Run(run func(ctx context.Context, key string, rank ...uint64)) *MockPipeliner_TDigestByRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestByRank_Call) Return(_a0 *FloatSliceCmd) *MockPipeliner_TDigestByRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestByRank_Call) RunAndReturn(run func(context.Context, string, ...uint64) *FloatSliceCmd) *MockPipeliner_TDigestByRank_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestByRevRank provides a mock function with given fields: ctx, key, rank
func (_m *MockPipeliner) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *FloatSliceCmd {
	_va := make([]interface{}, len(rank))
	for _i := range rank {
		_va[_i] = rank[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestByRevRank")
	}

	var r0 *FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...uint64) *FloatSliceCmd); ok {
		r0 = rf(ctx, key, rank...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestByRevRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestByRevRank'
type MockPipeliner_TDigestByRevRank_Call struct {
	*mock.Call
}

// TDigestByRevRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - rank ...uint64
func (_e *MockPipeliner_Expecter) TDigestByRevRank(ctx interface{}, key interface{}, rank ...interface{}) *MockPipeliner_TDigestByRevRank_Call {
	return &MockPipeliner_TDigestByRevRank_Call{Call: _e.mock.On("TDigestByRevRank",
		append([]interface{}{ctx, key}, rank...)...)}
}

func (_c *MockPipeliner_TDigestByRevRank_Call) Run(run func(ctx context.Context, key string, rank ...uint64)) *MockPipeliner_TDigestByRevRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]uint64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(uint64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestByRevRank_Call) Return(_a0 *FloatSliceCmd) *MockPipeliner_TDigestByRevRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestByRevRank_Call) RunAndReturn(run func(context.Context, string, ...uint64) *FloatSliceCmd) *MockPipeliner_TDigestByRevRank_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestCDF provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TDigestCDF(ctx context.Context, key string, elements ...float64) *FloatSliceCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCDF")
	}

	var r0 *FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *FloatSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestCDF_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestCDF'
type MockPipeliner_TDigestCDF_Call struct {
	*mock.Call
}

// TDigestCDF is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...float64
func (_e *MockPipeliner_Expecter) TDigestCDF(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TDigestCDF_Call {
	return &MockPipeliner_TDigestCDF_Call{Call: _e.mock.On("TDigestCDF",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TDigestCDF_Call) Run(run func(ctx context.Context, key string, elements ...float64)) *MockPipeliner_TDigestCDF_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]float64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(float64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestCDF_Call) Return(_a0 *FloatSliceCmd) *MockPipeliner_TDigestCDF_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestCDF_Call) RunAndReturn(run func(context.Context, string, ...float64) *FloatSliceCmd) *MockPipeliner_TDigestCDF_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestCreate provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TDigestCreate(ctx context.Context, key string) *StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCreate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestCreate'
type MockPipeliner_TDigestCreate_Call struct {
	*mock.Call
}

// TDigestCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TDigestCreate(ctx interface{}, key interface{}) *MockPipeliner_TDigestCreate_Call {
	return &MockPipeliner_TDigestCreate_Call{Call: _e.mock.On("TDigestCreate", ctx, key)}
}

func (_c *MockPipeliner_TDigestCreate_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TDigestCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TDigestCreate_Call) Return(_a0 *StatusCmd) *MockPipeliner_TDigestCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestCreate_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_TDigestCreate_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestCreateWithCompression provides a mock function with given fields: ctx, key, compression
func (_m *MockPipeliner) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *StatusCmd {
	ret := _m.Called(ctx, key, compression)

	if len(ret) == 0 {
		panic("no return value specified for TDigestCreateWithCompression")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, compression)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestCreateWithCompression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestCreateWithCompression'
type MockPipeliner_TDigestCreateWithCompression_Call struct {
	*mock.Call
}

// TDigestCreateWithCompression is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - compression int64
func (_e *MockPipeliner_Expecter) TDigestCreateWithCompression(ctx interface{}, key interface{}, compression interface{}) *MockPipeliner_TDigestCreateWithCompression_Call {
	return &MockPipeliner_TDigestCreateWithCompression_Call{Call: _e.mock.On("TDigestCreateWithCompression", ctx, key, compression)}
}

func (_c *MockPipeliner_TDigestCreateWithCompression_Call) Run(run func(ctx context.Context, key string, compression int64)) *MockPipeliner_TDigestCreateWithCompression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_TDigestCreateWithCompression_Call) Return(_a0 *StatusCmd) *MockPipeliner_TDigestCreateWithCompression_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestCreateWithCompression_Call) RunAndReturn(run func(context.Context, string, int64) *StatusCmd) *MockPipeliner_TDigestCreateWithCompression_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TDigestInfo(ctx context.Context, key string) *TDigestInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestInfo")
	}

	var r0 *TDigestInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *TDigestInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TDigestInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestInfo'
type MockPipeliner_TDigestInfo_Call struct {
	*mock.Call
}

// TDigestInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TDigestInfo(ctx interface{}, key interface{}) *MockPipeliner_TDigestInfo_Call {
	return &MockPipeliner_TDigestInfo_Call{Call: _e.mock.On("TDigestInfo", ctx, key)}
}

func (_c *MockPipeliner_TDigestInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TDigestInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TDigestInfo_Call) Return(_a0 *TDigestInfoCmd) *MockPipeliner_TDigestInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestInfo_Call) RunAndReturn(run func(context.Context, string) *TDigestInfoCmd) *MockPipeliner_TDigestInfo_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestMax provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TDigestMax(ctx context.Context, key string) *FloatCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMax")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *FloatCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestMax'
type MockPipeliner_TDigestMax_Call struct {
	*mock.Call
}

// TDigestMax is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TDigestMax(ctx interface{}, key interface{}) *MockPipeliner_TDigestMax_Call {
	return &MockPipeliner_TDigestMax_Call{Call: _e.mock.On("TDigestMax", ctx, key)}
}

func (_c *MockPipeliner_TDigestMax_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TDigestMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TDigestMax_Call) Return(_a0 *FloatCmd) *MockPipeliner_TDigestMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestMax_Call) RunAndReturn(run func(context.Context, string) *FloatCmd) *MockPipeliner_TDigestMax_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestMerge provides a mock function with given fields: ctx, destKey, options, sourceKeys
func (_m *MockPipeliner) TDigestMerge(ctx context.Context, destKey string, options *TDigestMergeOptions, sourceKeys ...string) *StatusCmd {
	_va := make([]interface{}, len(sourceKeys))
	for _i := range sourceKeys {
		_va[_i] = sourceKeys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey, options)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMerge")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TDigestMergeOptions, ...string) *StatusCmd); ok {
		r0 = rf(ctx, destKey, options, sourceKeys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestMerge'
type MockPipeliner_TDigestMerge_Call struct {
	*mock.Call
}

// TDigestMerge is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - options *TDigestMergeOptions
//   - sourceKeys ...string
func (_e *MockPipeliner_Expecter) TDigestMerge(ctx interface{}, destKey interface{}, options interface{}, sourceKeys ...interface{}) *MockPipeliner_TDigestMerge_Call {
	return &MockPipeliner_TDigestMerge_Call{Call: _e.mock.On("TDigestMerge",
		append([]interface{}{ctx, destKey, options}, sourceKeys...)...)}
}

func (_c *MockPipeliner_TDigestMerge_Call) Run(run func(ctx context.Context, destKey string, options *TDigestMergeOptions, sourceKeys ...string)) *MockPipeliner_TDigestMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(*TDigestMergeOptions), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestMerge_Call) Return(_a0 *StatusCmd) *MockPipeliner_TDigestMerge_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestMerge_Call) RunAndReturn(run func(context.Context, string, *TDigestMergeOptions, ...string) *StatusCmd) *MockPipeliner_TDigestMerge_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestMin provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TDigestMin(ctx context.Context, key string) *FloatCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestMin")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *FloatCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestMin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestMin'
type MockPipeliner_TDigestMin_Call struct {
	*mock.Call
}

// TDigestMin is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TDigestMin(ctx interface{}, key interface{}) *MockPipeliner_TDigestMin_Call {
	return &MockPipeliner_TDigestMin_Call{Call: _e.mock.On("TDigestMin", ctx, key)}
}

func (_c *MockPipeliner_TDigestMin_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TDigestMin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TDigestMin_Call) Return(_a0 *FloatCmd) *MockPipeliner_TDigestMin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestMin_Call) RunAndReturn(run func(context.Context, string) *FloatCmd) *MockPipeliner_TDigestMin_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestQuantile provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TDigestQuantile(ctx context.Context, key string, elements ...float64) *FloatSliceCmd {
	_va := make([]interface{}, len(elements))
	for _i := range elements {
		_va[_i] = elements[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestQuantile")
	}

	var r0 *FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *FloatSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestQuantile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestQuantile'
type MockPipeliner_TDigestQuantile_Call struct {
	*mock.Call
}

// TDigestQuantile is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...float64
func (_e *MockPipeliner_Expecter) TDigestQuantile(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TDigestQuantile_Call {
	return &MockPipeliner_TDigestQuantile_Call{Call: _e.mock.On("TDigestQuantile",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TDigestQuantile_Call) Run(run func(ctx context.Context, key string, elements ...float64)) *MockPipeliner_TDigestQuantile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]float64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(float64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestQuantile_Call) Return(_a0 *FloatSliceCmd) *MockPipeliner_TDigestQuantile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestQuantile_Call) RunAndReturn(run func(context.Context, string, ...float64) *FloatSliceCmd) *MockPipeliner_TDigestQuantile_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestRank provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) TDigestRank(ctx context.Context, key string, values ...float64) *IntSliceCmd {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestRank")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestRank'
type MockPipeliner_TDigestRank_Call struct {
	*mock.Call
}

// TDigestRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...float64
func (_e *MockPipeliner_Expecter) TDigestRank(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_TDigestRank_Call {
	return &MockPipeliner_TDigestRank_Call{Call: _e.mock.On("TDigestRank",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_TDigestRank_Call) Run(run func(ctx context.Context, key string, values ...float64)) *MockPipeliner_TDigestRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]float64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(float64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestRank_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_TDigestRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestRank_Call) RunAndReturn(run func(context.Context, string, ...float64) *IntSliceCmd) *MockPipeliner_TDigestRank_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestReset provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TDigestReset(ctx context.Context, key string) *StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TDigestReset")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestReset'
type MockPipeliner_TDigestReset_Call struct {
	*mock.Call
}

// TDigestReset is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TDigestReset(ctx interface{}, key interface{}) *MockPipeliner_TDigestReset_Call {
	return &MockPipeliner_TDigestReset_Call{Call: _e.mock.On("TDigestReset", ctx, key)}
}

func (_c *MockPipeliner_TDigestReset_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TDigestReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TDigestReset_Call) Return(_a0 *StatusCmd) *MockPipeliner_TDigestReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestReset_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_TDigestReset_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestRevRank provides a mock function with given fields: ctx, key, values
func (_m *MockPipeliner) TDigestRevRank(ctx context.Context, key string, values ...float64) *IntSliceCmd {
	_va := make([]interface{}, len(values))
	for _i := range values {
		_va[_i] = values[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TDigestRevRank")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...float64) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestRevRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestRevRank'
type MockPipeliner_TDigestRevRank_Call struct {
	*mock.Call
}

// TDigestRevRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...float64
func (_e *MockPipeliner_Expecter) TDigestRevRank(ctx interface{}, key interface{}, values ...interface{}) *MockPipeliner_TDigestRevRank_Call {
	return &MockPipeliner_TDigestRevRank_Call{Call: _e.mock.On("TDigestRevRank",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockPipeliner_TDigestRevRank_Call) Run(run func(ctx context.Context, key string, values ...float64)) *MockPipeliner_TDigestRevRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]float64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(float64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TDigestRevRank_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_TDigestRevRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestRevRank_Call) RunAndReturn(run func(context.Context, string, ...float64) *IntSliceCmd) *MockPipeliner_TDigestRevRank_Call {
	_c.Call.Return(run)
	return _c
}

// TDigestTrimmedMean provides a mock function with given fields: ctx, key, lowCutQuantile, highCutQuantile
func (_m *MockPipeliner) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *FloatCmd {
	ret := _m.Called(ctx, key, lowCutQuantile, highCutQuantile)

	if len(ret) == 0 {
		panic("no return value specified for TDigestTrimmedMean")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64) *FloatCmd); ok {
		r0 = rf(ctx, key, lowCutQuantile, highCutQuantile)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_TDigestTrimmedMean_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TDigestTrimmedMean'
type MockPipeliner_TDigestTrimmedMean_Call struct {
	*mock.Call
}

// TDigestTrimmedMean is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - lowCutQuantile float64
//   - highCutQuantile float64
func (_e *MockPipeliner_Expecter) TDigestTrimmedMean(ctx interface{}, key interface{}, lowCutQuantile interface{}, highCutQuantile interface{}) *MockPipeliner_TDigestTrimmedMean_Call {
	return &MockPipeliner_TDigestTrimmedMean_Call{Call: _e.mock.On("TDigestTrimmedMean", ctx, key, lowCutQuantile, highCutQuantile)}
}

func (_c *MockPipeliner_TDigestTrimmedMean_Call) Run(run func(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64)) *MockPipeliner_TDigestTrimmedMean_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64))
	})
	return _c
}

func (_c *MockPipeliner_TDigestTrimmedMean_Call) Return(_a0 *FloatCmd) *MockPipeliner_TDigestTrimmedMean_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TDigestTrimmedMean_Call) RunAndReturn(run func(context.Context, string, float64, float64) *FloatCmd) *MockPipeliner_TDigestTrimmedMean_Call {
	_c.Call.Return(run)
	return _c
}

// TFCall provides a mock function with given fields: ctx, libName, funcName, numKeys
func (_m *MockPipeliner) TFCall(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys)

	if len(ret) == 0 {
		panic("no return value specified for TFCall")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_TFCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCall'
type MockPipeliner_TFCall_Call struct {
	*mock.Call
}

// TFCall is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
func (_e *MockPipeliner_Expecter) TFCall(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}) *MockPipeliner_TFCall_Call {
	return &MockPipeliner_TFCall_Call{Call: _e.mock.On("TFCall", ctx, libName, funcName, numKeys)}
}

func (_c *MockPipeliner_TFCall_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int)) *MockPipeliner_TFCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_TFCall_Call) Return(_a0 *Cmd) *MockPipeliner_TFCall_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFCall_Call) RunAndReturn(run func(context.Context, string, string, int) *Cmd) *MockPipeliner_TFCall_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallASYNC provides a mock function with given fields: ctx, libName, funcName, numKeys
func (_m *MockPipeliner) TFCallASYNC(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys)

	if len(ret) == 0 {
		panic("no return value specified for TFCallASYNC")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_TFCallASYNC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallASYNC'
type MockPipeliner_TFCallASYNC_Call struct {
	*mock.Call
}

// TFCallASYNC is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
func (_e *MockPipeliner_Expecter) TFCallASYNC(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}) *MockPipeliner_TFCallASYNC_Call {
	return &MockPipeliner_TFCallASYNC_Call{Call: _e.mock.On("TFCallASYNC", ctx, libName, funcName, numKeys)}
}

func (_c *MockPipeliner_TFCallASYNC_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int)) *MockPipeliner_TFCallASYNC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_TFCallASYNC_Call) Return(_a0 *Cmd) *MockPipeliner_TFCallASYNC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFCallASYNC_Call) RunAndReturn(run func(context.Context, string, string, int) *Cmd) *MockPipeliner_TFCallASYNC_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallASYNCArgs provides a mock function with given fields: ctx, libName, funcName, numKeys, options
func (_m *MockPipeliner) TFCallASYNCArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys, options)

	if len(ret) == 0 {
		panic("no return value specified for TFCallASYNCArgs")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, *TFCallOptions) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_TFCallASYNCArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallASYNCArgs'
type MockPipeliner_TFCallASYNCArgs_Call struct {
	*mock.Call
}

// TFCallASYNCArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
//   - options *TFCallOptions
func (_e *MockPipeliner_Expecter) TFCallASYNCArgs(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}, options interface{}) *MockPipeliner_TFCallASYNCArgs_Call {
	return &MockPipeliner_TFCallASYNCArgs_Call{Call: _e.mock.On("TFCallASYNCArgs", ctx, libName, funcName, numKeys, options)}
}

func (_c *MockPipeliner_TFCallASYNCArgs_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions)) *MockPipeliner_TFCallASYNCArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(*TFCallOptions))
	})
	return _c
}

func (_c *MockPipeliner_TFCallASYNCArgs_Call) Return(_a0 *Cmd) *MockPipeliner_TFCallASYNCArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFCallASYNCArgs_Call) RunAndReturn(run func(context.Context, string, string, int, *TFCallOptions) *Cmd) *MockPipeliner_TFCallASYNCArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallArgs provides a mock function with given fields: ctx, libName, funcName, numKeys, options
func (_m *MockPipeliner) TFCallArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys, options)

	if len(ret) == 0 {
		panic("no return value specified for TFCallArgs")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, *TFCallOptions) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockPipeliner_TFCallArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallArgs'
type MockPipeliner_TFCallArgs_Call struct {
	*mock.Call
}

// TFCallArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
//   - options *TFCallOptions
func (_e *MockPipeliner_Expecter) TFCallArgs(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}, options interface{}) *MockPipeliner_TFCallArgs_Call {
	return &MockPipeliner_TFCallArgs_Call{Call: _e.mock.On("TFCallArgs", ctx, libName, funcName, numKeys, options)}
}

func (_c *MockPipeliner_TFCallArgs_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions)) *MockPipeliner_TFCallArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(*TFCallOptions))
	})
	return _c
}

func (_c *MockPipeliner_TFCallArgs_Call) Return(_a0 *Cmd) *MockPipeliner_TFCallArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFCallArgs_Call) RunAndReturn(run func(context.Context, string, string, int, *TFCallOptions) *Cmd) *MockPipeliner_TFCallArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionDelete provides a mock function with given fields: ctx, libName
func (_m *MockPipeliner) TFunctionDelete(ctx context.Context, libName string) *StatusCmd {
	ret := _m.Called(ctx, libName)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionDelete")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, libName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TFunctionDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionDelete'
type MockPipeliner_TFunctionDelete_Call struct {
	*mock.Call
}

// TFunctionDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
func (_e *MockPipeliner_Expecter) TFunctionDelete(ctx interface{}, libName interface{}) *MockPipeliner_TFunctionDelete_Call {
	return &MockPipeliner_TFunctionDelete_Call{Call: _e.mock.On("TFunctionDelete", ctx, libName)}
}

func (_c *MockPipeliner_TFunctionDelete_Call) Run(run func(ctx context.Context, libName string)) *MockPipeliner_TFunctionDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TFunctionDelete_Call) Return(_a0 *StatusCmd) *MockPipeliner_TFunctionDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFunctionDelete_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_TFunctionDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionList provides a mock function with given fields: ctx
func (_m *MockPipeliner) TFunctionList(ctx context.Context) *MapStringInterfaceSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionList")
	}

	var r0 *MapStringInterfaceSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *MapStringInterfaceSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TFunctionList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionList'
type MockPipeliner_TFunctionList_Call struct {
	*mock.Call
}

// TFunctionList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) TFunctionList(ctx interface{}) *MockPipeliner_TFunctionList_Call {
	return &MockPipeliner_TFunctionList_Call{Call: _e.mock.On("TFunctionList", ctx)}
}

func (_c *MockPipeliner_TFunctionList_Call) Run(run func(ctx context.Context)) *MockPipeliner_TFunctionList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_TFunctionList_Call) Return(_a0 *MapStringInterfaceSliceCmd) *MockPipeliner_TFunctionList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFunctionList_Call) RunAndReturn(run func(context.Context) *MapStringInterfaceSliceCmd) *MockPipeliner_TFunctionList_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionListArgs provides a mock function with given fields: ctx, options
func (_m *MockPipeliner) TFunctionListArgs(ctx context.Context, options *TFunctionListOptions) *MapStringInterfaceSliceCmd {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionListArgs")
	}

	var r0 *MapStringInterfaceSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *TFunctionListOptions) *MapStringInterfaceSliceCmd); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TFunctionListArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionListArgs'
type MockPipeliner_TFunctionListArgs_Call struct {
	*mock.Call
}

// TFunctionListArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - options *TFunctionListOptions
func (_e *MockPipeliner_Expecter) TFunctionListArgs(ctx interface{}, options interface{}) *MockPipeliner_TFunctionListArgs_Call {
	return &MockPipeliner_TFunctionListArgs_Call{Call: _e.mock.On("TFunctionListArgs", ctx, options)}
}

func (_c *MockPipeliner_TFunctionListArgs_Call) Run(run func(ctx context.Context, options *TFunctionListOptions)) *MockPipeliner_TFunctionListArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*TFunctionListOptions))
	})
	return _c
}

func (_c *MockPipeliner_TFunctionListArgs_Call) Return(_a0 *MapStringInterfaceSliceCmd) *MockPipeliner_TFunctionListArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFunctionListArgs_Call) RunAndReturn(run func(context.Context, *TFunctionListOptions) *MapStringInterfaceSliceCmd) *MockPipeliner_TFunctionListArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionLoad provides a mock function with given fields: ctx, lib
func (_m *MockPipeliner) TFunctionLoad(ctx context.Context, lib string) *StatusCmd {
	ret := _m.Called(ctx, lib)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionLoad")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, lib)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TFunctionLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionLoad'
type MockPipeliner_TFunctionLoad_Call struct {
	*mock.Call
}

// TFunctionLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - lib string
func (_e *MockPipeliner_Expecter) TFunctionLoad(ctx interface{}, lib interface{}) *MockPipeliner_TFunctionLoad_Call {
	return &MockPipeliner_TFunctionLoad_Call{Call: _e.mock.On("TFunctionLoad", ctx, lib)}
}

func (_c *MockPipeliner_TFunctionLoad_Call) Run(run func(ctx context.Context, lib string)) *MockPipeliner_TFunctionLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TFunctionLoad_Call) Return(_a0 *StatusCmd) *MockPipeliner_TFunctionLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFunctionLoad_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_TFunctionLoad_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionLoadArgs provides a mock function with given fields: ctx, lib, options
func (_m *MockPipeliner) TFunctionLoadArgs(ctx context.Context, lib string, options *TFunctionLoadOptions) *StatusCmd {
	ret := _m.Called(ctx, lib, options)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionLoadArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TFunctionLoadOptions) *StatusCmd); ok {
		r0 = rf(ctx, lib, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TFunctionLoadArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionLoadArgs'
type MockPipeliner_TFunctionLoadArgs_Call struct {
	*mock.Call
}

// TFunctionLoadArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - lib string
//   - options *TFunctionLoadOptions
func (_e *MockPipeliner_Expecter) TFunctionLoadArgs(ctx interface{}, lib interface{}, options interface{}) *MockPipeliner_TFunctionLoadArgs_Call {
	return &MockPipeliner_TFunctionLoadArgs_Call{Call: _e.mock.On("TFunctionLoadArgs", ctx, lib, options)}
}

func (_c *MockPipeliner_TFunctionLoadArgs_Call) Run(run func(ctx context.Context, lib string, options *TFunctionLoadOptions)) *MockPipeliner_TFunctionLoadArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TFunctionLoadOptions))
	})
	return _c
}

func (_c *MockPipeliner_TFunctionLoadArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_TFunctionLoadArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TFunctionLoadArgs_Call) RunAndReturn(run func(context.Context, string, *TFunctionLoadOptions) *StatusCmd) *MockPipeliner_TFunctionLoadArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSAdd provides a mock function with given fields: ctx, key, timestamp, value
func (_m *MockPipeliner) TSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *IntCmd {
	ret := _m.Called(ctx, key, timestamp, value)

	if len(ret) == 0 {
		panic("no return value specified for TSAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, float64) *IntCmd); ok {
		r0 = rf(ctx, key, timestamp, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSAdd'
type MockPipeliner_TSAdd_Call struct {
	*mock.Call
}

// TSAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - timestamp interface{}
//   - value float64
func (_e *MockPipeliner_Expecter) TSAdd(ctx interface{}, key interface{}, timestamp interface{}, value interface{}) *MockPipeliner_TSAdd_Call {
	return &MockPipeliner_TSAdd_Call{Call: _e.mock.On("TSAdd", ctx, key, timestamp, value)}
}

func (_c *MockPipeliner_TSAdd_Call) Run(run func(ctx context.Context, key string, timestamp interface{}, value float64)) *MockPipeliner_TSAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(float64))
	})
	return _c
}

func (_c *MockPipeliner_TSAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_TSAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSAdd_Call) RunAndReturn(run func(context.Context, string, interface{}, float64) *IntCmd) *MockPipeliner_TSAdd_Call {
	_c.Call.Return(run)
	return _c
}

// TSAddWithArgs provides a mock function with given fields: ctx, key, timestamp, value, options
func (_m *MockPipeliner) TSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *TSOptions) *IntCmd {
	ret := _m.Called(ctx, key, timestamp, value, options)

	if len(ret) == 0 {
		panic("no return value specified for TSAddWithArgs")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, float64, *TSOptions) *IntCmd); ok {
		r0 = rf(ctx, key, timestamp, value, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSAddWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSAddWithArgs'
type MockPipeliner_TSAddWithArgs_Call struct {
	*mock.Call
}

// TSAddWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - timestamp interface{}
//   - value float64
//   - options *TSOptions
func (_e *MockPipeliner_Expecter) TSAddWithArgs(ctx interface{}, key interface{}, timestamp interface{}, value interface{}, options interface{}) *MockPipeliner_TSAddWithArgs_Call {
	return &MockPipeliner_TSAddWithArgs_Call{Call: _e.mock.On("TSAddWithArgs", ctx, key, timestamp, value, options)}
}

func (_c *MockPipeliner_TSAddWithArgs_Call) Run(run func(ctx context.Context, key string, timestamp interface{}, value float64, options *TSOptions)) *MockPipeliner_TSAddWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(float64), args[4].(*TSOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSAddWithArgs_Call) Return(_a0 *IntCmd) *MockPipeliner_TSAddWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSAddWithArgs_Call) RunAndReturn(run func(context.Context, string, interface{}, float64, *TSOptions) *IntCmd) *MockPipeliner_TSAddWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSAlter provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) TSAlter(ctx context.Context, key string, options *TSAlterOptions) *StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSAlter")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TSAlterOptions) *StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSAlter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSAlter'
type MockPipeliner_TSAlter_Call struct {
	*mock.Call
}

// TSAlter is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *TSAlterOptions
func (_e *MockPipeliner_Expecter) TSAlter(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_TSAlter_Call {
	return &MockPipeliner_TSAlter_Call{Call: _e.mock.On("TSAlter", ctx, key, options)}
}

func (_c *MockPipeliner_TSAlter_Call) Run(run func(ctx context.Context, key string, options *TSAlterOptions)) *MockPipeliner_TSAlter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TSAlterOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSAlter_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSAlter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSAlter_Call) RunAndReturn(run func(context.Context, string, *TSAlterOptions) *StatusCmd) *MockPipeliner_TSAlter_Call {
	_c.Call.Return(run)
	return _c
}

// TSCreate provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TSCreate(ctx context.Context, key string) *StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSCreate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSCreate'
type MockPipeliner_TSCreate_Call struct {
	*mock.Call
}

// TSCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TSCreate(ctx interface{}, key interface{}) *MockPipeliner_TSCreate_Call {
	return &MockPipeliner_TSCreate_Call{Call: _e.mock.On("TSCreate", ctx, key)}
}

func (_c *MockPipeliner_TSCreate_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TSCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TSCreate_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSCreate_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_TSCreate_Call {
	_c.Call.Return(run)
	return _c
}

// TSCreateRule provides a mock function with given fields: ctx, sourceKey, destKey, aggregator, bucketDuration
func (_m *MockPipeliner) TSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int) *StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey, aggregator, bucketDuration)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateRule")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, Aggregator, int) *StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, aggregator, bucketDuration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSCreateRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSCreateRule'
type MockPipeliner_TSCreateRule_Call struct {
	*mock.Call
}

// TSCreateRule is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
//   - aggregator Aggregator
//   - bucketDuration int
func (_e *MockPipeliner_Expecter) TSCreateRule(ctx interface{}, sourceKey interface{}, destKey interface{}, aggregator interface{}, bucketDuration interface{}) *MockPipeliner_TSCreateRule_Call {
	return &MockPipeliner_TSCreateRule_Call{Call: _e.mock.On("TSCreateRule", ctx, sourceKey, destKey, aggregator, bucketDuration)}
}

func (_c *MockPipeliner_TSCreateRule_Call) Run(run func(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int)) *MockPipeliner_TSCreateRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(Aggregator), args[4].(int))
	})
	return _c
}

func (_c *MockPipeliner_TSCreateRule_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSCreateRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSCreateRule_Call) RunAndReturn(run func(context.Context, string, string, Aggregator, int) *StatusCmd) *MockPipeliner_TSCreateRule_Call {
	_c.Call.Return(run)
	return _c
}

// TSCreateRuleWithArgs provides a mock function with given fields: ctx, sourceKey, destKey, aggregator, bucketDuration, options
func (_m *MockPipeliner) TSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int, options *TSCreateRuleOptions) *StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey, aggregator, bucketDuration, options)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateRuleWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, Aggregator, int, *TSCreateRuleOptions) *StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, aggregator, bucketDuration, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSCreateRuleWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSCreateRuleWithArgs'
type MockPipeliner_TSCreateRuleWithArgs_Call struct {
	*mock.Call
}

// TSCreateRuleWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
//   - aggregator Aggregator
//   - bucketDuration int
//   - options *TSCreateRuleOptions
func (_e *MockPipeliner_Expecter) TSCreateRuleWithArgs(ctx interface{}, sourceKey interface{}, destKey interface{}, aggregator interface{}, bucketDuration interface{}, options interface{}) *MockPipeliner_TSCreateRuleWithArgs_Call {
	return &MockPipeliner_TSCreateRuleWithArgs_Call{Call: _e.mock.On("TSCreateRuleWithArgs", ctx, sourceKey, destKey, aggregator, bucketDuration, options)}
}

func (_c *MockPipeliner_TSCreateRuleWithArgs_Call) Run(run func(ctx context.Context, sourceKey string, destKey string, aggregator Aggregator, bucketDuration int, options *TSCreateRuleOptions)) *MockPipeliner_TSCreateRuleWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(Aggregator), args[4].(int), args[5].(*TSCreateRuleOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSCreateRuleWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSCreateRuleWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSCreateRuleWithArgs_Call) RunAndReturn(run func(context.Context, string, string, Aggregator, int, *TSCreateRuleOptions) *StatusCmd) *MockPipeliner_TSCreateRuleWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSCreateWithArgs provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) TSCreateWithArgs(ctx context.Context, key string, options *TSOptions) *StatusCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSCreateWithArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TSOptions) *StatusCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSCreateWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSCreateWithArgs'
type MockPipeliner_TSCreateWithArgs_Call struct {
	*mock.Call
}

// TSCreateWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *TSOptions
func (_e *MockPipeliner_Expecter) TSCreateWithArgs(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_TSCreateWithArgs_Call {
	return &MockPipeliner_TSCreateWithArgs_Call{Call: _e.mock.On("TSCreateWithArgs", ctx, key, options)}
}

func (_c *MockPipeliner_TSCreateWithArgs_Call) Run(run func(ctx context.Context, key string, options *TSOptions)) *MockPipeliner_TSCreateWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TSOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSCreateWithArgs_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSCreateWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSCreateWithArgs_Call) RunAndReturn(run func(context.Context, string, *TSOptions) *StatusCmd) *MockPipeliner_TSCreateWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSDecrBy provides a mock function with given fields: ctx, Key, timestamp
func (_m *MockPipeliner) TSDecrBy(ctx context.Context, Key string, timestamp float64) *IntCmd {
	ret := _m.Called(ctx, Key, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSDecrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *IntCmd); ok {
		r0 = rf(ctx, Key, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSDecrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSDecrBy'
type MockPipeliner_TSDecrBy_Call struct {
	*mock.Call
}

// TSDecrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - Key string
//   - timestamp float64
func (_e *MockPipeliner_Expecter) TSDecrBy(ctx interface{}, Key interface{}, timestamp interface{}) *MockPipeliner_TSDecrBy_Call {
	return &MockPipeliner_TSDecrBy_Call{Call: _e.mock.On("TSDecrBy", ctx, Key, timestamp)}
}

func (_c *MockPipeliner_TSDecrBy_Call) Run(run func(ctx context.Context, Key string, timestamp float64)) *MockPipeliner_TSDecrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockPipeliner_TSDecrBy_Call) Return(_a0 *IntCmd) *MockPipeliner_TSDecrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSDecrBy_Call) RunAndReturn(run func(context.Context, string, float64) *IntCmd) *MockPipeliner_TSDecrBy_Call {
	_c.Call.Return(run)
	return _c
}

// TSDecrByWithArgs provides a mock function with given fields: ctx, key, timestamp, options
func (_m *MockPipeliner) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd {
	ret := _m.Called(ctx, key, timestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSDecrByWithArgs")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, *TSIncrDecrOptions) *IntCmd); ok {
		r0 = rf(ctx, key, timestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSDecrByWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSDecrByWithArgs'
type MockPipeliner_TSDecrByWithArgs_Call struct {
	*mock.Call
}

// TSDecrByWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - timestamp float64
//   - options *TSIncrDecrOptions
func (_e *MockPipeliner_Expecter) TSDecrByWithArgs(ctx interface{}, key interface{}, timestamp interface{}, options interface{}) *MockPipeliner_TSDecrByWithArgs_Call {
	return &MockPipeliner_TSDecrByWithArgs_Call{Call: _e.mock.On("TSDecrByWithArgs", ctx, key, timestamp, options)}
}

func (_c *MockPipeliner_TSDecrByWithArgs_Call) Run(run func(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions)) *MockPipeliner_TSDecrByWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(*TSIncrDecrOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSDecrByWithArgs_Call) Return(_a0 *IntCmd) *MockPipeliner_TSDecrByWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSDecrByWithArgs_Call) RunAndReturn(run func(context.Context, string, float64, *TSIncrDecrOptions) *IntCmd) *MockPipeliner_TSDecrByWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSDel provides a mock function with given fields: ctx, Key, fromTimestamp, toTimestamp
func (_m *MockPipeliner) TSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *IntCmd {
	ret := _m.Called(ctx, Key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *IntCmd); ok {
		r0 = rf(ctx, Key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSDel'
type MockPipeliner_TSDel_Call struct {
	*mock.Call
}

// TSDel is a helper method to define mock.On call
//   - ctx context.Context
//   - Key string
//   - fromTimestamp int
//   - toTimestamp int
func (_e *MockPipeliner_Expecter) TSDel(ctx interface{}, Key interface{}, fromTimestamp interface{}, toTimestamp interface{}) *MockPipeliner_TSDel_Call {
	return &MockPipeliner_TSDel_Call{Call: _e.mock.On("TSDel", ctx, Key, fromTimestamp, toTimestamp)}
}

func (_c *MockPipeliner_TSDel_Call) Run(run func(ctx context.Context, Key string, fromTimestamp int, toTimestamp int)) *MockPipeliner_TSDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_TSDel_Call) Return(_a0 *IntCmd) *MockPipeliner_TSDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSDel_Call) RunAndReturn(run func(context.Context, string, int, int) *IntCmd) *MockPipeliner_TSDel_Call {
	_c.Call.Return(run)
	return _c
}

// TSDeleteRule provides a mock function with given fields: ctx, sourceKey, destKey
func (_m *MockPipeliner) TSDeleteRule(ctx context.Context, sourceKey string, destKey string) *StatusCmd {
	ret := _m.Called(ctx, sourceKey, destKey)

	if len(ret) == 0 {
		panic("no return value specified for TSDeleteRule")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, sourceKey, destKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TSDeleteRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSDeleteRule'
type MockPipeliner_TSDeleteRule_Call struct {
	*mock.Call
}

// TSDeleteRule is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
func (_e *MockPipeliner_Expecter) TSDeleteRule(ctx interface{}, sourceKey interface{}, destKey interface{}) *MockPipeliner_TSDeleteRule_Call {
	return &MockPipeliner_TSDeleteRule_Call{Call: _e.mock.On("TSDeleteRule", ctx, sourceKey, destKey)}
}

func (_c *MockPipeliner_TSDeleteRule_Call) Run(run func(ctx context.Context, sourceKey string, destKey string)) *MockPipeliner_TSDeleteRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_TSDeleteRule_Call) Return(_a0 *StatusCmd) *MockPipeliner_TSDeleteRule_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSDeleteRule_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockPipeliner_TSDeleteRule_Call {
	_c.Call.Return(run)
	return _c
}

// TSGet provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TSGet(ctx context.Context, key string) *TSTimestampValueCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSGet")
	}

	var r0 *TSTimestampValueCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *TSTimestampValueCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueCmd)
		}
	}

	return r0
}

// MockPipeliner_TSGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSGet'
type MockPipeliner_TSGet_Call struct {
	*mock.Call
}

// TSGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TSGet(ctx interface{}, key interface{}) *MockPipeliner_TSGet_Call {
	return &MockPipeliner_TSGet_Call{Call: _e.mock.On("TSGet", ctx, key)}
}

func (_c *MockPipeliner_TSGet_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TSGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TSGet_Call) Return(_a0 *TSTimestampValueCmd) *MockPipeliner_TSGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSGet_Call) RunAndReturn(run func(context.Context, string) *TSTimestampValueCmd) *MockPipeliner_TSGet_Call {
	_c.Call.Return(run)
	return _c
}

// TSGetWithArgs provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) TSGetWithArgs(ctx context.Context, key string, options *TSGetOptions) *TSTimestampValueCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSGetWithArgs")
	}

	var r0 *TSTimestampValueCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TSGetOptions) *TSTimestampValueCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueCmd)
		}
	}

	return r0
}

// MockPipeliner_TSGetWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSGetWithArgs'
type MockPipeliner_TSGetWithArgs_Call struct {
	*mock.Call
}

// TSGetWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *TSGetOptions
func (_e *MockPipeliner_Expecter) TSGetWithArgs(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_TSGetWithArgs_Call {
	return &MockPipeliner_TSGetWithArgs_Call{Call: _e.mock.On("TSGetWithArgs", ctx, key, options)}
}

func (_c *MockPipeliner_TSGetWithArgs_Call) Run(run func(ctx context.Context, key string, options *TSGetOptions)) *MockPipeliner_TSGetWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TSGetOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSGetWithArgs_Call) Return(_a0 *TSTimestampValueCmd) *MockPipeliner_TSGetWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSGetWithArgs_Call) RunAndReturn(run func(context.Context, string, *TSGetOptions) *TSTimestampValueCmd) *MockPipeliner_TSGetWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSIncrBy provides a mock function with given fields: ctx, Key, timestamp
func (_m *MockPipeliner) TSIncrBy(ctx context.Context, Key string, timestamp float64) *IntCmd {
	ret := _m.Called(ctx, Key, timestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSIncrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *IntCmd); ok {
		r0 = rf(ctx, Key, timestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSIncrBy'
type MockPipeliner_TSIncrBy_Call struct {
	*mock.Call
}

// TSIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - Key string
//   - timestamp float64
func (_e *MockPipeliner_Expecter) TSIncrBy(ctx interface{}, Key interface{}, timestamp interface{}) *MockPipeliner_TSIncrBy_Call {
	return &MockPipeliner_TSIncrBy_Call{Call: _e.mock.On("TSIncrBy", ctx, Key, timestamp)}
}

func (_c *MockPipeliner_TSIncrBy_Call) Run(run func(ctx context.Context, Key string, timestamp float64)) *MockPipeliner_TSIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockPipeliner_TSIncrBy_Call) Return(_a0 *IntCmd) *MockPipeliner_TSIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSIncrBy_Call) RunAndReturn(run func(context.Context, string, float64) *IntCmd) *MockPipeliner_TSIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// TSIncrByWithArgs provides a mock function with given fields: ctx, key, timestamp, options
func (_m *MockPipeliner) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions) *IntCmd {
	ret := _m.Called(ctx, key, timestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSIncrByWithArgs")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, *TSIncrDecrOptions) *IntCmd); ok {
		r0 = rf(ctx, key, timestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_TSIncrByWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSIncrByWithArgs'
type MockPipeliner_TSIncrByWithArgs_Call struct {
	*mock.Call
}

// TSIncrByWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - timestamp float64
//   - options *TSIncrDecrOptions
func (_e *MockPipeliner_Expecter) TSIncrByWithArgs(ctx interface{}, key interface{}, timestamp interface{}, options interface{}) *MockPipeliner_TSIncrByWithArgs_Call {
	return &MockPipeliner_TSIncrByWithArgs_Call{Call: _e.mock.On("TSIncrByWithArgs", ctx, key, timestamp, options)}
}

func (_c *MockPipeliner_TSIncrByWithArgs_Call) Run(run func(ctx context.Context, key string, timestamp float64, options *TSIncrDecrOptions)) *MockPipeliner_TSIncrByWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(*TSIncrDecrOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSIncrByWithArgs_Call) Return(_a0 *IntCmd) *MockPipeliner_TSIncrByWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSIncrByWithArgs_Call) RunAndReturn(run func(context.Context, string, float64, *TSIncrDecrOptions) *IntCmd) *MockPipeliner_TSIncrByWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TSInfo(ctx context.Context, key string) *MapStringInterfaceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TSInfo")
	}

	var r0 *MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapStringInterfaceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSInfo'
type MockPipeliner_TSInfo_Call struct {
	*mock.Call
}

// TSInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TSInfo(ctx interface{}, key interface{}) *MockPipeliner_TSInfo_Call {
	return &MockPipeliner_TSInfo_Call{Call: _e.mock.On("TSInfo", ctx, key)}
}

func (_c *MockPipeliner_TSInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TSInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TSInfo_Call) Return(_a0 *MapStringInterfaceCmd) *MockPipeliner_TSInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSInfo_Call) RunAndReturn(run func(context.Context, string) *MapStringInterfaceCmd) *MockPipeliner_TSInfo_Call {
	_c.Call.Return(run)
	return _c
}

// TSInfoWithArgs provides a mock function with given fields: ctx, key, options
func (_m *MockPipeliner) TSInfoWithArgs(ctx context.Context, key string, options *TSInfoOptions) *MapStringInterfaceCmd {
	ret := _m.Called(ctx, key, options)

	if len(ret) == 0 {
		panic("no return value specified for TSInfoWithArgs")
	}

	var r0 *MapStringInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TSInfoOptions) *MapStringInterfaceCmd); ok {
		r0 = rf(ctx, key, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSInfoWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSInfoWithArgs'
type MockPipeliner_TSInfoWithArgs_Call struct {
	*mock.Call
}

// TSInfoWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - options *TSInfoOptions
func (_e *MockPipeliner_Expecter) TSInfoWithArgs(ctx interface{}, key interface{}, options interface{}) *MockPipeliner_TSInfoWithArgs_Call {
	return &MockPipeliner_TSInfoWithArgs_Call{Call: _e.mock.On("TSInfoWithArgs", ctx, key, options)}
}

func (_c *MockPipeliner_TSInfoWithArgs_Call) Run(run func(ctx context.Context, key string, options *TSInfoOptions)) *MockPipeliner_TSInfoWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TSInfoOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSInfoWithArgs_Call) Return(_a0 *MapStringInterfaceCmd) *MockPipeliner_TSInfoWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSInfoWithArgs_Call) RunAndReturn(run func(context.Context, string, *TSInfoOptions) *MapStringInterfaceCmd) *MockPipeliner_TSInfoWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSMAdd provides a mock function with given fields: ctx, ktvSlices
func (_m *MockPipeliner) TSMAdd(ctx context.Context, ktvSlices [][]interface{}) *IntSliceCmd {
	ret := _m.Called(ctx, ktvSlices)

	if len(ret) == 0 {
		panic("no return value specified for TSMAdd")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, [][]interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, ktvSlices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMAdd'
type MockPipeliner_TSMAdd_Call struct {
	*mock.Call
}

// TSMAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - ktvSlices [][]interface{}
func (_e *MockPipeliner_Expecter) TSMAdd(ctx interface{}, ktvSlices interface{}) *MockPipeliner_TSMAdd_Call {
	return &MockPipeliner_TSMAdd_Call{Call: _e.mock.On("TSMAdd", ctx, ktvSlices)}
}

func (_c *MockPipeliner_TSMAdd_Call) Run(run func(ctx context.Context, ktvSlices [][]interface{})) *MockPipeliner_TSMAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([][]interface{}))
	})
	return _c
}

func (_c *MockPipeliner_TSMAdd_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_TSMAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMAdd_Call) RunAndReturn(run func(context.Context, [][]interface{}) *IntSliceCmd) *MockPipeliner_TSMAdd_Call {
	_c.Call.Return(run)
	return _c
}

// TSMGet provides a mock function with given fields: ctx, filters
func (_m *MockPipeliner) TSMGet(ctx context.Context, filters []string) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, filters)

	if len(ret) == 0 {
		panic("no return value specified for TSMGet")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, filters)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMGet'
type MockPipeliner_TSMGet_Call struct {
	*mock.Call
}

// TSMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - filters []string
func (_e *MockPipeliner_Expecter) TSMGet(ctx interface{}, filters interface{}) *MockPipeliner_TSMGet_Call {
	return &MockPipeliner_TSMGet_Call{Call: _e.mock.On("TSMGet", ctx, filters)}
}

func (_c *MockPipeliner_TSMGet_Call) Run(run func(ctx context.Context, filters []string)) *MockPipeliner_TSMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockPipeliner_TSMGet_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMGet_Call) RunAndReturn(run func(context.Context, []string) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMGet_Call {
	_c.Call.Return(run)
	return _c
}

// TSMGetWithArgs provides a mock function with given fields: ctx, filters, options
func (_m *MockPipeliner) TSMGetWithArgs(ctx context.Context, filters []string, options *TSMGetOptions) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, filters, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMGetWithArgs")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string, *TSMGetOptions) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, filters, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMGetWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMGetWithArgs'
type MockPipeliner_TSMGetWithArgs_Call struct {
	*mock.Call
}

// TSMGetWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - filters []string
//   - options *TSMGetOptions
func (_e *MockPipeliner_Expecter) TSMGetWithArgs(ctx interface{}, filters interface{}, options interface{}) *MockPipeliner_TSMGetWithArgs_Call {
	return &MockPipeliner_TSMGetWithArgs_Call{Call: _e.mock.On("TSMGetWithArgs", ctx, filters, options)}
}

func (_c *MockPipeliner_TSMGetWithArgs_Call) Run(run func(ctx context.Context, filters []string, options *TSMGetOptions)) *MockPipeliner_TSMGetWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(*TSMGetOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSMGetWithArgs_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMGetWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMGetWithArgs_Call) RunAndReturn(run func(context.Context, []string, *TSMGetOptions) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMGetWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSMRange provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr
func (_m *MockPipeliner) TSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSMRange")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMRange'
type MockPipeliner_TSMRange_Call struct {
	*mock.Call
}

// TSMRange is a helper method to define mock.On call
//   - ctx context.Context
//   - fromTimestamp int
//   - toTimestamp int
//   - filterExpr []string
func (_e *MockPipeliner_Expecter) TSMRange(ctx interface{}, fromTimestamp interface{}, toTimestamp interface{}, filterExpr interface{}) *MockPipeliner_TSMRange_Call {
	return &MockPipeliner_TSMRange_Call{Call: _e.mock.On("TSMRange", ctx, fromTimestamp, toTimestamp, filterExpr)}
}

func (_c *MockPipeliner_TSMRange_Call) Run(run func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string)) *MockPipeliner_TSMRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].([]string))
	})
	return _c
}

func (_c *MockPipeliner_TSMRange_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMRange_Call) RunAndReturn(run func(context.Context, int, int, []string) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRange_Call {
	_c.Call.Return(run)
	return _c
}

// TSMRangeWithArgs provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr, options
func (_m *MockPipeliner) TSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRangeOptions) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMRangeWithArgs")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string, *TSMRangeOptions) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMRangeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMRangeWithArgs'
type MockPipeliner_TSMRangeWithArgs_Call struct {
	*mock.Call
}

// TSMRangeWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - fromTimestamp int
//   - toTimestamp int
//   - filterExpr []string
//   - options *TSMRangeOptions
func (_e *MockPipeliner_Expecter) TSMRangeWithArgs(ctx interface{}, fromTimestamp interface{}, toTimestamp interface{}, filterExpr interface{}, options interface{}) *MockPipeliner_TSMRangeWithArgs_Call {
	return &MockPipeliner_TSMRangeWithArgs_Call{Call: _e.mock.On("TSMRangeWithArgs", ctx, fromTimestamp, toTimestamp, filterExpr, options)}
}

func (_c *MockPipeliner_TSMRangeWithArgs_Call) Run(run func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRangeOptions)) *MockPipeliner_TSMRangeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].([]string), args[4].(*TSMRangeOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSMRangeWithArgs_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRangeWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMRangeWithArgs_Call) RunAndReturn(run func(context.Context, int, int, []string, *TSMRangeOptions) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRangeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSMRevRange provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr
func (_m *MockPipeliner) TSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSMRevRange")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMRevRange'
type MockPipeliner_TSMRevRange_Call struct {
	*mock.Call
}

// TSMRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - fromTimestamp int
//   - toTimestamp int
//   - filterExpr []string
func (_e *MockPipeliner_Expecter) TSMRevRange(ctx interface{}, fromTimestamp interface{}, toTimestamp interface{}, filterExpr interface{}) *MockPipeliner_TSMRevRange_Call {
	return &MockPipeliner_TSMRevRange_Call{Call: _e.mock.On("TSMRevRange", ctx, fromTimestamp, toTimestamp, filterExpr)}
}

func (_c *MockPipeliner_TSMRevRange_Call) Run(run func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string)) *MockPipeliner_TSMRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].([]string))
	})
	return _c
}

func (_c *MockPipeliner_TSMRevRange_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMRevRange_Call) RunAndReturn(run func(context.Context, int, int, []string) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// TSMRevRangeWithArgs provides a mock function with given fields: ctx, fromTimestamp, toTimestamp, filterExpr, options
func (_m *MockPipeliner) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRevRangeOptions) *MapStringSliceInterfaceCmd {
	ret := _m.Called(ctx, fromTimestamp, toTimestamp, filterExpr, options)

	if len(ret) == 0 {
		panic("no return value specified for TSMRevRangeWithArgs")
	}

	var r0 *MapStringSliceInterfaceCmd
	if rf, ok := ret.Get(0).(func(context.Context, int, int, []string, *TSMRevRangeOptions) *MapStringSliceInterfaceCmd); ok {
		r0 = rf(ctx, fromTimestamp, toTimestamp, filterExpr, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringSliceInterfaceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSMRevRangeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSMRevRangeWithArgs'
type MockPipeliner_TSMRevRangeWithArgs_Call struct {
	*mock.Call
}

// TSMRevRangeWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - fromTimestamp int
//   - toTimestamp int
//   - filterExpr []string
//   - options *TSMRevRangeOptions
func (_e *MockPipeliner_Expecter) TSMRevRangeWithArgs(ctx interface{}, fromTimestamp interface{}, toTimestamp interface{}, filterExpr interface{}, options interface{}) *MockPipeliner_TSMRevRangeWithArgs_Call {
	return &MockPipeliner_TSMRevRangeWithArgs_Call{Call: _e.mock.On("TSMRevRangeWithArgs", ctx, fromTimestamp, toTimestamp, filterExpr, options)}
}

func (_c *MockPipeliner_TSMRevRangeWithArgs_Call) Run(run func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *TSMRevRangeOptions)) *MockPipeliner_TSMRevRangeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].([]string), args[4].(*TSMRevRangeOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSMRevRangeWithArgs_Call) Return(_a0 *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRevRangeWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSMRevRangeWithArgs_Call) RunAndReturn(run func(context.Context, int, int, []string, *TSMRevRangeOptions) *MapStringSliceInterfaceCmd) *MockPipeliner_TSMRevRangeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSQueryIndex provides a mock function with given fields: ctx, filterExpr
func (_m *MockPipeliner) TSQueryIndex(ctx context.Context, filterExpr []string) *StringSliceCmd {
	ret := _m.Called(ctx, filterExpr)

	if len(ret) == 0 {
		panic("no return value specified for TSQueryIndex")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, []string) *StringSliceCmd); ok {
		r0 = rf(ctx, filterExpr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSQueryIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSQueryIndex'
type MockPipeliner_TSQueryIndex_Call struct {
	*mock.Call
}

// TSQueryIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - filterExpr []string
func (_e *MockPipeliner_Expecter) TSQueryIndex(ctx interface{}, filterExpr interface{}) *MockPipeliner_TSQueryIndex_Call {
	return &MockPipeliner_TSQueryIndex_Call{Call: _e.mock.On("TSQueryIndex", ctx, filterExpr)}
}

func (_c *MockPipeliner_TSQueryIndex_Call) Run(run func(ctx context.Context, filterExpr []string)) *MockPipeliner_TSQueryIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string))
	})
	return _c
}

func (_c *MockPipeliner_TSQueryIndex_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_TSQueryIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSQueryIndex_Call) RunAndReturn(run func(context.Context, []string) *StringSliceCmd) *MockPipeliner_TSQueryIndex_Call {
	_c.Call.Return(run)
	return _c
}

// TSRange provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp
func (_m *MockPipeliner) TSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSRange")
	}

	var r0 *TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSRange'
type MockPipeliner_TSRange_Call struct {
	*mock.Call
}

// TSRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fromTimestamp int
//   - toTimestamp int
func (_e *MockPipeliner_Expecter) TSRange(ctx interface{}, key interface{}, fromTimestamp interface{}, toTimestamp interface{}) *MockPipeliner_TSRange_Call {
	return &MockPipeliner_TSRange_Call{Call: _e.mock.On("TSRange", ctx, key, fromTimestamp, toTimestamp)}
}

func (_c *MockPipeliner_TSRange_Call) Run(run func(ctx context.Context, key string, fromTimestamp int, toTimestamp int)) *MockPipeliner_TSRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_TSRange_Call) Return(_a0 *TSTimestampValueSliceCmd) *MockPipeliner_TSRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSRange_Call) RunAndReturn(run func(context.Context, string, int, int) *TSTimestampValueSliceCmd) *MockPipeliner_TSRange_Call {
	_c.Call.Return(run)
	return _c
}

// TSRangeWithArgs provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp, options
func (_m *MockPipeliner) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRangeOptions) *TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSRangeWithArgs")
	}

	var r0 *TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, *TSRangeOptions) *TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSRangeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSRangeWithArgs'
type MockPipeliner_TSRangeWithArgs_Call struct {
	*mock.Call
}

// TSRangeWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fromTimestamp int
//   - toTimestamp int
//   - options *TSRangeOptions
func (_e *MockPipeliner_Expecter) TSRangeWithArgs(ctx interface{}, key interface{}, fromTimestamp interface{}, toTimestamp interface{}, options interface{}) *MockPipeliner_TSRangeWithArgs_Call {
	return &MockPipeliner_TSRangeWithArgs_Call{Call: _e.mock.On("TSRangeWithArgs", ctx, key, fromTimestamp, toTimestamp, options)}
}

func (_c *MockPipeliner_TSRangeWithArgs_Call) Run(run func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRangeOptions)) *MockPipeliner_TSRangeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int), args[4].(*TSRangeOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSRangeWithArgs_Call) Return(_a0 *TSTimestampValueSliceCmd) *MockPipeliner_TSRangeWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSRangeWithArgs_Call) RunAndReturn(run func(context.Context, string, int, int, *TSRangeOptions) *TSTimestampValueSliceCmd) *MockPipeliner_TSRangeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TSRevRange provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp
func (_m *MockPipeliner) TSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for TSRevRange")
	}

	var r0 *TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSRevRange'
type MockPipeliner_TSRevRange_Call struct {
	*mock.Call
}

// TSRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fromTimestamp int
//   - toTimestamp int
func (_e *MockPipeliner_Expecter) TSRevRange(ctx interface{}, key interface{}, fromTimestamp interface{}, toTimestamp interface{}) *MockPipeliner_TSRevRange_Call {
	return &MockPipeliner_TSRevRange_Call{Call: _e.mock.On("TSRevRange", ctx, key, fromTimestamp, toTimestamp)}
}

func (_c *MockPipeliner_TSRevRange_Call) Run(run func(ctx context.Context, key string, fromTimestamp int, toTimestamp int)) *MockPipeliner_TSRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockPipeliner_TSRevRange_Call) Return(_a0 *TSTimestampValueSliceCmd) *MockPipeliner_TSRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSRevRange_Call) RunAndReturn(run func(context.Context, string, int, int) *TSTimestampValueSliceCmd) *MockPipeliner_TSRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// TSRevRangeWithArgs provides a mock function with given fields: ctx, key, fromTimestamp, toTimestamp, options
func (_m *MockPipeliner) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRevRangeOptions) *TSTimestampValueSliceCmd {
	ret := _m.Called(ctx, key, fromTimestamp, toTimestamp, options)

	if len(ret) == 0 {
		panic("no return value specified for TSRevRangeWithArgs")
	}

	var r0 *TSTimestampValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, *TSRevRangeOptions) *TSTimestampValueSliceCmd); ok {
		r0 = rf(ctx, key, fromTimestamp, toTimestamp, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TSTimestampValueSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TSRevRangeWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TSRevRangeWithArgs'
type MockPipeliner_TSRevRangeWithArgs_Call struct {
	*mock.Call
}

// TSRevRangeWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fromTimestamp int
//   - toTimestamp int
//   - options *TSRevRangeOptions
func (_e *MockPipeliner_Expecter) TSRevRangeWithArgs(ctx interface{}, key interface{}, fromTimestamp interface{}, toTimestamp interface{}, options interface{}) *MockPipeliner_TSRevRangeWithArgs_Call {
	return &MockPipeliner_TSRevRangeWithArgs_Call{Call: _e.mock.On("TSRevRangeWithArgs", ctx, key, fromTimestamp, toTimestamp, options)}
}

func (_c *MockPipeliner_TSRevRangeWithArgs_Call) Run(run func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *TSRevRangeOptions)) *MockPipeliner_TSRevRangeWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int), args[4].(*TSRevRangeOptions))
	})
	return _c
}

func (_c *MockPipeliner_TSRevRangeWithArgs_Call) Return(_a0 *TSTimestampValueSliceCmd) *MockPipeliner_TSRevRangeWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TSRevRangeWithArgs_Call) RunAndReturn(run func(context.Context, string, int, int, *TSRevRangeOptions) *TSTimestampValueSliceCmd) *MockPipeliner_TSRevRangeWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TTL provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TTL(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockPipeliner_TTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TTL'
type MockPipeliner_TTL_Call struct {
	*mock.Call
}

// TTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TTL(ctx interface{}, key interface{}) *MockPipeliner_TTL_Call {
	return &MockPipeliner_TTL_Call{Call: _e.mock.On("TTL", ctx, key)}
}

func (_c *MockPipeliner_TTL_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TTL_Call) Return(_a0 *DurationCmd) *MockPipeliner_TTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TTL_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockPipeliner_TTL_Call {
	_c.Call.Return(run)
	return _c
}

// Time provides a mock function with given fields: ctx
func (_m *MockPipeliner) Time(ctx context.Context) *TimeCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 *TimeCmd
	if rf, ok := ret.Get(0).(func(context.Context) *TimeCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TimeCmd)
		}
	}

	return r0
}

// MockPipeliner_Time_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Time'
type MockPipeliner_Time_Call struct {
	*mock.Call
}

// Time is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPipeliner_Expecter) Time(ctx interface{}) *MockPipeliner_Time_Call {
	return &MockPipeliner_Time_Call{Call: _e.mock.On("Time", ctx)}
}

func (_c *MockPipeliner_Time_Call) Run(run func(ctx context.Context)) *MockPipeliner_Time_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPipeliner_Time_Call) Return(_a0 *TimeCmd) *MockPipeliner_Time_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Time_Call) RunAndReturn(run func(context.Context) *TimeCmd) *MockPipeliner_Time_Call {
	_c.Call.Return(run)
	return _c
}

// TopKAdd provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TopKAdd(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKAdd")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *StringSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKAdd'
type MockPipeliner_TopKAdd_Call struct {
	*mock.Call
}

// TopKAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) TopKAdd(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TopKAdd_Call {
	return &MockPipeliner_TopKAdd_Call{Call: _e.mock.On("TopKAdd",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TopKAdd_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_TopKAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TopKAdd_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_TopKAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKAdd_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *StringSliceCmd) *MockPipeliner_TopKAdd_Call {
	_c.Call.Return(run)
	return _c
}

// TopKCount provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TopKCount(ctx context.Context, key string, elements ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKCount")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKCount'
type MockPipeliner_TopKCount_Call struct {
	*mock.Call
}

// TopKCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) TopKCount(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TopKCount_Call {
	return &MockPipeliner_TopKCount_Call{Call: _e.mock.On("TopKCount",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TopKCount_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_TopKCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TopKCount_Call) Return(_a0 *IntSliceCmd) *MockPipeliner_TopKCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKCount_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockPipeliner_TopKCount_Call {
	_c.Call.Return(run)
	return _c
}

// TopKIncrBy provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TopKIncrBy(ctx context.Context, key string, elements ...interface{}) *StringSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKIncrBy")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *StringSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKIncrBy'
type MockPipeliner_TopKIncrBy_Call struct {
	*mock.Call
}

// TopKIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) TopKIncrBy(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TopKIncrBy_Call {
	return &MockPipeliner_TopKIncrBy_Call{Call: _e.mock.On("TopKIncrBy",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TopKIncrBy_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_TopKIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TopKIncrBy_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_TopKIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKIncrBy_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *StringSliceCmd) *MockPipeliner_TopKIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// TopKInfo provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TopKInfo(ctx context.Context, key string) *TopKInfoCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKInfo")
	}

	var r0 *TopKInfoCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *TopKInfoCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*TopKInfoCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKInfo'
type MockPipeliner_TopKInfo_Call struct {
	*mock.Call
}

// TopKInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TopKInfo(ctx interface{}, key interface{}) *MockPipeliner_TopKInfo_Call {
	return &MockPipeliner_TopKInfo_Call{Call: _e.mock.On("TopKInfo", ctx, key)}
}

func (_c *MockPipeliner_TopKInfo_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TopKInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TopKInfo_Call) Return(_a0 *TopKInfoCmd) *MockPipeliner_TopKInfo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKInfo_Call) RunAndReturn(run func(context.Context, string) *TopKInfoCmd) *MockPipeliner_TopKInfo_Call {
	_c.Call.Return(run)
	return _c
}

// TopKList provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TopKList(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKList")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKList'
type MockPipeliner_TopKList_Call struct {
	*mock.Call
}

// TopKList is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TopKList(ctx interface{}, key interface{}) *MockPipeliner_TopKList_Call {
	return &MockPipeliner_TopKList_Call{Call: _e.mock.On("TopKList", ctx, key)}
}

func (_c *MockPipeliner_TopKList_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TopKList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TopKList_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_TopKList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKList_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPipeliner_TopKList_Call {
	_c.Call.Return(run)
	return _c
}

// TopKListWithCount provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) TopKListWithCount(ctx context.Context, key string) *MapStringIntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TopKListWithCount")
	}

	var r0 *MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapStringIntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringIntCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKListWithCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKListWithCount'
type MockPipeliner_TopKListWithCount_Call struct {
	*mock.Call
}

// TopKListWithCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) TopKListWithCount(ctx interface{}, key interface{}) *MockPipeliner_TopKListWithCount_Call {
	return &MockPipeliner_TopKListWithCount_Call{Call: _e.mock.On("TopKListWithCount", ctx, key)}
}

func (_c *MockPipeliner_TopKListWithCount_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_TopKListWithCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_TopKListWithCount_Call) Return(_a0 *MapStringIntCmd) *MockPipeliner_TopKListWithCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKListWithCount_Call) RunAndReturn(run func(context.Context, string) *MapStringIntCmd) *MockPipeliner_TopKListWithCount_Call {
	_c.Call.Return(run)
	return _c
}

// TopKQuery provides a mock function with given fields: ctx, key, elements
func (_m *MockPipeliner) TopKQuery(ctx context.Context, key string, elements ...interface{}) *BoolSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, elements...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TopKQuery")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolSliceCmd); ok {
		r0 = rf(ctx, key, elements...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKQuery'
type MockPipeliner_TopKQuery_Call struct {
	*mock.Call
}

// TopKQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - elements ...interface{}
func (_e *MockPipeliner_Expecter) TopKQuery(ctx interface{}, key interface{}, elements ...interface{}) *MockPipeliner_TopKQuery_Call {
	return &MockPipeliner_TopKQuery_Call{Call: _e.mock.On("TopKQuery",
		append([]interface{}{ctx, key}, elements...)...)}
}

func (_c *MockPipeliner_TopKQuery_Call) Run(run func(ctx context.Context, key string, elements ...interface{})) *MockPipeliner_TopKQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_TopKQuery_Call) Return(_a0 *BoolSliceCmd) *MockPipeliner_TopKQuery_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKQuery_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolSliceCmd) *MockPipeliner_TopKQuery_Call {
	_c.Call.Return(run)
	return _c
}

// TopKReserve provides a mock function with given fields: ctx, key, k
func (_m *MockPipeliner) TopKReserve(ctx context.Context, key string, k int64) *StatusCmd {
	ret := _m.Called(ctx, key, k)

	if len(ret) == 0 {
		panic("no return value specified for TopKReserve")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, k)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKReserve_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKReserve'
type MockPipeliner_TopKReserve_Call struct {
	*mock.Call
}

// TopKReserve is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - k int64
func (_e *MockPipeliner_Expecter) TopKReserve(ctx interface{}, key interface{}, k interface{}) *MockPipeliner_TopKReserve_Call {
	return &MockPipeliner_TopKReserve_Call{Call: _e.mock.On("TopKReserve", ctx, key, k)}
}

func (_c *MockPipeliner_TopKReserve_Call) Run(run func(ctx context.Context, key string, k int64)) *MockPipeliner_TopKReserve_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_TopKReserve_Call) Return(_a0 *StatusCmd) *MockPipeliner_TopKReserve_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKReserve_Call) RunAndReturn(run func(context.Context, string, int64) *StatusCmd) *MockPipeliner_TopKReserve_Call {
	_c.Call.Return(run)
	return _c
}

// TopKReserveWithOptions provides a mock function with given fields: ctx, key, k, width, depth, decay
func (_m *MockPipeliner) TopKReserveWithOptions(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *StatusCmd {
	ret := _m.Called(ctx, key, k, width, depth, decay)

	if len(ret) == 0 {
		panic("no return value specified for TopKReserveWithOptions")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64, int64, float64) *StatusCmd); ok {
		r0 = rf(ctx, key, k, width, depth, decay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_TopKReserveWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TopKReserveWithOptions'
type MockPipeliner_TopKReserveWithOptions_Call struct {
	*mock.Call
}

// TopKReserveWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - k int64
//   - width int64
//   - depth int64
//   - decay float64
func (_e *MockPipeliner_Expecter) TopKReserveWithOptions(ctx interface{}, key interface{}, k interface{}, width interface{}, depth interface{}, decay interface{}) *MockPipeliner_TopKReserveWithOptions_Call {
	return &MockPipeliner_TopKReserveWithOptions_Call{Call: _e.mock.On("TopKReserveWithOptions", ctx, key, k, width, depth, decay)}
}

func (_c *MockPipeliner_TopKReserveWithOptions_Call) Run(run func(ctx context.Context, key string, k int64, width int64, depth int64, decay float64)) *MockPipeliner_TopKReserveWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64), args[4].(int64), args[5].(float64))
	})
	return _c
}

func (_c *MockPipeliner_TopKReserveWithOptions_Call) Return(_a0 *StatusCmd) *MockPipeliner_TopKReserveWithOptions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TopKReserveWithOptions_Call) RunAndReturn(run func(context.Context, string, int64, int64, int64, float64) *StatusCmd) *MockPipeliner_TopKReserveWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Touch provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) Touch(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Touch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Touch'
type MockPipeliner_Touch_Call struct {
	*mock.Call
}

// Touch is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) Touch(ctx interface{}, keys ...interface{}) *MockPipeliner_Touch_Call {
	return &MockPipeliner_Touch_Call{Call: _e.mock.On("Touch",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_Touch_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_Touch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Touch_Call) Return(_a0 *IntCmd) *MockPipeliner_Touch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Touch_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_Touch_Call {
	_c.Call.Return(run)
	return _c
}

// TxPipeline provides a mock function with no fields
func (_m *MockPipeliner) TxPipeline() Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxPipeline")
	}

	var r0 Pipeliner
	if rf, ok := ret.Get(0).(func() Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Pipeliner)
		}
	}

	return r0
}

// MockPipeliner_TxPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxPipeline'
type MockPipeliner_TxPipeline_Call struct {
	*mock.Call
}

// TxPipeline is a helper method to define mock.On call
func (_e *MockPipeliner_Expecter) TxPipeline() *MockPipeliner_TxPipeline_Call {
	return &MockPipeliner_TxPipeline_Call{Call: _e.mock.On("TxPipeline")}
}

func (_c *MockPipeliner_TxPipeline_Call) Run(run func()) *MockPipeliner_TxPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockPipeliner_TxPipeline_Call) Return(_a0 Pipeliner) *MockPipeliner_TxPipeline_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_TxPipeline_Call) RunAndReturn(run func() Pipeliner) *MockPipeliner_TxPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// TxPipelined provides a mock function with given fields: ctx, fn
func (_m *MockPipeliner) TxPipelined(ctx context.Context, fn func(Pipeliner) error) ([]Cmder, error) {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for TxPipelined")
	}

	var r0 []Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, func(Pipeliner) error) ([]Cmder, error)); ok {
		return rf(ctx, fn)
	}
	if rf, ok := ret.Get(0).(func(context.Context, func(Pipeliner) error) []Cmder); ok {
		r0 = rf(ctx, fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, func(Pipeliner) error) error); ok {
		r1 = rf(ctx, fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockPipeliner_TxPipelined_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxPipelined'
type MockPipeliner_TxPipelined_Call struct {
	*mock.Call
}

// TxPipelined is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(Pipeliner) error
func (_e *MockPipeliner_Expecter) TxPipelined(ctx interface{}, fn interface{}) *MockPipeliner_TxPipelined_Call {
	return &MockPipeliner_TxPipelined_Call{Call: _e.mock.On("TxPipelined", ctx, fn)}
}

func (_c *MockPipeliner_TxPipelined_Call) Run(run func(ctx context.Context, fn func(Pipeliner) error)) *MockPipeliner_TxPipelined_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(func(Pipeliner) error))
	})
	return _c
}

func (_c *MockPipeliner_TxPipelined_Call) Return(_a0 []Cmder, _a1 error) *MockPipeliner_TxPipelined_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockPipeliner_TxPipelined_Call) RunAndReturn(run func(context.Context, func(Pipeliner) error) ([]Cmder, error)) *MockPipeliner_TxPipelined_Call {
	_c.Call.Return(run)
	return _c
}

// Type provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) Type(ctx context.Context, key string) *StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Type'
type MockPipeliner_Type_Call struct {
	*mock.Call
}

// Type is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) Type(ctx interface{}, key interface{}) *MockPipeliner_Type_Call {
	return &MockPipeliner_Type_Call{Call: _e.mock.On("Type", ctx, key)}
}

func (_c *MockPipeliner_Type_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_Type_Call) Return(_a0 *StatusCmd) *MockPipeliner_Type_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Type_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockPipeliner_Type_Call {
	_c.Call.Return(run)
	return _c
}

// Unlink provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) Unlink(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_Unlink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unlink'
type MockPipeliner_Unlink_Call struct {
	*mock.Call
}

// Unlink is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) Unlink(ctx interface{}, keys ...interface{}) *MockPipeliner_Unlink_Call {
	return &MockPipeliner_Unlink_Call{Call: _e.mock.On("Unlink",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_Unlink_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_Unlink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_Unlink_Call) Return(_a0 *IntCmd) *MockPipeliner_Unlink_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_Unlink_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockPipeliner_Unlink_Call {
	_c.Call.Return(run)
	return _c
}

// XAck provides a mock function with given fields: ctx, stream, group, ids
func (_m *MockPipeliner) XAck(ctx context.Context, stream string, group string, ids ...string) *IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XAck")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XAck_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAck'
type MockPipeliner_XAck_Call struct {
	*mock.Call
}

// XAck is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - ids ...string
func (_e *MockPipeliner_Expecter) XAck(ctx interface{}, stream interface{}, group interface{}, ids ...interface{}) *MockPipeliner_XAck_Call {
	return &MockPipeliner_XAck_Call{Call: _e.mock.On("XAck",
		append([]interface{}{ctx, stream, group}, ids...)...)}
}

func (_c *MockPipeliner_XAck_Call) Run(run func(ctx context.Context, stream string, group string, ids ...string)) *MockPipeliner_XAck_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_XAck_Call) Return(_a0 *IntCmd) *MockPipeliner_XAck_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XAck_Call) RunAndReturn(run func(context.Context, string, string, ...string) *IntCmd) *MockPipeliner_XAck_Call {
	_c.Call.Return(run)
	return _c
}

// XAdd provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XAdd(ctx context.Context, a *XAddArgs) *StringCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAdd")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XAddArgs) *StringCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockPipeliner_XAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAdd'
type MockPipeliner_XAdd_Call struct {
	*mock.Call
}

// XAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XAddArgs
func (_e *MockPipeliner_Expecter) XAdd(ctx interface{}, a interface{}) *MockPipeliner_XAdd_Call {
	return &MockPipeliner_XAdd_Call{Call: _e.mock.On("XAdd", ctx, a)}
}

func (_c *MockPipeliner_XAdd_Call) Run(run func(ctx context.Context, a *XAddArgs)) *MockPipeliner_XAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XAddArgs))
	})
	return _c
}

func (_c *MockPipeliner_XAdd_Call) Return(_a0 *StringCmd) *MockPipeliner_XAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XAdd_Call) RunAndReturn(run func(context.Context, *XAddArgs) *StringCmd) *MockPipeliner_XAdd_Call {
	_c.Call.Return(run)
	return _c
}

// XAutoClaim provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XAutoClaim(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaim")
	}

	var r0 *XAutoClaimCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XAutoClaimArgs) *XAutoClaimCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XAutoClaimCmd)
		}
	}

	return r0
}

// MockPipeliner_XAutoClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAutoClaim'
type MockPipeliner_XAutoClaim_Call struct {
	*mock.Call
}

// XAutoClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XAutoClaimArgs
func (_e *MockPipeliner_Expecter) XAutoClaim(ctx interface{}, a interface{}) *MockPipeliner_XAutoClaim_Call {
	return &MockPipeliner_XAutoClaim_Call{Call: _e.mock.On("XAutoClaim", ctx, a)}
}

func (_c *MockPipeliner_XAutoClaim_Call) Run(run func(ctx context.Context, a *XAutoClaimArgs)) *MockPipeliner_XAutoClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XAutoClaimArgs))
	})
	return _c
}

func (_c *MockPipeliner_XAutoClaim_Call) Return(_a0 *XAutoClaimCmd) *MockPipeliner_XAutoClaim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XAutoClaim_Call) RunAndReturn(run func(context.Context, *XAutoClaimArgs) *XAutoClaimCmd) *MockPipeliner_XAutoClaim_Call {
	_c.Call.Return(run)
	return _c
}

// XAutoClaimJustID provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XAutoClaimJustID(ctx context.Context, a *XAutoClaimArgs) *XAutoClaimJustIDCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XAutoClaimJustID")
	}

	var r0 *XAutoClaimJustIDCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XAutoClaimArgs) *XAutoClaimJustIDCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XAutoClaimJustIDCmd)
		}
	}

	return r0
}

// MockPipeliner_XAutoClaimJustID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XAutoClaimJustID'
type MockPipeliner_XAutoClaimJustID_Call struct {
	*mock.Call
}

// XAutoClaimJustID is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XAutoClaimArgs
func (_e *MockPipeliner_Expecter) XAutoClaimJustID(ctx interface{}, a interface{}) *MockPipeliner_XAutoClaimJustID_Call {
	return &MockPipeliner_XAutoClaimJustID_Call{Call: _e.mock.On("XAutoClaimJustID", ctx, a)}
}

func (_c *MockPipeliner_XAutoClaimJustID_Call) Run(run func(ctx context.Context, a *XAutoClaimArgs)) *MockPipeliner_XAutoClaimJustID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XAutoClaimArgs))
	})
	return _c
}

func (_c *MockPipeliner_XAutoClaimJustID_Call) Return(_a0 *XAutoClaimJustIDCmd) *MockPipeliner_XAutoClaimJustID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XAutoClaimJustID_Call) RunAndReturn(run func(context.Context, *XAutoClaimArgs) *XAutoClaimJustIDCmd) *MockPipeliner_XAutoClaimJustID_Call {
	_c.Call.Return(run)
	return _c
}

// XClaim provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XClaim(ctx context.Context, a *XClaimArgs) *XMessageSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaim")
	}

	var r0 *XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XClaimArgs) *XMessageSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XMessageSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XClaim'
type MockPipeliner_XClaim_Call struct {
	*mock.Call
}

// XClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XClaimArgs
func (_e *MockPipeliner_Expecter) XClaim(ctx interface{}, a interface{}) *MockPipeliner_XClaim_Call {
	return &MockPipeliner_XClaim_Call{Call: _e.mock.On("XClaim", ctx, a)}
}

func (_c *MockPipeliner_XClaim_Call) Run(run func(ctx context.Context, a *XClaimArgs)) *MockPipeliner_XClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XClaimArgs))
	})
	return _c
}

func (_c *MockPipeliner_XClaim_Call) Return(_a0 *XMessageSliceCmd) *MockPipeliner_XClaim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XClaim_Call) RunAndReturn(run func(context.Context, *XClaimArgs) *XMessageSliceCmd) *MockPipeliner_XClaim_Call {
	_c.Call.Return(run)
	return _c
}

// XClaimJustID provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XClaimJustID(ctx context.Context, a *XClaimArgs) *StringSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XClaimJustID")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XClaimArgs) *StringSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XClaimJustID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XClaimJustID'
type MockPipeliner_XClaimJustID_Call struct {
	*mock.Call
}

// XClaimJustID is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XClaimArgs
func (_e *MockPipeliner_Expecter) XClaimJustID(ctx interface{}, a interface{}) *MockPipeliner_XClaimJustID_Call {
	return &MockPipeliner_XClaimJustID_Call{Call: _e.mock.On("XClaimJustID", ctx, a)}
}

func (_c *MockPipeliner_XClaimJustID_Call) Run(run func(ctx context.Context, a *XClaimArgs)) *MockPipeliner_XClaimJustID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XClaimArgs))
	})
	return _c
}

func (_c *MockPipeliner_XClaimJustID_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_XClaimJustID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XClaimJustID_Call) RunAndReturn(run func(context.Context, *XClaimArgs) *StringSliceCmd) *MockPipeliner_XClaimJustID_Call {
	_c.Call.Return(run)
	return _c
}

// XDel provides a mock function with given fields: ctx, stream, ids
func (_m *MockPipeliner) XDel(ctx context.Context, stream string, ids ...string) *IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XDel'
type MockPipeliner_XDel_Call struct {
	*mock.Call
}

// XDel is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - ids ...string
func (_e *MockPipeliner_Expecter) XDel(ctx interface{}, stream interface{}, ids ...interface{}) *MockPipeliner_XDel_Call {
	return &MockPipeliner_XDel_Call{Call: _e.mock.On("XDel",
		append([]interface{}{ctx, stream}, ids...)...)}
}

func (_c *MockPipeliner_XDel_Call) Run(run func(ctx context.Context, stream string, ids ...string)) *MockPipeliner_XDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_XDel_Call) Return(_a0 *IntCmd) *MockPipeliner_XDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XDel_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_XDel_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreate provides a mock function with given fields: ctx, stream, group, start
func (_m *MockPipeliner) XGroupCreate(ctx context.Context, stream string, group string, start string) *StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupCreate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreate'
type MockPipeliner_XGroupCreate_Call struct {
	*mock.Call
}

// XGroupCreate is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockPipeliner_Expecter) XGroupCreate(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockPipeliner_XGroupCreate_Call {
	return &MockPipeliner_XGroupCreate_Call{Call: _e.mock.On("XGroupCreate", ctx, stream, group, start)}
}

func (_c *MockPipeliner_XGroupCreate_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockPipeliner_XGroupCreate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupCreate_Call) Return(_a0 *StatusCmd) *MockPipeliner_XGroupCreate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupCreate_Call) RunAndReturn(run func(context.Context, string, string, string) *StatusCmd) *MockPipeliner_XGroupCreate_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreateConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *MockPipeliner) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateConsumer")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupCreateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreateConsumer'
type MockPipeliner_XGroupCreateConsumer_Call struct {
	*mock.Call
}

// XGroupCreateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - consumer string
func (_e *MockPipeliner_Expecter) XGroupCreateConsumer(ctx interface{}, stream interface{}, group interface{}, consumer interface{}) *MockPipeliner_XGroupCreateConsumer_Call {
	return &MockPipeliner_XGroupCreateConsumer_Call{Call: _e.mock.On("XGroupCreateConsumer", ctx, stream, group, consumer)}
}

func (_c *MockPipeliner_XGroupCreateConsumer_Call) Run(run func(ctx context.Context, stream string, group string, consumer string)) *MockPipeliner_XGroupCreateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupCreateConsumer_Call) Return(_a0 *IntCmd) *MockPipeliner_XGroupCreateConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupCreateConsumer_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_XGroupCreateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupCreateMkStream provides a mock function with given fields: ctx, stream, group, start
func (_m *MockPipeliner) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateMkStream")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupCreateMkStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupCreateMkStream'
type MockPipeliner_XGroupCreateMkStream_Call struct {
	*mock.Call
}

// XGroupCreateMkStream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockPipeliner_Expecter) XGroupCreateMkStream(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockPipeliner_XGroupCreateMkStream_Call {
	return &MockPipeliner_XGroupCreateMkStream_Call{Call: _e.mock.On("XGroupCreateMkStream", ctx, stream, group, start)}
}

func (_c *MockPipeliner_XGroupCreateMkStream_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockPipeliner_XGroupCreateMkStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupCreateMkStream_Call) Return(_a0 *StatusCmd) *MockPipeliner_XGroupCreateMkStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupCreateMkStream_Call) RunAndReturn(run func(context.Context, string, string, string) *StatusCmd) *MockPipeliner_XGroupCreateMkStream_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupDelConsumer provides a mock function with given fields: ctx, stream, group, consumer
func (_m *MockPipeliner) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *IntCmd {
	ret := _m.Called(ctx, stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDelConsumer")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupDelConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupDelConsumer'
type MockPipeliner_XGroupDelConsumer_Call struct {
	*mock.Call
}

// XGroupDelConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - consumer string
func (_e *MockPipeliner_Expecter) XGroupDelConsumer(ctx interface{}, stream interface{}, group interface{}, consumer interface{}) *MockPipeliner_XGroupDelConsumer_Call {
	return &MockPipeliner_XGroupDelConsumer_Call{Call: _e.mock.On("XGroupDelConsumer", ctx, stream, group, consumer)}
}

func (_c *MockPipeliner_XGroupDelConsumer_Call) Run(run func(ctx context.Context, stream string, group string, consumer string)) *MockPipeliner_XGroupDelConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupDelConsumer_Call) Return(_a0 *IntCmd) *MockPipeliner_XGroupDelConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupDelConsumer_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_XGroupDelConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupDestroy provides a mock function with given fields: ctx, stream, group
func (_m *MockPipeliner) XGroupDestroy(ctx context.Context, stream string, group string) *IntCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDestroy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupDestroy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupDestroy'
type MockPipeliner_XGroupDestroy_Call struct {
	*mock.Call
}

// XGroupDestroy is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
func (_e *MockPipeliner_Expecter) XGroupDestroy(ctx interface{}, stream interface{}, group interface{}) *MockPipeliner_XGroupDestroy_Call {
	return &MockPipeliner_XGroupDestroy_Call{Call: _e.mock.On("XGroupDestroy", ctx, stream, group)}
}

func (_c *MockPipeliner_XGroupDestroy_Call) Run(run func(ctx context.Context, stream string, group string)) *MockPipeliner_XGroupDestroy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupDestroy_Call) Return(_a0 *IntCmd) *MockPipeliner_XGroupDestroy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupDestroy_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_XGroupDestroy_Call {
	_c.Call.Return(run)
	return _c
}

// XGroupSetID provides a mock function with given fields: ctx, stream, group, start
func (_m *MockPipeliner) XGroupSetID(ctx context.Context, stream string, group string, start string) *StatusCmd {
	ret := _m.Called(ctx, stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupSetID")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *StatusCmd); ok {
		r0 = rf(ctx, stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockPipeliner_XGroupSetID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XGroupSetID'
type MockPipeliner_XGroupSetID_Call struct {
	*mock.Call
}

// XGroupSetID is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
//   - start string
func (_e *MockPipeliner_Expecter) XGroupSetID(ctx interface{}, stream interface{}, group interface{}, start interface{}) *MockPipeliner_XGroupSetID_Call {
	return &MockPipeliner_XGroupSetID_Call{Call: _e.mock.On("XGroupSetID", ctx, stream, group, start)}
}

func (_c *MockPipeliner_XGroupSetID_Call) Run(run func(ctx context.Context, stream string, group string, start string)) *MockPipeliner_XGroupSetID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XGroupSetID_Call) Return(_a0 *StatusCmd) *MockPipeliner_XGroupSetID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XGroupSetID_Call) RunAndReturn(run func(context.Context, string, string, string) *StatusCmd) *MockPipeliner_XGroupSetID_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoConsumers provides a mock function with given fields: ctx, key, group
func (_m *MockPipeliner) XInfoConsumers(ctx context.Context, key string, group string) *XInfoConsumersCmd {
	ret := _m.Called(ctx, key, group)

	if len(ret) == 0 {
		panic("no return value specified for XInfoConsumers")
	}

	var r0 *XInfoConsumersCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *XInfoConsumersCmd); ok {
		r0 = rf(ctx, key, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XInfoConsumersCmd)
		}
	}

	return r0
}

// MockPipeliner_XInfoConsumers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoConsumers'
type MockPipeliner_XInfoConsumers_Call struct {
	*mock.Call
}

// XInfoConsumers is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - group string
func (_e *MockPipeliner_Expecter) XInfoConsumers(ctx interface{}, key interface{}, group interface{}) *MockPipeliner_XInfoConsumers_Call {
	return &MockPipeliner_XInfoConsumers_Call{Call: _e.mock.On("XInfoConsumers", ctx, key, group)}
}

func (_c *MockPipeliner_XInfoConsumers_Call) Run(run func(ctx context.Context, key string, group string)) *MockPipeliner_XInfoConsumers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_XInfoConsumers_Call) Return(_a0 *XInfoConsumersCmd) *MockPipeliner_XInfoConsumers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XInfoConsumers_Call) RunAndReturn(run func(context.Context, string, string) *XInfoConsumersCmd) *MockPipeliner_XInfoConsumers_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoGroups provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) XInfoGroups(ctx context.Context, key string) *XInfoGroupsCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoGroups")
	}

	var r0 *XInfoGroupsCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *XInfoGroupsCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XInfoGroupsCmd)
		}
	}

	return r0
}

// MockPipeliner_XInfoGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoGroups'
type MockPipeliner_XInfoGroups_Call struct {
	*mock.Call
}

// XInfoGroups is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) XInfoGroups(ctx interface{}, key interface{}) *MockPipeliner_XInfoGroups_Call {
	return &MockPipeliner_XInfoGroups_Call{Call: _e.mock.On("XInfoGroups", ctx, key)}
}

func (_c *MockPipeliner_XInfoGroups_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_XInfoGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_XInfoGroups_Call) Return(_a0 *XInfoGroupsCmd) *MockPipeliner_XInfoGroups_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XInfoGroups_Call) RunAndReturn(run func(context.Context, string) *XInfoGroupsCmd) *MockPipeliner_XInfoGroups_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoStream provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) XInfoStream(ctx context.Context, key string) *XInfoStreamCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStream")
	}

	var r0 *XInfoStreamCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *XInfoStreamCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XInfoStreamCmd)
		}
	}

	return r0
}

// MockPipeliner_XInfoStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoStream'
type MockPipeliner_XInfoStream_Call struct {
	*mock.Call
}

// XInfoStream is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) XInfoStream(ctx interface{}, key interface{}) *MockPipeliner_XInfoStream_Call {
	return &MockPipeliner_XInfoStream_Call{Call: _e.mock.On("XInfoStream", ctx, key)}
}

func (_c *MockPipeliner_XInfoStream_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_XInfoStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_XInfoStream_Call) Return(_a0 *XInfoStreamCmd) *MockPipeliner_XInfoStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XInfoStream_Call) RunAndReturn(run func(context.Context, string) *XInfoStreamCmd) *MockPipeliner_XInfoStream_Call {
	_c.Call.Return(run)
	return _c
}

// XInfoStreamFull provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) XInfoStreamFull(ctx context.Context, key string, count int) *XInfoStreamFullCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for XInfoStreamFull")
	}

	var r0 *XInfoStreamFullCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *XInfoStreamFullCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XInfoStreamFullCmd)
		}
	}

	return r0
}

// MockPipeliner_XInfoStreamFull_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XInfoStreamFull'
type MockPipeliner_XInfoStreamFull_Call struct {
	*mock.Call
}

// XInfoStreamFull is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) XInfoStreamFull(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_XInfoStreamFull_Call {
	return &MockPipeliner_XInfoStreamFull_Call{Call: _e.mock.On("XInfoStreamFull", ctx, key, count)}
}

func (_c *MockPipeliner_XInfoStreamFull_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_XInfoStreamFull_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_XInfoStreamFull_Call) Return(_a0 *XInfoStreamFullCmd) *MockPipeliner_XInfoStreamFull_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XInfoStreamFull_Call) RunAndReturn(run func(context.Context, string, int) *XInfoStreamFullCmd) *MockPipeliner_XInfoStreamFull_Call {
	_c.Call.Return(run)
	return _c
}

// XLen provides a mock function with given fields: ctx, stream
func (_m *MockPipeliner) XLen(ctx context.Context, stream string) *IntCmd {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for XLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XLen'
type MockPipeliner_XLen_Call struct {
	*mock.Call
}

// XLen is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *MockPipeliner_Expecter) XLen(ctx interface{}, stream interface{}) *MockPipeliner_XLen_Call {
	return &MockPipeliner_XLen_Call{Call: _e.mock.On("XLen", ctx, stream)}
}

func (_c *MockPipeliner_XLen_Call) Run(run func(ctx context.Context, stream string)) *MockPipeliner_XLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_XLen_Call) Return(_a0 *IntCmd) *MockPipeliner_XLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_XLen_Call {
	_c.Call.Return(run)
	return _c
}

// XPending provides a mock function with given fields: ctx, stream, group
func (_m *MockPipeliner) XPending(ctx context.Context, stream string, group string) *XPendingCmd {
	ret := _m.Called(ctx, stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XPending")
	}

	var r0 *XPendingCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *XPendingCmd); ok {
		r0 = rf(ctx, stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XPendingCmd)
		}
	}

	return r0
}

// MockPipeliner_XPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XPending'
type MockPipeliner_XPending_Call struct {
	*mock.Call
}

// XPending is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - group string
func (_e *MockPipeliner_Expecter) XPending(ctx interface{}, stream interface{}, group interface{}) *MockPipeliner_XPending_Call {
	return &MockPipeliner_XPending_Call{Call: _e.mock.On("XPending", ctx, stream, group)}
}

func (_c *MockPipeliner_XPending_Call) Run(run func(ctx context.Context, stream string, group string)) *MockPipeliner_XPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_XPending_Call) Return(_a0 *XPendingCmd) *MockPipeliner_XPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XPending_Call) RunAndReturn(run func(context.Context, string, string) *XPendingCmd) *MockPipeliner_XPending_Call {
	_c.Call.Return(run)
	return _c
}

// XPendingExt provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XPendingExt(ctx context.Context, a *XPendingExtArgs) *XPendingExtCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XPendingExt")
	}

	var r0 *XPendingExtCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XPendingExtArgs) *XPendingExtCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XPendingExtCmd)
		}
	}

	return r0
}

// MockPipeliner_XPendingExt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XPendingExt'
type MockPipeliner_XPendingExt_Call struct {
	*mock.Call
}

// XPendingExt is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XPendingExtArgs
func (_e *MockPipeliner_Expecter) XPendingExt(ctx interface{}, a interface{}) *MockPipeliner_XPendingExt_Call {
	return &MockPipeliner_XPendingExt_Call{Call: _e.mock.On("XPendingExt", ctx, a)}
}

func (_c *MockPipeliner_XPendingExt_Call) Run(run func(ctx context.Context, a *XPendingExtArgs)) *MockPipeliner_XPendingExt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XPendingExtArgs))
	})
	return _c
}

func (_c *MockPipeliner_XPendingExt_Call) Return(_a0 *XPendingExtCmd) *MockPipeliner_XPendingExt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XPendingExt_Call) RunAndReturn(run func(context.Context, *XPendingExtArgs) *XPendingExtCmd) *MockPipeliner_XPendingExt_Call {
	_c.Call.Return(run)
	return _c
}

// XRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *MockPipeliner) XRange(ctx context.Context, stream string, start string, stop string) *XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRange")
	}

	var r0 *XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XMessageSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRange'
type MockPipeliner_XRange_Call struct {
	*mock.Call
}

// XRange is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
func (_e *MockPipeliner_Expecter) XRange(ctx interface{}, stream interface{}, start interface{}, stop interface{}) *MockPipeliner_XRange_Call {
	return &MockPipeliner_XRange_Call{Call: _e.mock.On("XRange", ctx, stream, start, stop)}
}

func (_c *MockPipeliner_XRange_Call) Run(run func(ctx context.Context, stream string, start string, stop string)) *MockPipeliner_XRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XRange_Call) Return(_a0 *XMessageSliceCmd) *MockPipeliner_XRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XRange_Call) RunAndReturn(run func(context.Context, string, string, string) *XMessageSliceCmd) *MockPipeliner_XRange_Call {
	_c.Call.Return(run)
	return _c
}

// XRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *MockPipeliner) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRangeN")
	}

	var r0 *XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XMessageSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XRangeN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRangeN'
type MockPipeliner_XRangeN_Call struct {
	*mock.Call
}

// XRangeN is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
//   - count int64
func (_e *MockPipeliner_Expecter) XRangeN(ctx interface{}, stream interface{}, start interface{}, stop interface{}, count interface{}) *MockPipeliner_XRangeN_Call {
	return &MockPipeliner_XRangeN_Call{Call: _e.mock.On("XRangeN", ctx, stream, start, stop, count)}
}

func (_c *MockPipeliner_XRangeN_Call) Run(run func(ctx context.Context, stream string, start string, stop string, count int64)) *MockPipeliner_XRangeN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_XRangeN_Call) Return(_a0 *XMessageSliceCmd) *MockPipeliner_XRangeN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XRangeN_Call) RunAndReturn(run func(context.Context, string, string, string, int64) *XMessageSliceCmd) *MockPipeliner_XRangeN_Call {
	_c.Call.Return(run)
	return _c
}

// XRead provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XRead(ctx context.Context, a *XReadArgs) *XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XRead")
	}

	var r0 *XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XReadArgs) *XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XStreamSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XRead_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRead'
type MockPipeliner_XRead_Call struct {
	*mock.Call
}

// XRead is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XReadArgs
func (_e *MockPipeliner_Expecter) XRead(ctx interface{}, a interface{}) *MockPipeliner_XRead_Call {
	return &MockPipeliner_XRead_Call{Call: _e.mock.On("XRead", ctx, a)}
}

func (_c *MockPipeliner_XRead_Call) Run(run func(ctx context.Context, a *XReadArgs)) *MockPipeliner_XRead_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XReadArgs))
	})
	return _c
}

func (_c *MockPipeliner_XRead_Call) Return(_a0 *XStreamSliceCmd) *MockPipeliner_XRead_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XRead_Call) RunAndReturn(run func(context.Context, *XReadArgs) *XStreamSliceCmd) *MockPipeliner_XRead_Call {
	_c.Call.Return(run)
	return _c
}

// XReadGroup provides a mock function with given fields: ctx, a
func (_m *MockPipeliner) XReadGroup(ctx context.Context, a *XReadGroupArgs) *XStreamSliceCmd {
	ret := _m.Called(ctx, a)

	if len(ret) == 0 {
		panic("no return value specified for XReadGroup")
	}

	var r0 *XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *XReadGroupArgs) *XStreamSliceCmd); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XStreamSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XReadGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XReadGroup'
type MockPipeliner_XReadGroup_Call struct {
	*mock.Call
}

// XReadGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - a *XReadGroupArgs
func (_e *MockPipeliner_Expecter) XReadGroup(ctx interface{}, a interface{}) *MockPipeliner_XReadGroup_Call {
	return &MockPipeliner_XReadGroup_Call{Call: _e.mock.On("XReadGroup", ctx, a)}
}

func (_c *MockPipeliner_XReadGroup_Call) Run(run func(ctx context.Context, a *XReadGroupArgs)) *MockPipeliner_XReadGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*XReadGroupArgs))
	})
	return _c
}

func (_c *MockPipeliner_XReadGroup_Call) Return(_a0 *XStreamSliceCmd) *MockPipeliner_XReadGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XReadGroup_Call) RunAndReturn(run func(context.Context, *XReadGroupArgs) *XStreamSliceCmd) *MockPipeliner_XReadGroup_Call {
	_c.Call.Return(run)
	return _c
}

// XReadStreams provides a mock function with given fields: ctx, streams
func (_m *MockPipeliner) XReadStreams(ctx context.Context, streams ...string) *XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XReadStreams")
	}

	var r0 *XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *XStreamSliceCmd); ok {
		r0 = rf(ctx, streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XStreamSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XReadStreams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XReadStreams'
type MockPipeliner_XReadStreams_Call struct {
	*mock.Call
}

// XReadStreams is a helper method to define mock.On call
//   - ctx context.Context
//   - streams ...string
func (_e *MockPipeliner_Expecter) XReadStreams(ctx interface{}, streams ...interface{}) *MockPipeliner_XReadStreams_Call {
	return &MockPipeliner_XReadStreams_Call{Call: _e.mock.On("XReadStreams",
		append([]interface{}{ctx}, streams...)...)}
}

func (_c *MockPipeliner_XReadStreams_Call) Run(run func(ctx context.Context, streams ...string)) *MockPipeliner_XReadStreams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_XReadStreams_Call) Return(_a0 *XStreamSliceCmd) *MockPipeliner_XReadStreams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XReadStreams_Call) RunAndReturn(run func(context.Context, ...string) *XStreamSliceCmd) *MockPipeliner_XReadStreams_Call {
	_c.Call.Return(run)
	return _c
}

// XRevRange provides a mock function with given fields: ctx, stream, start, stop
func (_m *MockPipeliner) XRevRange(ctx context.Context, stream string, start string, stop string) *XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRevRange")
	}

	var r0 *XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XMessageSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRevRange'
type MockPipeliner_XRevRange_Call struct {
	*mock.Call
}

// XRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
func (_e *MockPipeliner_Expecter) XRevRange(ctx interface{}, stream interface{}, start interface{}, stop interface{}) *MockPipeliner_XRevRange_Call {
	return &MockPipeliner_XRevRange_Call{Call: _e.mock.On("XRevRange", ctx, stream, start, stop)}
}

func (_c *MockPipeliner_XRevRange_Call) Run(run func(ctx context.Context, stream string, start string, stop string)) *MockPipeliner_XRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_XRevRange_Call) Return(_a0 *XMessageSliceCmd) *MockPipeliner_XRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XRevRange_Call) RunAndReturn(run func(context.Context, string, string, string) *XMessageSliceCmd) *MockPipeliner_XRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// XRevRangeN provides a mock function with given fields: ctx, stream, start, stop, count
func (_m *MockPipeliner) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *XMessageSliceCmd {
	ret := _m.Called(ctx, stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRevRangeN")
	}

	var r0 *XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int64) *XMessageSliceCmd); ok {
		r0 = rf(ctx, stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*XMessageSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_XRevRangeN_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XRevRangeN'
type MockPipeliner_XRevRangeN_Call struct {
	*mock.Call
}

// XRevRangeN is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - start string
//   - stop string
//   - count int64
func (_e *MockPipeliner_Expecter) XRevRangeN(ctx interface{}, stream interface{}, start interface{}, stop interface{}, count interface{}) *MockPipeliner_XRevRangeN_Call {
	return &MockPipeliner_XRevRangeN_Call{Call: _e.mock.On("XRevRangeN", ctx, stream, start, stop, count)}
}

func (_c *MockPipeliner_XRevRangeN_Call) Run(run func(ctx context.Context, stream string, start string, stop string, count int64)) *MockPipeliner_XRevRangeN_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_XRevRangeN_Call) Return(_a0 *XMessageSliceCmd) *MockPipeliner_XRevRangeN_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XRevRangeN_Call) RunAndReturn(run func(context.Context, string, string, string, int64) *XMessageSliceCmd) *MockPipeliner_XRevRangeN_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMaxLen provides a mock function with given fields: ctx, key, maxLen
func (_m *MockPipeliner) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *IntCmd {
	ret := _m.Called(ctx, key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XTrimMaxLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMaxLen'
type MockPipeliner_XTrimMaxLen_Call struct {
	*mock.Call
}

// XTrimMaxLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
func (_e *MockPipeliner_Expecter) XTrimMaxLen(ctx interface{}, key interface{}, maxLen interface{}) *MockPipeliner_XTrimMaxLen_Call {
	return &MockPipeliner_XTrimMaxLen_Call{Call: _e.mock.On("XTrimMaxLen", ctx, key, maxLen)}
}

func (_c *MockPipeliner_XTrimMaxLen_Call) Run(run func(ctx context.Context, key string, maxLen int64)) *MockPipeliner_XTrimMaxLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockPipeliner_XTrimMaxLen_Call) Return(_a0 *IntCmd) *MockPipeliner_XTrimMaxLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XTrimMaxLen_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockPipeliner_XTrimMaxLen_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMaxLenApprox provides a mock function with given fields: ctx, key, maxLen, limit
func (_m *MockPipeliner) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *IntCmd {
	ret := _m.Called(ctx, key, maxLen, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMaxLenApprox")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *IntCmd); ok {
		r0 = rf(ctx, key, maxLen, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XTrimMaxLenApprox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMaxLenApprox'
type MockPipeliner_XTrimMaxLenApprox_Call struct {
	*mock.Call
}

// XTrimMaxLenApprox is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - maxLen int64
//   - limit int64
func (_e *MockPipeliner_Expecter) XTrimMaxLenApprox(ctx interface{}, key interface{}, maxLen interface{}, limit interface{}) *MockPipeliner_XTrimMaxLenApprox_Call {
	return &MockPipeliner_XTrimMaxLenApprox_Call{Call: _e.mock.On("XTrimMaxLenApprox", ctx, key, maxLen, limit)}
}

func (_c *MockPipeliner_XTrimMaxLenApprox_Call) Run(run func(ctx context.Context, key string, maxLen int64, limit int64)) *MockPipeliner_XTrimMaxLenApprox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_XTrimMaxLenApprox_Call) Return(_a0 *IntCmd) *MockPipeliner_XTrimMaxLenApprox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XTrimMaxLenApprox_Call) RunAndReturn(run func(context.Context, string, int64, int64) *IntCmd) *MockPipeliner_XTrimMaxLenApprox_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMinID provides a mock function with given fields: ctx, key, minID
func (_m *MockPipeliner) XTrimMinID(ctx context.Context, key string, minID string) *IntCmd {
	ret := _m.Called(ctx, key, minID)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinID")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, minID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XTrimMinID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMinID'
type MockPipeliner_XTrimMinID_Call struct {
	*mock.Call
}

// XTrimMinID is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - minID string
func (_e *MockPipeliner_Expecter) XTrimMinID(ctx interface{}, key interface{}, minID interface{}) *MockPipeliner_XTrimMinID_Call {
	return &MockPipeliner_XTrimMinID_Call{Call: _e.mock.On("XTrimMinID", ctx, key, minID)}
}

func (_c *MockPipeliner_XTrimMinID_Call) Run(run func(ctx context.Context, key string, minID string)) *MockPipeliner_XTrimMinID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_XTrimMinID_Call) Return(_a0 *IntCmd) *MockPipeliner_XTrimMinID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XTrimMinID_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_XTrimMinID_Call {
	_c.Call.Return(run)
	return _c
}

// XTrimMinIDApprox provides a mock function with given fields: ctx, key, minID, limit
func (_m *MockPipeliner) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *IntCmd {
	ret := _m.Called(ctx, key, minID, limit)

	if len(ret) == 0 {
		panic("no return value specified for XTrimMinIDApprox")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, minID, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_XTrimMinIDApprox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'XTrimMinIDApprox'
type MockPipeliner_XTrimMinIDApprox_Call struct {
	*mock.Call
}

// XTrimMinIDApprox is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - minID string
//   - limit int64
func (_e *MockPipeliner_Expecter) XTrimMinIDApprox(ctx interface{}, key interface{}, minID interface{}, limit interface{}) *MockPipeliner_XTrimMinIDApprox_Call {
	return &MockPipeliner_XTrimMinIDApprox_Call{Call: _e.mock.On("XTrimMinIDApprox", ctx, key, minID, limit)}
}

func (_c *MockPipeliner_XTrimMinIDApprox_Call) Run(run func(ctx context.Context, key string, minID string, limit int64)) *MockPipeliner_XTrimMinIDApprox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_XTrimMinIDApprox_Call) Return(_a0 *IntCmd) *MockPipeliner_XTrimMinIDApprox_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_XTrimMinIDApprox_Call) RunAndReturn(run func(context.Context, string, string, int64) *IntCmd) *MockPipeliner_XTrimMinIDApprox_Call {
	_c.Call.Return(run)
	return _c
}

// ZAdd provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZAdd(ctx context.Context, key string, members ...Z) *IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...Z) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAdd'
type MockPipeliner_ZAdd_Call struct {
	*mock.Call
}

// ZAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...Z
func (_e *MockPipeliner_Expecter) ZAdd(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZAdd_Call {
	return &MockPipeliner_ZAdd_Call{Call: _e.mock.On("ZAdd",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZAdd_Call) Run(run func(ctx context.Context, key string, members ...Z)) *MockPipeliner_ZAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZAdd_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAdd_Call) RunAndReturn(run func(context.Context, string, ...Z) *IntCmd) *MockPipeliner_ZAdd_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddArgs provides a mock function with given fields: ctx, key, args
func (_m *MockPipeliner) ZAddArgs(ctx context.Context, key string, args ZAddArgs) *IntCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgs")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ZAddArgs) *IntCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddArgs'
type MockPipeliner_ZAddArgs_Call struct {
	*mock.Call
}

// ZAddArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - args ZAddArgs
func (_e *MockPipeliner_Expecter) ZAddArgs(ctx interface{}, key interface{}, args interface{}) *MockPipeliner_ZAddArgs_Call {
	return &MockPipeliner_ZAddArgs_Call{Call: _e.mock.On("ZAddArgs", ctx, key, args)}
}

func (_c *MockPipeliner_ZAddArgs_Call) Run(run func(ctx context.Context, key string, args ZAddArgs)) *MockPipeliner_ZAddArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ZAddArgs))
	})
	return _c
}

func (_c *MockPipeliner_ZAddArgs_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAddArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddArgs_Call) RunAndReturn(run func(context.Context, string, ZAddArgs) *IntCmd) *MockPipeliner_ZAddArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddArgsIncr provides a mock function with given fields: ctx, key, args
func (_m *MockPipeliner) ZAddArgsIncr(ctx context.Context, key string, args ZAddArgs) *FloatCmd {
	ret := _m.Called(ctx, key, args)

	if len(ret) == 0 {
		panic("no return value specified for ZAddArgsIncr")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ZAddArgs) *FloatCmd); ok {
		r0 = rf(ctx, key, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddArgsIncr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddArgsIncr'
type MockPipeliner_ZAddArgsIncr_Call struct {
	*mock.Call
}

// ZAddArgsIncr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - args ZAddArgs
func (_e *MockPipeliner_Expecter) ZAddArgsIncr(ctx interface{}, key interface{}, args interface{}) *MockPipeliner_ZAddArgsIncr_Call {
	return &MockPipeliner_ZAddArgsIncr_Call{Call: _e.mock.On("ZAddArgsIncr", ctx, key, args)}
}

func (_c *MockPipeliner_ZAddArgsIncr_Call) Run(run func(ctx context.Context, key string, args ZAddArgs)) *MockPipeliner_ZAddArgsIncr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ZAddArgs))
	})
	return _c
}

func (_c *MockPipeliner_ZAddArgsIncr_Call) Return(_a0 *FloatCmd) *MockPipeliner_ZAddArgsIncr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddArgsIncr_Call) RunAndReturn(run func(context.Context, string, ZAddArgs) *FloatCmd) *MockPipeliner_ZAddArgsIncr_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddGT provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZAddGT(ctx context.Context, key string, members ...Z) *IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddGT")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...Z) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddGT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddGT'
type MockPipeliner_ZAddGT_Call struct {
	*mock.Call
}

// ZAddGT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...Z
func (_e *MockPipeliner_Expecter) ZAddGT(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZAddGT_Call {
	return &MockPipeliner_ZAddGT_Call{Call: _e.mock.On("ZAddGT",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZAddGT_Call) Run(run func(ctx context.Context, key string, members ...Z)) *MockPipeliner_ZAddGT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZAddGT_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAddGT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddGT_Call) RunAndReturn(run func(context.Context, string, ...Z) *IntCmd) *MockPipeliner_ZAddGT_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddLT provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZAddLT(ctx context.Context, key string, members ...Z) *IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddLT")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...Z) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddLT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddLT'
type MockPipeliner_ZAddLT_Call struct {
	*mock.Call
}

// ZAddLT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...Z
func (_e *MockPipeliner_Expecter) ZAddLT(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZAddLT_Call {
	return &MockPipeliner_ZAddLT_Call{Call: _e.mock.On("ZAddLT",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZAddLT_Call) Run(run func(ctx context.Context, key string, members ...Z)) *MockPipeliner_ZAddLT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZAddLT_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAddLT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddLT_Call) RunAndReturn(run func(context.Context, string, ...Z) *IntCmd) *MockPipeliner_ZAddLT_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddNX provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZAddNX(ctx context.Context, key string, members ...Z) *IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...Z) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddNX'
type MockPipeliner_ZAddNX_Call struct {
	*mock.Call
}

// ZAddNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...Z
func (_e *MockPipeliner_Expecter) ZAddNX(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZAddNX_Call {
	return &MockPipeliner_ZAddNX_Call{Call: _e.mock.On("ZAddNX",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZAddNX_Call) Run(run func(ctx context.Context, key string, members ...Z)) *MockPipeliner_ZAddNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZAddNX_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAddNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddNX_Call) RunAndReturn(run func(context.Context, string, ...Z) *IntCmd) *MockPipeliner_ZAddNX_Call {
	_c.Call.Return(run)
	return _c
}

// ZAddXX provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZAddXX(ctx context.Context, key string, members ...Z) *IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...Z) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZAddXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZAddXX'
type MockPipeliner_ZAddXX_Call struct {
	*mock.Call
}

// ZAddXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...Z
func (_e *MockPipeliner_Expecter) ZAddXX(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZAddXX_Call {
	return &MockPipeliner_ZAddXX_Call{Call: _e.mock.On("ZAddXX",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZAddXX_Call) Run(run func(ctx context.Context, key string, members ...Z)) *MockPipeliner_ZAddXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]Z, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(Z)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZAddXX_Call) Return(_a0 *IntCmd) *MockPipeliner_ZAddXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZAddXX_Call) RunAndReturn(run func(context.Context, string, ...Z) *IntCmd) *MockPipeliner_ZAddXX_Call {
	_c.Call.Return(run)
	return _c
}

// ZCard provides a mock function with given fields: ctx, key
func (_m *MockPipeliner) ZCard(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ZCard")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZCard'
type MockPipeliner_ZCard_Call struct {
	*mock.Call
}

// ZCard is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockPipeliner_Expecter) ZCard(ctx interface{}, key interface{}) *MockPipeliner_ZCard_Call {
	return &MockPipeliner_ZCard_Call{Call: _e.mock.On("ZCard", ctx, key)}
}

func (_c *MockPipeliner_ZCard_Call) Run(run func(ctx context.Context, key string)) *MockPipeliner_ZCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZCard_Call) Return(_a0 *IntCmd) *MockPipeliner_ZCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZCard_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockPipeliner_ZCard_Call {
	_c.Call.Return(run)
	return _c
}

// ZCount provides a mock function with given fields: ctx, key, min, max
func (_m *MockPipeliner) ZCount(ctx context.Context, key string, min string, max string) *IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZCount'
type MockPipeliner_ZCount_Call struct {
	*mock.Call
}

// ZCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockPipeliner_Expecter) ZCount(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockPipeliner_ZCount_Call {
	return &MockPipeliner_ZCount_Call{Call: _e.mock.On("ZCount", ctx, key, min, max)}
}

func (_c *MockPipeliner_ZCount_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockPipeliner_ZCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZCount_Call) Return(_a0 *IntCmd) *MockPipeliner_ZCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZCount_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_ZCount_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiff provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) ZDiff(ctx context.Context, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiff")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiff'
type MockPipeliner_ZDiff_Call struct {
	*mock.Call
}

// ZDiff is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) ZDiff(ctx interface{}, keys ...interface{}) *MockPipeliner_ZDiff_Call {
	return &MockPipeliner_ZDiff_Call{Call: _e.mock.On("ZDiff",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_ZDiff_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_ZDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZDiff_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZDiff_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZDiff_Call) RunAndReturn(run func(context.Context, ...string) *StringSliceCmd) *MockPipeliner_ZDiff_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiffStore provides a mock function with given fields: ctx, destination, keys
func (_m *MockPipeliner) ZDiffStore(ctx context.Context, destination string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZDiffStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiffStore'
type MockPipeliner_ZDiffStore_Call struct {
	*mock.Call
}

// ZDiffStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - keys ...string
func (_e *MockPipeliner_Expecter) ZDiffStore(ctx interface{}, destination interface{}, keys ...interface{}) *MockPipeliner_ZDiffStore_Call {
	return &MockPipeliner_ZDiffStore_Call{Call: _e.mock.On("ZDiffStore",
		append([]interface{}{ctx, destination}, keys...)...)}
}

func (_c *MockPipeliner_ZDiffStore_Call) Run(run func(ctx context.Context, destination string, keys ...string)) *MockPipeliner_ZDiffStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZDiffStore_Call) Return(_a0 *IntCmd) *MockPipeliner_ZDiffStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZDiffStore_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockPipeliner_ZDiffStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZDiffWithScores provides a mock function with given fields: ctx, keys
func (_m *MockPipeliner) ZDiffWithScores(ctx context.Context, keys ...string) *ZSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZDiffWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *ZSliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZDiffWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZDiffWithScores'
type MockPipeliner_ZDiffWithScores_Call struct {
	*mock.Call
}

// ZDiffWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockPipeliner_Expecter) ZDiffWithScores(ctx interface{}, keys ...interface{}) *MockPipeliner_ZDiffWithScores_Call {
	return &MockPipeliner_ZDiffWithScores_Call{Call: _e.mock.On("ZDiffWithScores",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockPipeliner_ZDiffWithScores_Call) Run(run func(ctx context.Context, keys ...string)) *MockPipeliner_ZDiffWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZDiffWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZDiffWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZDiffWithScores_Call) RunAndReturn(run func(context.Context, ...string) *ZSliceCmd) *MockPipeliner_ZDiffWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZIncrBy provides a mock function with given fields: ctx, key, increment, member
func (_m *MockPipeliner) ZIncrBy(ctx context.Context, key string, increment float64, member string) *FloatCmd {
	ret := _m.Called(ctx, key, increment, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrBy")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, string) *FloatCmd); ok {
		r0 = rf(ctx, key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_ZIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZIncrBy'
type MockPipeliner_ZIncrBy_Call struct {
	*mock.Call
}

// ZIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - increment float64
//   - member string
func (_e *MockPipeliner_Expecter) ZIncrBy(ctx interface{}, key interface{}, increment interface{}, member interface{}) *MockPipeliner_ZIncrBy_Call {
	return &MockPipeliner_ZIncrBy_Call{Call: _e.mock.On("ZIncrBy", ctx, key, increment, member)}
}

func (_c *MockPipeliner_ZIncrBy_Call) Run(run func(ctx context.Context, key string, increment float64, member string)) *MockPipeliner_ZIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZIncrBy_Call) Return(_a0 *FloatCmd) *MockPipeliner_ZIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZIncrBy_Call) RunAndReturn(run func(context.Context, string, float64, string) *FloatCmd) *MockPipeliner_ZIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// ZInter provides a mock function with given fields: ctx, store
func (_m *MockPipeliner) ZInter(ctx context.Context, store *ZStore) *StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInter")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *ZStore) *StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZInter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInter'
type MockPipeliner_ZInter_Call struct {
	*mock.Call
}

// ZInter is a helper method to define mock.On call
//   - ctx context.Context
//   - store *ZStore
func (_e *MockPipeliner_Expecter) ZInter(ctx interface{}, store interface{}) *MockPipeliner_ZInter_Call {
	return &MockPipeliner_ZInter_Call{Call: _e.mock.On("ZInter", ctx, store)}
}

func (_c *MockPipeliner_ZInter_Call) Run(run func(ctx context.Context, store *ZStore)) *MockPipeliner_ZInter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZInter_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZInter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZInter_Call) RunAndReturn(run func(context.Context, *ZStore) *StringSliceCmd) *MockPipeliner_ZInter_Call {
	_c.Call.Return(run)
	return _c
}

// ZInterCard provides a mock function with given fields: ctx, limit, keys
func (_m *MockPipeliner) ZInterCard(ctx context.Context, limit int64, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZInterCard")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64, ...string) *IntCmd); ok {
		r0 = rf(ctx, limit, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZInterCard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInterCard'
type MockPipeliner_ZInterCard_Call struct {
	*mock.Call
}

// ZInterCard is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) ZInterCard(ctx interface{}, limit interface{}, keys ...interface{}) *MockPipeliner_ZInterCard_Call {
	return &MockPipeliner_ZInterCard_Call{Call: _e.mock.On("ZInterCard",
		append([]interface{}{ctx, limit}, keys...)...)}
}

func (_c *MockPipeliner_ZInterCard_Call) Run(run func(ctx context.Context, limit int64, keys ...string)) *MockPipeliner_ZInterCard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZInterCard_Call) Return(_a0 *IntCmd) *MockPipeliner_ZInterCard_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZInterCard_Call) RunAndReturn(run func(context.Context, int64, ...string) *IntCmd) *MockPipeliner_ZInterCard_Call {
	_c.Call.Return(run)
	return _c
}

// ZInterStore provides a mock function with given fields: ctx, destination, store
func (_m *MockPipeliner) ZInterStore(ctx context.Context, destination string, store *ZStore) *IntCmd {
	ret := _m.Called(ctx, destination, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZStore) *IntCmd); ok {
		r0 = rf(ctx, destination, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZInterStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInterStore'
type MockPipeliner_ZInterStore_Call struct {
	*mock.Call
}

// ZInterStore is a helper method to define mock.On call
//   - ctx context.Context
//   - destination string
//   - store *ZStore
func (_e *MockPipeliner_Expecter) ZInterStore(ctx interface{}, destination interface{}, store interface{}) *MockPipeliner_ZInterStore_Call {
	return &MockPipeliner_ZInterStore_Call{Call: _e.mock.On("ZInterStore", ctx, destination, store)}
}

func (_c *MockPipeliner_ZInterStore_Call) Run(run func(ctx context.Context, destination string, store *ZStore)) *MockPipeliner_ZInterStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZInterStore_Call) Return(_a0 *IntCmd) *MockPipeliner_ZInterStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZInterStore_Call) RunAndReturn(run func(context.Context, string, *ZStore) *IntCmd) *MockPipeliner_ZInterStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZInterWithScores provides a mock function with given fields: ctx, store
func (_m *MockPipeliner) ZInterWithScores(ctx context.Context, store *ZStore) *ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZInterWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *ZStore) *ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZInterWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZInterWithScores'
type MockPipeliner_ZInterWithScores_Call struct {
	*mock.Call
}

// ZInterWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - store *ZStore
func (_e *MockPipeliner_Expecter) ZInterWithScores(ctx interface{}, store interface{}) *MockPipeliner_ZInterWithScores_Call {
	return &MockPipeliner_ZInterWithScores_Call{Call: _e.mock.On("ZInterWithScores", ctx, store)}
}

func (_c *MockPipeliner_ZInterWithScores_Call) Run(run func(ctx context.Context, store *ZStore)) *MockPipeliner_ZInterWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZInterWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZInterWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZInterWithScores_Call) RunAndReturn(run func(context.Context, *ZStore) *ZSliceCmd) *MockPipeliner_ZInterWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZLexCount provides a mock function with given fields: ctx, key, min, max
func (_m *MockPipeliner) ZLexCount(ctx context.Context, key string, min string, max string) *IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZLexCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZLexCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZLexCount'
type MockPipeliner_ZLexCount_Call struct {
	*mock.Call
}

// ZLexCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockPipeliner_Expecter) ZLexCount(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockPipeliner_ZLexCount_Call {
	return &MockPipeliner_ZLexCount_Call{Call: _e.mock.On("ZLexCount", ctx, key, min, max)}
}

func (_c *MockPipeliner_ZLexCount_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockPipeliner_ZLexCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZLexCount_Call) Return(_a0 *IntCmd) *MockPipeliner_ZLexCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZLexCount_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_ZLexCount_Call {
	_c.Call.Return(run)
	return _c
}

// ZMPop provides a mock function with given fields: ctx, order, count, keys
func (_m *MockPipeliner) ZMPop(ctx context.Context, order string, count int64, keys ...string) *ZSliceWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, order, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMPop")
	}

	var r0 *ZSliceWithKeyCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...string) *ZSliceWithKeyCmd); ok {
		r0 = rf(ctx, order, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceWithKeyCmd)
		}
	}

	return r0
}

// MockPipeliner_ZMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZMPop'
type MockPipeliner_ZMPop_Call struct {
	*mock.Call
}

// ZMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - order string
//   - count int64
//   - keys ...string
func (_e *MockPipeliner_Expecter) ZMPop(ctx interface{}, order interface{}, count interface{}, keys ...interface{}) *MockPipeliner_ZMPop_Call {
	return &MockPipeliner_ZMPop_Call{Call: _e.mock.On("ZMPop",
		append([]interface{}{ctx, order, count}, keys...)...)}
}

func (_c *MockPipeliner_ZMPop_Call) Run(run func(ctx context.Context, order string, count int64, keys ...string)) *MockPipeliner_ZMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZMPop_Call) Return(_a0 *ZSliceWithKeyCmd) *MockPipeliner_ZMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZMPop_Call) RunAndReturn(run func(context.Context, string, int64, ...string) *ZSliceWithKeyCmd) *MockPipeliner_ZMPop_Call {
	_c.Call.Return(run)
	return _c
}

// ZMScore provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZMScore(ctx context.Context, key string, members ...string) *FloatSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZMScore")
	}

	var r0 *FloatSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *FloatSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZMScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZMScore'
type MockPipeliner_ZMScore_Call struct {
	*mock.Call
}

// ZMScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockPipeliner_Expecter) ZMScore(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZMScore_Call {
	return &MockPipeliner_ZMScore_Call{Call: _e.mock.On("ZMScore",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZMScore_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockPipeliner_ZMScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZMScore_Call) Return(_a0 *FloatSliceCmd) *MockPipeliner_ZMScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZMScore_Call) RunAndReturn(run func(context.Context, string, ...string) *FloatSliceCmd) *MockPipeliner_ZMScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZPopMax provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) ZPopMax(ctx context.Context, key string, count ...int64) *ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMax")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZPopMax_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZPopMax'
type MockPipeliner_ZPopMax_Call struct {
	*mock.Call
}

// ZPopMax is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count ...int64
func (_e *MockPipeliner_Expecter) ZPopMax(ctx interface{}, key interface{}, count ...interface{}) *MockPipeliner_ZPopMax_Call {
	return &MockPipeliner_ZPopMax_Call{Call: _e.mock.On("ZPopMax",
		append([]interface{}{ctx, key}, count...)...)}
}

func (_c *MockPipeliner_ZPopMax_Call) Run(run func(ctx context.Context, key string, count ...int64)) *MockPipeliner_ZPopMax_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZPopMax_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZPopMax_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZPopMax_Call) RunAndReturn(run func(context.Context, string, ...int64) *ZSliceCmd) *MockPipeliner_ZPopMax_Call {
	_c.Call.Return(run)
	return _c
}

// ZPopMin provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) ZPopMin(ctx context.Context, key string, count ...int64) *ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMin")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...int64) *ZSliceCmd); ok {
		r0 = rf(ctx, key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZPopMin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZPopMin'
type MockPipeliner_ZPopMin_Call struct {
	*mock.Call
}

// ZPopMin is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count ...int64
func (_e *MockPipeliner_Expecter) ZPopMin(ctx interface{}, key interface{}, count ...interface{}) *MockPipeliner_ZPopMin_Call {
	return &MockPipeliner_ZPopMin_Call{Call: _e.mock.On("ZPopMin",
		append([]interface{}{ctx, key}, count...)...)}
}

func (_c *MockPipeliner_ZPopMin_Call) Run(run func(ctx context.Context, key string, count ...int64)) *MockPipeliner_ZPopMin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZPopMin_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZPopMin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZPopMin_Call) RunAndReturn(run func(context.Context, string, ...int64) *ZSliceCmd) *MockPipeliner_ZPopMin_Call {
	_c.Call.Return(run)
	return _c
}

// ZRandMember provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) ZRandMember(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMember")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRandMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRandMember'
type MockPipeliner_ZRandMember_Call struct {
	*mock.Call
}

// ZRandMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) ZRandMember(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_ZRandMember_Call {
	return &MockPipeliner_ZRandMember_Call{Call: _e.mock.On("ZRandMember", ctx, key, count)}
}

func (_c *MockPipeliner_ZRandMember_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_ZRandMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_ZRandMember_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRandMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRandMember_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockPipeliner_ZRandMember_Call {
	_c.Call.Return(run)
	return _c
}

// ZRandMemberWithScores provides a mock function with given fields: ctx, key, count
func (_m *MockPipeliner) ZRandMemberWithScores(ctx context.Context, key string, count int) *ZSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for ZRandMemberWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *ZSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRandMemberWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRandMemberWithScores'
type MockPipeliner_ZRandMemberWithScores_Call struct {
	*mock.Call
}

// ZRandMemberWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockPipeliner_Expecter) ZRandMemberWithScores(ctx interface{}, key interface{}, count interface{}) *MockPipeliner_ZRandMemberWithScores_Call {
	return &MockPipeliner_ZRandMemberWithScores_Call{Call: _e.mock.On("ZRandMemberWithScores", ctx, key, count)}
}

func (_c *MockPipeliner_ZRandMemberWithScores_Call) Run(run func(ctx context.Context, key string, count int)) *MockPipeliner_ZRandMemberWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockPipeliner_ZRandMemberWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRandMemberWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRandMemberWithScores_Call) RunAndReturn(run func(context.Context, string, int) *ZSliceCmd) *MockPipeliner_ZRandMemberWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) ZRange(ctx context.Context, key string, start int64, stop int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRange")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRange'
type MockPipeliner_ZRange_Call struct {
	*mock.Call
}

// ZRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) ZRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_ZRange_Call {
	return &MockPipeliner_ZRange_Call{Call: _e.mock.On("ZRange", ctx, key, start, stop)}
}

func (_c *MockPipeliner_ZRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_ZRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZRange_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringSliceCmd) *MockPipeliner_ZRange_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeArgs provides a mock function with given fields: ctx, z
func (_m *MockPipeliner) ZRangeArgs(ctx context.Context, z ZRangeArgs) *StringSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgs")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ZRangeArgs) *StringSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeArgs'
type MockPipeliner_ZRangeArgs_Call struct {
	*mock.Call
}

// ZRangeArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - z ZRangeArgs
func (_e *MockPipeliner_Expecter) ZRangeArgs(ctx interface{}, z interface{}) *MockPipeliner_ZRangeArgs_Call {
	return &MockPipeliner_ZRangeArgs_Call{Call: _e.mock.On("ZRangeArgs", ctx, z)}
}

func (_c *MockPipeliner_ZRangeArgs_Call) Run(run func(ctx context.Context, z ZRangeArgs)) *MockPipeliner_ZRangeArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ZRangeArgs))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeArgs_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRangeArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeArgs_Call) RunAndReturn(run func(context.Context, ZRangeArgs) *StringSliceCmd) *MockPipeliner_ZRangeArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeArgsWithScores provides a mock function with given fields: ctx, z
func (_m *MockPipeliner) ZRangeArgsWithScores(ctx context.Context, z ZRangeArgs) *ZSliceCmd {
	ret := _m.Called(ctx, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeArgsWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ZRangeArgs) *ZSliceCmd); ok {
		r0 = rf(ctx, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeArgsWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeArgsWithScores'
type MockPipeliner_ZRangeArgsWithScores_Call struct {
	*mock.Call
}

// ZRangeArgsWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - z ZRangeArgs
func (_e *MockPipeliner_Expecter) ZRangeArgsWithScores(ctx interface{}, z interface{}) *MockPipeliner_ZRangeArgsWithScores_Call {
	return &MockPipeliner_ZRangeArgsWithScores_Call{Call: _e.mock.On("ZRangeArgsWithScores", ctx, z)}
}

func (_c *MockPipeliner_ZRangeArgsWithScores_Call) Run(run func(ctx context.Context, z ZRangeArgs)) *MockPipeliner_ZRangeArgsWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ZRangeArgs))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeArgsWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRangeArgsWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeArgsWithScores_Call) RunAndReturn(run func(context.Context, ZRangeArgs) *ZSliceCmd) *MockPipeliner_ZRangeArgsWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByLex")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByLex'
type MockPipeliner_ZRangeByLex_Call struct {
	*mock.Call
}

// ZRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRangeByLex(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRangeByLex_Call {
	return &MockPipeliner_ZRangeByLex_Call{Call: _e.mock.On("ZRangeByLex", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRangeByLex_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeByLex_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeByLex_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *StringSliceCmd) *MockPipeliner_ZRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScore")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByScore'
type MockPipeliner_ZRangeByScore_Call struct {
	*mock.Call
}

// ZRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRangeByScore(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRangeByScore_Call {
	return &MockPipeliner_ZRangeByScore_Call{Call: _e.mock.On("ZRangeByScore", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRangeByScore_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeByScore_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeByScore_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *StringSliceCmd) *MockPipeliner_ZRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScoreWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeByScoreWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeByScoreWithScores'
type MockPipeliner_ZRangeByScoreWithScores_Call struct {
	*mock.Call
}

// ZRangeByScoreWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRangeByScoreWithScores(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRangeByScoreWithScores_Call {
	return &MockPipeliner_ZRangeByScoreWithScores_Call{Call: _e.mock.On("ZRangeByScoreWithScores", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRangeByScoreWithScores_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRangeByScoreWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeByScoreWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRangeByScoreWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeByScoreWithScores_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *ZSliceCmd) *MockPipeliner_ZRangeByScoreWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeStore provides a mock function with given fields: ctx, dst, z
func (_m *MockPipeliner) ZRangeStore(ctx context.Context, dst string, z ZRangeArgs) *IntCmd {
	ret := _m.Called(ctx, dst, z)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ZRangeArgs) *IntCmd); ok {
		r0 = rf(ctx, dst, z)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeStore'
type MockPipeliner_ZRangeStore_Call struct {
	*mock.Call
}

// ZRangeStore is a helper method to define mock.On call
//   - ctx context.Context
//   - dst string
//   - z ZRangeArgs
func (_e *MockPipeliner_Expecter) ZRangeStore(ctx interface{}, dst interface{}, z interface{}) *MockPipeliner_ZRangeStore_Call {
	return &MockPipeliner_ZRangeStore_Call{Call: _e.mock.On("ZRangeStore", ctx, dst, z)}
}

func (_c *MockPipeliner_ZRangeStore_Call) Run(run func(ctx context.Context, dst string, z ZRangeArgs)) *MockPipeliner_ZRangeStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(ZRangeArgs))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeStore_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRangeStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeStore_Call) RunAndReturn(run func(context.Context, string, ZRangeArgs) *IntCmd) *MockPipeliner_ZRangeStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRangeWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRangeWithScores'
type MockPipeliner_ZRangeWithScores_Call struct {
	*mock.Call
}

// ZRangeWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) ZRangeWithScores(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_ZRangeWithScores_Call {
	return &MockPipeliner_ZRangeWithScores_Call{Call: _e.mock.On("ZRangeWithScores", ctx, key, start, stop)}
}

func (_c *MockPipeliner_ZRangeWithScores_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_ZRangeWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZRangeWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRangeWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRangeWithScores_Call) RunAndReturn(run func(context.Context, string, int64, int64) *ZSliceCmd) *MockPipeliner_ZRangeWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRank provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) ZRank(ctx context.Context, key string, member string) *IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRank")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRank'
type MockPipeliner_ZRank_Call struct {
	*mock.Call
}

// ZRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockPipeliner_Expecter) ZRank(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_ZRank_Call {
	return &MockPipeliner_ZRank_Call{Call: _e.mock.On("ZRank", ctx, key, member)}
}

func (_c *MockPipeliner_ZRank_Call) Run(run func(ctx context.Context, key string, member string)) *MockPipeliner_ZRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRank_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRank_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_ZRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZRankWithScore provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) ZRankWithScore(ctx context.Context, key string, member string) *RankWithScoreCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRankWithScore")
	}

	var r0 *RankWithScoreCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *RankWithScoreCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*RankWithScoreCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRankWithScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRankWithScore'
type MockPipeliner_ZRankWithScore_Call struct {
	*mock.Call
}

// ZRankWithScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockPipeliner_Expecter) ZRankWithScore(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_ZRankWithScore_Call {
	return &MockPipeliner_ZRankWithScore_Call{Call: _e.mock.On("ZRankWithScore", ctx, key, member)}
}

func (_c *MockPipeliner_ZRankWithScore_Call) Run(run func(ctx context.Context, key string, member string)) *MockPipeliner_ZRankWithScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRankWithScore_Call) Return(_a0 *RankWithScoreCmd) *MockPipeliner_ZRankWithScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRankWithScore_Call) RunAndReturn(run func(context.Context, string, string) *RankWithScoreCmd) *MockPipeliner_ZRankWithScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRem provides a mock function with given fields: ctx, key, members
func (_m *MockPipeliner) ZRem(ctx context.Context, key string, members ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZRem")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRem'
type MockPipeliner_ZRem_Call struct {
	*mock.Call
}

// ZRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...interface{}
func (_e *MockPipeliner_Expecter) ZRem(ctx interface{}, key interface{}, members ...interface{}) *MockPipeliner_ZRem_Call {
	return &MockPipeliner_ZRem_Call{Call: _e.mock.On("ZRem",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockPipeliner_ZRem_Call) Run(run func(ctx context.Context, key string, members ...interface{})) *MockPipeliner_ZRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockPipeliner_ZRem_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRem_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockPipeliner_ZRem_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByLex provides a mock function with given fields: ctx, key, min, max
func (_m *MockPipeliner) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByLex")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRemRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByLex'
type MockPipeliner_ZRemRangeByLex_Call struct {
	*mock.Call
}

// ZRemRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockPipeliner_Expecter) ZRemRangeByLex(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockPipeliner_ZRemRangeByLex_Call {
	return &MockPipeliner_ZRemRangeByLex_Call{Call: _e.mock.On("ZRemRangeByLex", ctx, key, min, max)}
}

func (_c *MockPipeliner_ZRemRangeByLex_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockPipeliner_ZRemRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRemRangeByLex_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRemRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRemRangeByLex_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_ZRemRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByRank provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *IntCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByRank")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *IntCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRemRangeByRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByRank'
type MockPipeliner_ZRemRangeByRank_Call struct {
	*mock.Call
}

// ZRemRangeByRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) ZRemRangeByRank(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_ZRemRangeByRank_Call {
	return &MockPipeliner_ZRemRangeByRank_Call{Call: _e.mock.On("ZRemRangeByRank", ctx, key, start, stop)}
}

func (_c *MockPipeliner_ZRemRangeByRank_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_ZRemRangeByRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZRemRangeByRank_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRemRangeByRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRemRangeByRank_Call) RunAndReturn(run func(context.Context, string, int64, int64) *IntCmd) *MockPipeliner_ZRemRangeByRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZRemRangeByScore provides a mock function with given fields: ctx, key, min, max
func (_m *MockPipeliner) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *IntCmd {
	ret := _m.Called(ctx, key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByScore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRemRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRemRangeByScore'
type MockPipeliner_ZRemRangeByScore_Call struct {
	*mock.Call
}

// ZRemRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - min string
//   - max string
func (_e *MockPipeliner_Expecter) ZRemRangeByScore(ctx interface{}, key interface{}, min interface{}, max interface{}) *MockPipeliner_ZRemRangeByScore_Call {
	return &MockPipeliner_ZRemRangeByScore_Call{Call: _e.mock.On("ZRemRangeByScore", ctx, key, min, max)}
}

func (_c *MockPipeliner_ZRemRangeByScore_Call) Run(run func(ctx context.Context, key string, min string, max string)) *MockPipeliner_ZRemRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRemRangeByScore_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRemRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRemRangeByScore_Call) RunAndReturn(run func(context.Context, string, string, string) *IntCmd) *MockPipeliner_ZRemRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) ZRevRange(ctx context.Context, key string, start int64, stop int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRange")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRange'
type MockPipeliner_ZRevRange_Call struct {
	*mock.Call
}

// ZRevRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) ZRevRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_ZRevRange_Call {
	return &MockPipeliner_ZRevRange_Call{Call: _e.mock.On("ZRevRange", ctx, key, start, stop)}
}

func (_c *MockPipeliner_ZRevRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_ZRevRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRange_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRevRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringSliceCmd) *MockPipeliner_ZRevRange_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByLex provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRevRangeByLex(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByLex")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRangeByLex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByLex'
type MockPipeliner_ZRevRangeByLex_Call struct {
	*mock.Call
}

// ZRevRangeByLex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRevRangeByLex(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRevRangeByLex_Call {
	return &MockPipeliner_ZRevRangeByLex_Call{Call: _e.mock.On("ZRevRangeByLex", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRevRangeByLex_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRevRangeByLex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRangeByLex_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRevRangeByLex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRangeByLex_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *StringSliceCmd) *MockPipeliner_ZRevRangeByLex_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByScore provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRevRangeByScore(ctx context.Context, key string, opt *ZRangeBy) *StringSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScore")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *StringSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRangeByScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByScore'
type MockPipeliner_ZRevRangeByScore_Call struct {
	*mock.Call
}

// ZRevRangeByScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRevRangeByScore(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRevRangeByScore_Call {
	return &MockPipeliner_ZRevRangeByScore_Call{Call: _e.mock.On("ZRevRangeByScore", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRevRangeByScore_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRevRangeByScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRangeByScore_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZRevRangeByScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRangeByScore_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *StringSliceCmd) *MockPipeliner_ZRevRangeByScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: ctx, key, opt
func (_m *MockPipeliner) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *ZRangeBy) *ZSliceCmd {
	ret := _m.Called(ctx, key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScoreWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZRangeBy) *ZSliceCmd); ok {
		r0 = rf(ctx, key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRangeByScoreWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeByScoreWithScores'
type MockPipeliner_ZRevRangeByScoreWithScores_Call struct {
	*mock.Call
}

// ZRevRangeByScoreWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - opt *ZRangeBy
func (_e *MockPipeliner_Expecter) ZRevRangeByScoreWithScores(ctx interface{}, key interface{}, opt interface{}) *MockPipeliner_ZRevRangeByScoreWithScores_Call {
	return &MockPipeliner_ZRevRangeByScoreWithScores_Call{Call: _e.mock.On("ZRevRangeByScoreWithScores", ctx, key, opt)}
}

func (_c *MockPipeliner_ZRevRangeByScoreWithScores_Call) Run(run func(ctx context.Context, key string, opt *ZRangeBy)) *MockPipeliner_ZRevRangeByScoreWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZRangeBy))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRangeByScoreWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRevRangeByScoreWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRangeByScoreWithScores_Call) RunAndReturn(run func(context.Context, string, *ZRangeBy) *ZSliceCmd) *MockPipeliner_ZRevRangeByScoreWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRangeWithScores provides a mock function with given fields: ctx, key, start, stop
func (_m *MockPipeliner) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *ZSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *ZSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRangeWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRangeWithScores'
type MockPipeliner_ZRevRangeWithScores_Call struct {
	*mock.Call
}

// ZRevRangeWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockPipeliner_Expecter) ZRevRangeWithScores(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockPipeliner_ZRevRangeWithScores_Call {
	return &MockPipeliner_ZRevRangeWithScores_Call{Call: _e.mock.On("ZRevRangeWithScores", ctx, key, start, stop)}
}

func (_c *MockPipeliner_ZRevRangeWithScores_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockPipeliner_ZRevRangeWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRangeWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZRevRangeWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRangeWithScores_Call) RunAndReturn(run func(context.Context, string, int64, int64) *ZSliceCmd) *MockPipeliner_ZRevRangeWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRank provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) ZRevRank(ctx context.Context, key string, member string) *IntCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRank")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRank_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRank'
type MockPipeliner_ZRevRank_Call struct {
	*mock.Call
}

// ZRevRank is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockPipeliner_Expecter) ZRevRank(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_ZRevRank_Call {
	return &MockPipeliner_ZRevRank_Call{Call: _e.mock.On("ZRevRank", ctx, key, member)}
}

func (_c *MockPipeliner_ZRevRank_Call) Run(run func(ctx context.Context, key string, member string)) *MockPipeliner_ZRevRank_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRank_Call) Return(_a0 *IntCmd) *MockPipeliner_ZRevRank_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRank_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockPipeliner_ZRevRank_Call {
	_c.Call.Return(run)
	return _c
}

// ZRevRankWithScore provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) ZRevRankWithScore(ctx context.Context, key string, member string) *RankWithScoreCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRankWithScore")
	}

	var r0 *RankWithScoreCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *RankWithScoreCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*RankWithScoreCmd)
		}
	}

	return r0
}

// MockPipeliner_ZRevRankWithScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZRevRankWithScore'
type MockPipeliner_ZRevRankWithScore_Call struct {
	*mock.Call
}

// ZRevRankWithScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockPipeliner_Expecter) ZRevRankWithScore(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_ZRevRankWithScore_Call {
	return &MockPipeliner_ZRevRankWithScore_Call{Call: _e.mock.On("ZRevRankWithScore", ctx, key, member)}
}

func (_c *MockPipeliner_ZRevRankWithScore_Call) Run(run func(ctx context.Context, key string, member string)) *MockPipeliner_ZRevRankWithScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZRevRankWithScore_Call) Return(_a0 *RankWithScoreCmd) *MockPipeliner_ZRevRankWithScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZRevRankWithScore_Call) RunAndReturn(run func(context.Context, string, string) *RankWithScoreCmd) *MockPipeliner_ZRevRankWithScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockPipeliner) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for ZScan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockPipeliner_ZScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZScan'
type MockPipeliner_ZScan_Call struct {
	*mock.Call
}

// ZScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockPipeliner_Expecter) ZScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockPipeliner_ZScan_Call {
	return &MockPipeliner_ZScan_Call{Call: _e.mock.On("ZScan", ctx, key, cursor, match, count)}
}

func (_c *MockPipeliner_ZScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockPipeliner_ZScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockPipeliner_ZScan_Call) Return(_a0 *ScanCmd) *MockPipeliner_ZScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockPipeliner_ZScan_Call {
	_c.Call.Return(run)
	return _c
}

// ZScore provides a mock function with given fields: ctx, key, member
func (_m *MockPipeliner) ZScore(ctx context.Context, key string, member string) *FloatCmd {
	ret := _m.Called(ctx, key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZScore")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *FloatCmd); ok {
		r0 = rf(ctx, key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockPipeliner_ZScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZScore'
type MockPipeliner_ZScore_Call struct {
	*mock.Call
}

// ZScore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
func (_e *MockPipeliner_Expecter) ZScore(ctx interface{}, key interface{}, member interface{}) *MockPipeliner_ZScore_Call {
	return &MockPipeliner_ZScore_Call{Call: _e.mock.On("ZScore", ctx, key, member)}
}

func (_c *MockPipeliner_ZScore_Call) Run(run func(ctx context.Context, key string, member string)) *MockPipeliner_ZScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockPipeliner_ZScore_Call) Return(_a0 *FloatCmd) *MockPipeliner_ZScore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZScore_Call) RunAndReturn(run func(context.Context, string, string) *FloatCmd) *MockPipeliner_ZScore_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnion provides a mock function with given fields: ctx, store
func (_m *MockPipeliner) ZUnion(ctx context.Context, store ZStore) *StringSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnion")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ZStore) *StringSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZUnion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnion'
type MockPipeliner_ZUnion_Call struct {
	*mock.Call
}

// ZUnion is a helper method to define mock.On call
//   - ctx context.Context
//   - store ZStore
func (_e *MockPipeliner_Expecter) ZUnion(ctx interface{}, store interface{}) *MockPipeliner_ZUnion_Call {
	return &MockPipeliner_ZUnion_Call{Call: _e.mock.On("ZUnion", ctx, store)}
}

func (_c *MockPipeliner_ZUnion_Call) Run(run func(ctx context.Context, store ZStore)) *MockPipeliner_ZUnion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZUnion_Call) Return(_a0 *StringSliceCmd) *MockPipeliner_ZUnion_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZUnion_Call) RunAndReturn(run func(context.Context, ZStore) *StringSliceCmd) *MockPipeliner_ZUnion_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnionStore provides a mock function with given fields: ctx, dest, store
func (_m *MockPipeliner) ZUnionStore(ctx context.Context, dest string, store *ZStore) *IntCmd {
	ret := _m.Called(ctx, dest, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *ZStore) *IntCmd); ok {
		r0 = rf(ctx, dest, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPipeliner_ZUnionStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnionStore'
type MockPipeliner_ZUnionStore_Call struct {
	*mock.Call
}

// ZUnionStore is a helper method to define mock.On call
//   - ctx context.Context
//   - dest string
//   - store *ZStore
func (_e *MockPipeliner_Expecter) ZUnionStore(ctx interface{}, dest interface{}, store interface{}) *MockPipeliner_ZUnionStore_Call {
	return &MockPipeliner_ZUnionStore_Call{Call: _e.mock.On("ZUnionStore", ctx, dest, store)}
}

func (_c *MockPipeliner_ZUnionStore_Call) Run(run func(ctx context.Context, dest string, store *ZStore)) *MockPipeliner_ZUnionStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZUnionStore_Call) Return(_a0 *IntCmd) *MockPipeliner_ZUnionStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZUnionStore_Call) RunAndReturn(run func(context.Context, string, *ZStore) *IntCmd) *MockPipeliner_ZUnionStore_Call {
	_c.Call.Return(run)
	return _c
}

// ZUnionWithScores provides a mock function with given fields: ctx, store
func (_m *MockPipeliner) ZUnionWithScores(ctx context.Context, store ZStore) *ZSliceCmd {
	ret := _m.Called(ctx, store)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionWithScores")
	}

	var r0 *ZSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ZStore) *ZSliceCmd); ok {
		r0 = rf(ctx, store)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ZSliceCmd)
		}
	}

	return r0
}

// MockPipeliner_ZUnionWithScores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ZUnionWithScores'
type MockPipeliner_ZUnionWithScores_Call struct {
	*mock.Call
}

// ZUnionWithScores is a helper method to define mock.On call
//   - ctx context.Context
//   - store ZStore
func (_e *MockPipeliner_Expecter) ZUnionWithScores(ctx interface{}, store interface{}) *MockPipeliner_ZUnionWithScores_Call {
	return &MockPipeliner_ZUnionWithScores_Call{Call: _e.mock.On("ZUnionWithScores", ctx, store)}
}

func (_c *MockPipeliner_ZUnionWithScores_Call) Run(run func(ctx context.Context, store ZStore)) *MockPipeliner_ZUnionWithScores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(ZStore))
	})
	return _c
}

func (_c *MockPipeliner_ZUnionWithScores_Call) Return(_a0 *ZSliceCmd) *MockPipeliner_ZUnionWithScores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPipeliner_ZUnionWithScores_Call) RunAndReturn(run func(context.Context, ZStore) *ZSliceCmd) *MockPipeliner_ZUnionWithScores_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPipeliner creates a new instance of MockPipeliner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPipeliner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPipeliner {
	mock := &MockPipeliner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
