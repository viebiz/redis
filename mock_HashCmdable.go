// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockHashCmdable is an autogenerated mock type for the HashCmdable type
type MockHashCmdable struct {
	mock.Mock
}

type MockHashCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockHashCmdable) EXPECT() *MockHashCmdable_Expecter {
	return &MockHashCmdable_Expecter{mock: &_m.Mock}
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HDel(ctx context.Context, key string, fields ...string) *IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockHashCmdable_HDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HDel'
type MockHashCmdable_HDel_Call struct {
	*mock.Call
}

// HDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HDel(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HDel_Call {
	return &MockHashCmdable_HDel_Call{Call: _e.mock.On("HDel",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HDel_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HDel_Call) Return(_a0 *IntCmd) *MockHashCmdable_HDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HDel_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockHashCmdable_HDel_Call {
	_c.Call.Return(run)
	return _c
}

// HExists provides a mock function with given fields: ctx, key, field
func (_m *MockHashCmdable) HExists(ctx context.Context, key string, field string) *BoolCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *BoolCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExists'
type MockHashCmdable_HExists_Call struct {
	*mock.Call
}

// HExists is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockHashCmdable_Expecter) HExists(ctx interface{}, key interface{}, field interface{}) *MockHashCmdable_HExists_Call {
	return &MockHashCmdable_HExists_Call{Call: _e.mock.On("HExists", ctx, key, field)}
}

func (_c *MockHashCmdable_HExists_Call) Run(run func(ctx context.Context, key string, field string)) *MockHashCmdable_HExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HExists_Call) Return(_a0 *BoolCmd) *MockHashCmdable_HExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExists_Call) RunAndReturn(run func(context.Context, string, string) *BoolCmd) *MockHashCmdable_HExists_Call {
	_c.Call.Return(run)
	return _c
}

// HExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *MockHashCmdable) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpire")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpire'
type MockHashCmdable_HExpire_Call struct {
	*mock.Call
}

// HExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HExpire(ctx interface{}, key interface{}, expiration interface{}, fields ...interface{}) *MockHashCmdable_HExpire_Call {
	return &MockHashCmdable_HExpire_Call{Call: _e.mock.On("HExpire",
		append([]interface{}{ctx, key, expiration}, fields...)...)}
}

func (_c *MockHashCmdable_HExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, fields ...string)) *MockHashCmdable_HExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HExpire_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration, ...string) *IntSliceCmd) *MockHashCmdable_HExpire_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *MockHashCmdable) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAt")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireAt'
type MockHashCmdable_HExpireAt_Call struct {
	*mock.Call
}

// HExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HExpireAt(ctx interface{}, key interface{}, tm interface{}, fields ...interface{}) *MockHashCmdable_HExpireAt_Call {
	return &MockHashCmdable_HExpireAt_Call{Call: _e.mock.On("HExpireAt",
		append([]interface{}{ctx, key, tm}, fields...)...)}
}

func (_c *MockHashCmdable_HExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time, fields ...string)) *MockHashCmdable_HExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HExpireAt_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time, ...string) *IntSliceCmd) *MockHashCmdable_HExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *MockHashCmdable) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireAtWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExpireAtWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireAtWithArgs'
type MockHashCmdable_HExpireAtWithArgs_Call struct {
	*mock.Call
}

// HExpireAtWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HExpireAtWithArgs(ctx interface{}, key interface{}, tm interface{}, expirationArgs interface{}, fields ...interface{}) *MockHashCmdable_HExpireAtWithArgs_Call {
	return &MockHashCmdable_HExpireAtWithArgs_Call{Call: _e.mock.On("HExpireAtWithArgs",
		append([]interface{}{ctx, key, tm, expirationArgs}, fields...)...)}
}

func (_c *MockHashCmdable_HExpireAtWithArgs_Call) Run(run func(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string)) *MockHashCmdable_HExpireAtWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HExpireAtWithArgs_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HExpireAtWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExpireAtWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd) *MockHashCmdable_HExpireAtWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireTime")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireTime'
type MockHashCmdable_HExpireTime_Call struct {
	*mock.Call
}

// HExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HExpireTime(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HExpireTime_Call {
	return &MockHashCmdable_HExpireTime_Call{Call: _e.mock.On("HExpireTime",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HExpireTime_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HExpireTime_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExpireTime_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockHashCmdable_HExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// HExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *MockHashCmdable) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HExpireWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HExpireWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HExpireWithArgs'
type MockHashCmdable_HExpireWithArgs_Call struct {
	*mock.Call
}

// HExpireWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HExpireWithArgs(ctx interface{}, key interface{}, expiration interface{}, expirationArgs interface{}, fields ...interface{}) *MockHashCmdable_HExpireWithArgs_Call {
	return &MockHashCmdable_HExpireWithArgs_Call{Call: _e.mock.On("HExpireWithArgs",
		append([]interface{}{ctx, key, expiration, expirationArgs}, fields...)...)}
}

func (_c *MockHashCmdable_HExpireWithArgs_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string)) *MockHashCmdable_HExpireWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HExpireWithArgs_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HExpireWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HExpireWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd) *MockHashCmdable_HExpireWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HGet provides a mock function with given fields: ctx, key, field
func (_m *MockHashCmdable) HGet(ctx context.Context, key string, field string) *StringCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockHashCmdable_HGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGet'
type MockHashCmdable_HGet_Call struct {
	*mock.Call
}

// HGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockHashCmdable_Expecter) HGet(ctx interface{}, key interface{}, field interface{}) *MockHashCmdable_HGet_Call {
	return &MockHashCmdable_HGet_Call{Call: _e.mock.On("HGet", ctx, key, field)}
}

func (_c *MockHashCmdable_HGet_Call) Run(run func(ctx context.Context, key string, field string)) *MockHashCmdable_HGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HGet_Call) Return(_a0 *StringCmd) *MockHashCmdable_HGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HGet_Call) RunAndReturn(run func(context.Context, string, string) *StringCmd) *MockHashCmdable_HGet_Call {
	_c.Call.Return(run)
	return _c
}

// HGetAll provides a mock function with given fields: ctx, key
func (_m *MockHashCmdable) HGetAll(ctx context.Context, key string) *MapStringStringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *MapStringStringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *MapStringStringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringStringCmd)
		}
	}

	return r0
}

// MockHashCmdable_HGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGetAll'
type MockHashCmdable_HGetAll_Call struct {
	*mock.Call
}

// HGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockHashCmdable_Expecter) HGetAll(ctx interface{}, key interface{}) *MockHashCmdable_HGetAll_Call {
	return &MockHashCmdable_HGetAll_Call{Call: _e.mock.On("HGetAll", ctx, key)}
}

func (_c *MockHashCmdable_HGetAll_Call) Run(run func(ctx context.Context, key string)) *MockHashCmdable_HGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HGetAll_Call) Return(_a0 *MapStringStringCmd) *MockHashCmdable_HGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HGetAll_Call) RunAndReturn(run func(context.Context, string) *MapStringStringCmd) *MockHashCmdable_HGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrBy provides a mock function with given fields: ctx, key, field, incr
func (_m *MockHashCmdable) HIncrBy(ctx context.Context, key string, field string, incr int64) *IntCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockHashCmdable_HIncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrBy'
type MockHashCmdable_HIncrBy_Call struct {
	*mock.Call
}

// HIncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr int64
func (_e *MockHashCmdable_Expecter) HIncrBy(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockHashCmdable_HIncrBy_Call {
	return &MockHashCmdable_HIncrBy_Call{Call: _e.mock.On("HIncrBy", ctx, key, field, incr)}
}

func (_c *MockHashCmdable_HIncrBy_Call) Run(run func(ctx context.Context, key string, field string, incr int64)) *MockHashCmdable_HIncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockHashCmdable_HIncrBy_Call) Return(_a0 *IntCmd) *MockHashCmdable_HIncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HIncrBy_Call) RunAndReturn(run func(context.Context, string, string, int64) *IntCmd) *MockHashCmdable_HIncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// HIncrByFloat provides a mock function with given fields: ctx, key, field, incr
func (_m *MockHashCmdable) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *FloatCmd {
	ret := _m.Called(ctx, key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, float64) *FloatCmd); ok {
		r0 = rf(ctx, key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockHashCmdable_HIncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HIncrByFloat'
type MockHashCmdable_HIncrByFloat_Call struct {
	*mock.Call
}

// HIncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - incr float64
func (_e *MockHashCmdable_Expecter) HIncrByFloat(ctx interface{}, key interface{}, field interface{}, incr interface{}) *MockHashCmdable_HIncrByFloat_Call {
	return &MockHashCmdable_HIncrByFloat_Call{Call: _e.mock.On("HIncrByFloat", ctx, key, field, incr)}
}

func (_c *MockHashCmdable_HIncrByFloat_Call) Run(run func(ctx context.Context, key string, field string, incr float64)) *MockHashCmdable_HIncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(float64))
	})
	return _c
}

func (_c *MockHashCmdable_HIncrByFloat_Call) Return(_a0 *FloatCmd) *MockHashCmdable_HIncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HIncrByFloat_Call) RunAndReturn(run func(context.Context, string, string, float64) *FloatCmd) *MockHashCmdable_HIncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// HKeys provides a mock function with given fields: ctx, key
func (_m *MockHashCmdable) HKeys(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HKeys'
type MockHashCmdable_HKeys_Call struct {
	*mock.Call
}

// HKeys is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockHashCmdable_Expecter) HKeys(ctx interface{}, key interface{}) *MockHashCmdable_HKeys_Call {
	return &MockHashCmdable_HKeys_Call{Call: _e.mock.On("HKeys", ctx, key)}
}

func (_c *MockHashCmdable_HKeys_Call) Run(run func(ctx context.Context, key string)) *MockHashCmdable_HKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HKeys_Call) Return(_a0 *StringSliceCmd) *MockHashCmdable_HKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HKeys_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockHashCmdable_HKeys_Call {
	_c.Call.Return(run)
	return _c
}

// HLen provides a mock function with given fields: ctx, key
func (_m *MockHashCmdable) HLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockHashCmdable_HLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HLen'
type MockHashCmdable_HLen_Call struct {
	*mock.Call
}

// HLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockHashCmdable_Expecter) HLen(ctx interface{}, key interface{}) *MockHashCmdable_HLen_Call {
	return &MockHashCmdable_HLen_Call{Call: _e.mock.On("HLen", ctx, key)}
}

func (_c *MockHashCmdable_HLen_Call) Run(run func(ctx context.Context, key string)) *MockHashCmdable_HLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HLen_Call) Return(_a0 *IntCmd) *MockHashCmdable_HLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockHashCmdable_HLen_Call {
	_c.Call.Return(run)
	return _c
}

// HMGet provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HMGet(ctx context.Context, key string, fields ...string) *SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *SliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMGet'
type MockHashCmdable_HMGet_Call struct {
	*mock.Call
}

// HMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HMGet(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HMGet_Call {
	return &MockHashCmdable_HMGet_Call{Call: _e.mock.On("HMGet",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HMGet_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HMGet_Call) Return(_a0 *SliceCmd) *MockHashCmdable_HMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HMGet_Call) RunAndReturn(run func(context.Context, string, ...string) *SliceCmd) *MockHashCmdable_HMGet_Call {
	_c.Call.Return(run)
	return _c
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *MockHashCmdable) HMSet(ctx context.Context, key string, values ...interface{}) *BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockHashCmdable_HMSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMSet'
type MockHashCmdable_HMSet_Call struct {
	*mock.Call
}

// HMSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockHashCmdable_Expecter) HMSet(ctx interface{}, key interface{}, values ...interface{}) *MockHashCmdable_HMSet_Call {
	return &MockHashCmdable_HMSet_Call{Call: _e.mock.On("HMSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockHashCmdable_HMSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockHashCmdable_HMSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HMSet_Call) Return(_a0 *BoolCmd) *MockHashCmdable_HMSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HMSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *BoolCmd) *MockHashCmdable_HMSet_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpire provides a mock function with given fields: ctx, key, expiration, fields
func (_m *MockHashCmdable) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpire")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpire'
type MockHashCmdable_HPExpire_Call struct {
	*mock.Call
}

// HPExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPExpire(ctx interface{}, key interface{}, expiration interface{}, fields ...interface{}) *MockHashCmdable_HPExpire_Call {
	return &MockHashCmdable_HPExpire_Call{Call: _e.mock.On("HPExpire",
		append([]interface{}{ctx, key, expiration}, fields...)...)}
}

func (_c *MockHashCmdable_HPExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, fields ...string)) *MockHashCmdable_HPExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPExpire_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration, ...string) *IntSliceCmd) *MockHashCmdable_HPExpire_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireAt provides a mock function with given fields: ctx, key, tm, fields
func (_m *MockHashCmdable) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAt")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireAt'
type MockHashCmdable_HPExpireAt_Call struct {
	*mock.Call
}

// HPExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPExpireAt(ctx interface{}, key interface{}, tm interface{}, fields ...interface{}) *MockHashCmdable_HPExpireAt_Call {
	return &MockHashCmdable_HPExpireAt_Call{Call: _e.mock.On("HPExpireAt",
		append([]interface{}{ctx, key, tm}, fields...)...)}
}

func (_c *MockHashCmdable_HPExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time, fields ...string)) *MockHashCmdable_HPExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPExpireAt_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time, ...string) *IntSliceCmd) *MockHashCmdable_HPExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireAtWithArgs provides a mock function with given fields: ctx, key, tm, expirationArgs, fields
func (_m *MockHashCmdable) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, tm, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireAtWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, tm, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPExpireAtWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireAtWithArgs'
type MockHashCmdable_HPExpireAtWithArgs_Call struct {
	*mock.Call
}

// HPExpireAtWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPExpireAtWithArgs(ctx interface{}, key interface{}, tm interface{}, expirationArgs interface{}, fields ...interface{}) *MockHashCmdable_HPExpireAtWithArgs_Call {
	return &MockHashCmdable_HPExpireAtWithArgs_Call{Call: _e.mock.On("HPExpireAtWithArgs",
		append([]interface{}{ctx, key, tm, expirationArgs}, fields...)...)}
}

func (_c *MockHashCmdable_HPExpireAtWithArgs_Call) Run(run func(ctx context.Context, key string, tm time.Time, expirationArgs HExpireArgs, fields ...string)) *MockHashCmdable_HPExpireAtWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPExpireAtWithArgs_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPExpireAtWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPExpireAtWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Time, HExpireArgs, ...string) *IntSliceCmd) *MockHashCmdable_HPExpireAtWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireTime provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HPExpireTime(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireTime")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireTime'
type MockHashCmdable_HPExpireTime_Call struct {
	*mock.Call
}

// HPExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPExpireTime(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HPExpireTime_Call {
	return &MockHashCmdable_HPExpireTime_Call{Call: _e.mock.On("HPExpireTime",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HPExpireTime_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HPExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPExpireTime_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPExpireTime_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockHashCmdable_HPExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// HPExpireWithArgs provides a mock function with given fields: ctx, key, expiration, expirationArgs, fields
func (_m *MockHashCmdable) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, expiration, expirationArgs)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPExpireWithArgs")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, expiration, expirationArgs, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPExpireWithArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPExpireWithArgs'
type MockHashCmdable_HPExpireWithArgs_Call struct {
	*mock.Call
}

// HPExpireWithArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
//   - expirationArgs HExpireArgs
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPExpireWithArgs(ctx interface{}, key interface{}, expiration interface{}, expirationArgs interface{}, fields ...interface{}) *MockHashCmdable_HPExpireWithArgs_Call {
	return &MockHashCmdable_HPExpireWithArgs_Call{Call: _e.mock.On("HPExpireWithArgs",
		append([]interface{}{ctx, key, expiration, expirationArgs}, fields...)...)}
}

func (_c *MockHashCmdable_HPExpireWithArgs_Call) Run(run func(ctx context.Context, key string, expiration time.Duration, expirationArgs HExpireArgs, fields ...string)) *MockHashCmdable_HPExpireWithArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(HExpireArgs), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPExpireWithArgs_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPExpireWithArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPExpireWithArgs_Call) RunAndReturn(run func(context.Context, string, time.Duration, HExpireArgs, ...string) *IntSliceCmd) *MockHashCmdable_HPExpireWithArgs_Call {
	_c.Call.Return(run)
	return _c
}

// HPTTL provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HPTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPTTL")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPTTL'
type MockHashCmdable_HPTTL_Call struct {
	*mock.Call
}

// HPTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPTTL(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HPTTL_Call {
	return &MockHashCmdable_HPTTL_Call{Call: _e.mock.On("HPTTL",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HPTTL_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HPTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPTTL_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPTTL_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockHashCmdable_HPTTL_Call {
	_c.Call.Return(run)
	return _c
}

// HPersist provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HPersist(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HPersist")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HPersist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HPersist'
type MockHashCmdable_HPersist_Call struct {
	*mock.Call
}

// HPersist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HPersist(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HPersist_Call {
	return &MockHashCmdable_HPersist_Call{Call: _e.mock.On("HPersist",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HPersist_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HPersist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HPersist_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HPersist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HPersist_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockHashCmdable_HPersist_Call {
	_c.Call.Return(run)
	return _c
}

// HRandField provides a mock function with given fields: ctx, key, count
func (_m *MockHashCmdable) HRandField(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandField")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HRandField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HRandField'
type MockHashCmdable_HRandField_Call struct {
	*mock.Call
}

// HRandField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockHashCmdable_Expecter) HRandField(ctx interface{}, key interface{}, count interface{}) *MockHashCmdable_HRandField_Call {
	return &MockHashCmdable_HRandField_Call{Call: _e.mock.On("HRandField", ctx, key, count)}
}

func (_c *MockHashCmdable_HRandField_Call) Run(run func(ctx context.Context, key string, count int)) *MockHashCmdable_HRandField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockHashCmdable_HRandField_Call) Return(_a0 *StringSliceCmd) *MockHashCmdable_HRandField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HRandField_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockHashCmdable_HRandField_Call {
	_c.Call.Return(run)
	return _c
}

// HRandFieldWithValues provides a mock function with given fields: ctx, key, count
func (_m *MockHashCmdable) HRandFieldWithValues(ctx context.Context, key string, count int) *KeyValueSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for HRandFieldWithValues")
	}

	var r0 *KeyValueSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *KeyValueSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValueSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HRandFieldWithValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HRandFieldWithValues'
type MockHashCmdable_HRandFieldWithValues_Call struct {
	*mock.Call
}

// HRandFieldWithValues is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockHashCmdable_Expecter) HRandFieldWithValues(ctx interface{}, key interface{}, count interface{}) *MockHashCmdable_HRandFieldWithValues_Call {
	return &MockHashCmdable_HRandFieldWithValues_Call{Call: _e.mock.On("HRandFieldWithValues", ctx, key, count)}
}

func (_c *MockHashCmdable_HRandFieldWithValues_Call) Run(run func(ctx context.Context, key string, count int)) *MockHashCmdable_HRandFieldWithValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockHashCmdable_HRandFieldWithValues_Call) Return(_a0 *KeyValueSliceCmd) *MockHashCmdable_HRandFieldWithValues_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HRandFieldWithValues_Call) RunAndReturn(run func(context.Context, string, int) *KeyValueSliceCmd) *MockHashCmdable_HRandFieldWithValues_Call {
	_c.Call.Return(run)
	return _c
}

// HScan provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockHashCmdable) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockHashCmdable_HScan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HScan'
type MockHashCmdable_HScan_Call struct {
	*mock.Call
}

// HScan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockHashCmdable_Expecter) HScan(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockHashCmdable_HScan_Call {
	return &MockHashCmdable_HScan_Call{Call: _e.mock.On("HScan", ctx, key, cursor, match, count)}
}

func (_c *MockHashCmdable_HScan_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockHashCmdable_HScan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockHashCmdable_HScan_Call) Return(_a0 *ScanCmd) *MockHashCmdable_HScan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HScan_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockHashCmdable_HScan_Call {
	_c.Call.Return(run)
	return _c
}

// HScanNoValues provides a mock function with given fields: ctx, key, cursor, match, count
func (_m *MockHashCmdable) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScanNoValues")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockHashCmdable_HScanNoValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HScanNoValues'
type MockHashCmdable_HScanNoValues_Call struct {
	*mock.Call
}

// HScanNoValues is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockHashCmdable_Expecter) HScanNoValues(ctx interface{}, key interface{}, cursor interface{}, match interface{}, count interface{}) *MockHashCmdable_HScanNoValues_Call {
	return &MockHashCmdable_HScanNoValues_Call{Call: _e.mock.On("HScanNoValues", ctx, key, cursor, match, count)}
}

func (_c *MockHashCmdable_HScanNoValues_Call) Run(run func(ctx context.Context, key string, cursor uint64, match string, count int64)) *MockHashCmdable_HScanNoValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(int64))
	})
	return _c
}

func (_c *MockHashCmdable_HScanNoValues_Call) Return(_a0 *ScanCmd) *MockHashCmdable_HScanNoValues_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HScanNoValues_Call) RunAndReturn(run func(context.Context, string, uint64, string, int64) *ScanCmd) *MockHashCmdable_HScanNoValues_Call {
	_c.Call.Return(run)
	return _c
}

// HSet provides a mock function with given fields: ctx, key, values
func (_m *MockHashCmdable) HSet(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockHashCmdable_HSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSet'
type MockHashCmdable_HSet_Call struct {
	*mock.Call
}

// HSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockHashCmdable_Expecter) HSet(ctx interface{}, key interface{}, values ...interface{}) *MockHashCmdable_HSet_Call {
	return &MockHashCmdable_HSet_Call{Call: _e.mock.On("HSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockHashCmdable_HSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockHashCmdable_HSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HSet_Call) Return(_a0 *IntCmd) *MockHashCmdable_HSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockHashCmdable_HSet_Call {
	_c.Call.Return(run)
	return _c
}

// HSetNX provides a mock function with given fields: ctx, key, field, value
func (_m *MockHashCmdable) HSetNX(ctx context.Context, key string, field string, value interface{}) *BoolCmd {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) *BoolCmd); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockHashCmdable_HSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSetNX'
type MockHashCmdable_HSetNX_Call struct {
	*mock.Call
}

// HSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - value interface{}
func (_e *MockHashCmdable_Expecter) HSetNX(ctx interface{}, key interface{}, field interface{}, value interface{}) *MockHashCmdable_HSetNX_Call {
	return &MockHashCmdable_HSetNX_Call{Call: _e.mock.On("HSetNX", ctx, key, field, value)}
}

func (_c *MockHashCmdable_HSetNX_Call) Run(run func(ctx context.Context, key string, field string, value interface{})) *MockHashCmdable_HSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *MockHashCmdable_HSetNX_Call) Return(_a0 *BoolCmd) *MockHashCmdable_HSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HSetNX_Call) RunAndReturn(run func(context.Context, string, string, interface{}) *BoolCmd) *MockHashCmdable_HSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// HStrLen provides a mock function with given fields: ctx, key, field
func (_m *MockHashCmdable) HStrLen(ctx context.Context, key string, field string) *IntCmd {
	ret := _m.Called(ctx, key, field)

	if len(ret) == 0 {
		panic("no return value specified for HStrLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockHashCmdable_HStrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HStrLen'
type MockHashCmdable_HStrLen_Call struct {
	*mock.Call
}

// HStrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
func (_e *MockHashCmdable_Expecter) HStrLen(ctx interface{}, key interface{}, field interface{}) *MockHashCmdable_HStrLen_Call {
	return &MockHashCmdable_HStrLen_Call{Call: _e.mock.On("HStrLen", ctx, key, field)}
}

func (_c *MockHashCmdable_HStrLen_Call) Run(run func(ctx context.Context, key string, field string)) *MockHashCmdable_HStrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HStrLen_Call) Return(_a0 *IntCmd) *MockHashCmdable_HStrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HStrLen_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockHashCmdable_HStrLen_Call {
	_c.Call.Return(run)
	return _c
}

// HTTL provides a mock function with given fields: ctx, key, fields
func (_m *MockHashCmdable) HTTL(ctx context.Context, key string, fields ...string) *IntSliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HTTL")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntSliceCmd); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HTTL'
type MockHashCmdable_HTTL_Call struct {
	*mock.Call
}

// HTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *MockHashCmdable_Expecter) HTTL(ctx interface{}, key interface{}, fields ...interface{}) *MockHashCmdable_HTTL_Call {
	return &MockHashCmdable_HTTL_Call{Call: _e.mock.On("HTTL",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *MockHashCmdable_HTTL_Call) Run(run func(ctx context.Context, key string, fields ...string)) *MockHashCmdable_HTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockHashCmdable_HTTL_Call) Return(_a0 *IntSliceCmd) *MockHashCmdable_HTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HTTL_Call) RunAndReturn(run func(context.Context, string, ...string) *IntSliceCmd) *MockHashCmdable_HTTL_Call {
	_c.Call.Return(run)
	return _c
}

// HVals provides a mock function with given fields: ctx, key
func (_m *MockHashCmdable) HVals(ctx context.Context, key string) *StringSliceCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockHashCmdable_HVals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HVals'
type MockHashCmdable_HVals_Call struct {
	*mock.Call
}

// HVals is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockHashCmdable_Expecter) HVals(ctx interface{}, key interface{}) *MockHashCmdable_HVals_Call {
	return &MockHashCmdable_HVals_Call{Call: _e.mock.On("HVals", ctx, key)}
}

func (_c *MockHashCmdable_HVals_Call) Run(run func(ctx context.Context, key string)) *MockHashCmdable_HVals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockHashCmdable_HVals_Call) Return(_a0 *StringSliceCmd) *MockHashCmdable_HVals_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockHashCmdable_HVals_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockHashCmdable_HVals_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockHashCmdable creates a new instance of MockHashCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockHashCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockHashCmdable {
	mock := &MockHashCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
