// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockListCmdable is an autogenerated mock type for the ListCmdable type
type MockListCmdable struct {
	mock.Mock
}

type MockListCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockListCmdable) EXPECT() *MockListCmdable_Expecter {
	return &MockListCmdable_Expecter{mock: &_m.Mock}
}

// BLMPop provides a mock function with given fields: ctx, timeout, direction, count, keys
func (_m *MockListCmdable) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLMPop")
	}

	var r0 *KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, string, int64, ...string) *KeyValuesCmd); ok {
		r0 = rf(ctx, timeout, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValuesCmd)
		}
	}

	return r0
}

// MockListCmdable_BLMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLMPop'
type MockListCmdable_BLMPop_Call struct {
	*mock.Call
}

// BLMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - direction string
//   - count int64
//   - keys ...string
func (_e *MockListCmdable_Expecter) BLMPop(ctx interface{}, timeout interface{}, direction interface{}, count interface{}, keys ...interface{}) *MockListCmdable_BLMPop_Call {
	return &MockListCmdable_BLMPop_Call{Call: _e.mock.On("BLMPop",
		append([]interface{}{ctx, timeout, direction, count}, keys...)...)}
}

func (_c *MockListCmdable_BLMPop_Call) Run(run func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string)) *MockListCmdable_BLMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), args[2].(string), args[3].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_BLMPop_Call) Return(_a0 *KeyValuesCmd) *MockListCmdable_BLMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_BLMPop_Call) RunAndReturn(run func(context.Context, time.Duration, string, int64, ...string) *KeyValuesCmd) *MockListCmdable_BLMPop_Call {
	_c.Call.Return(run)
	return _c
}

// BLMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos, timeout
func (_m *MockListCmdable) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BLMove")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_BLMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLMove'
type MockListCmdable_BLMove_Call struct {
	*mock.Call
}

// BLMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
//   - timeout time.Duration
func (_e *MockListCmdable_Expecter) BLMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}, timeout interface{}) *MockListCmdable_BLMove_Call {
	return &MockListCmdable_BLMove_Call{Call: _e.mock.On("BLMove", ctx, source, destination, srcpos, destpos, timeout)}
}

func (_c *MockListCmdable_BLMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration)) *MockListCmdable_BLMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockListCmdable_BLMove_Call) Return(_a0 *StringCmd) *MockListCmdable_BLMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_BLMove_Call) RunAndReturn(run func(context.Context, string, string, string, string, time.Duration) *StringCmd) *MockListCmdable_BLMove_Call {
	_c.Call.Return(run)
	return _c
}

// BLPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockListCmdable) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_BLPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BLPop'
type MockListCmdable_BLPop_Call struct {
	*mock.Call
}

// BLPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockListCmdable_Expecter) BLPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockListCmdable_BLPop_Call {
	return &MockListCmdable_BLPop_Call{Call: _e.mock.On("BLPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockListCmdable_BLPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockListCmdable_BLPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_BLPop_Call) Return(_a0 *StringSliceCmd) *MockListCmdable_BLPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_BLPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *StringSliceCmd) *MockListCmdable_BLPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPop provides a mock function with given fields: ctx, timeout, keys
func (_m *MockListCmdable) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_BRPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPop'
type MockListCmdable_BRPop_Call struct {
	*mock.Call
}

// BRPop is a helper method to define mock.On call
//   - ctx context.Context
//   - timeout time.Duration
//   - keys ...string
func (_e *MockListCmdable_Expecter) BRPop(ctx interface{}, timeout interface{}, keys ...interface{}) *MockListCmdable_BRPop_Call {
	return &MockListCmdable_BRPop_Call{Call: _e.mock.On("BRPop",
		append([]interface{}{ctx, timeout}, keys...)...)}
}

func (_c *MockListCmdable_BRPop_Call) Run(run func(ctx context.Context, timeout time.Duration, keys ...string)) *MockListCmdable_BRPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(time.Duration), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_BRPop_Call) Return(_a0 *StringSliceCmd) *MockListCmdable_BRPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_BRPop_Call) RunAndReturn(run func(context.Context, time.Duration, ...string) *StringSliceCmd) *MockListCmdable_BRPop_Call {
	_c.Call.Return(run)
	return _c
}

// BRPopLPush provides a mock function with given fields: ctx, source, destination, timeout
func (_m *MockListCmdable) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *StringCmd {
	ret := _m.Called(ctx, source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_BRPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BRPopLPush'
type MockListCmdable_BRPopLPush_Call struct {
	*mock.Call
}

// BRPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - timeout time.Duration
func (_e *MockListCmdable_Expecter) BRPopLPush(ctx interface{}, source interface{}, destination interface{}, timeout interface{}) *MockListCmdable_BRPopLPush_Call {
	return &MockListCmdable_BRPopLPush_Call{Call: _e.mock.On("BRPopLPush", ctx, source, destination, timeout)}
}

func (_c *MockListCmdable_BRPopLPush_Call) Run(run func(ctx context.Context, source string, destination string, timeout time.Duration)) *MockListCmdable_BRPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockListCmdable_BRPopLPush_Call) Return(_a0 *StringCmd) *MockListCmdable_BRPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_BRPopLPush_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) *StringCmd) *MockListCmdable_BRPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// LIndex provides a mock function with given fields: ctx, key, index
func (_m *MockListCmdable) LIndex(ctx context.Context, key string, index int64) *StringCmd {
	ret := _m.Called(ctx, key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *StringCmd); ok {
		r0 = rf(ctx, key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_LIndex_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LIndex'
type MockListCmdable_LIndex_Call struct {
	*mock.Call
}

// LIndex is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
func (_e *MockListCmdable_Expecter) LIndex(ctx interface{}, key interface{}, index interface{}) *MockListCmdable_LIndex_Call {
	return &MockListCmdable_LIndex_Call{Call: _e.mock.On("LIndex", ctx, key, index)}
}

func (_c *MockListCmdable_LIndex_Call) Run(run func(ctx context.Context, key string, index int64)) *MockListCmdable_LIndex_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockListCmdable_LIndex_Call) Return(_a0 *StringCmd) *MockListCmdable_LIndex_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LIndex_Call) RunAndReturn(run func(context.Context, string, int64) *StringCmd) *MockListCmdable_LIndex_Call {
	_c.Call.Return(run)
	return _c
}

// LInsert provides a mock function with given fields: ctx, key, op, pivot, value
func (_m *MockListCmdable) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LInsert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsert'
type MockListCmdable_LInsert_Call struct {
	*mock.Call
}

// LInsert is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - op string
//   - pivot interface{}
//   - value interface{}
func (_e *MockListCmdable_Expecter) LInsert(ctx interface{}, key interface{}, op interface{}, pivot interface{}, value interface{}) *MockListCmdable_LInsert_Call {
	return &MockListCmdable_LInsert_Call{Call: _e.mock.On("LInsert", ctx, key, op, pivot, value)}
}

func (_c *MockListCmdable_LInsert_Call) Run(run func(ctx context.Context, key string, op string, pivot interface{}, value interface{})) *MockListCmdable_LInsert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}), args[4].(interface{}))
	})
	return _c
}

func (_c *MockListCmdable_LInsert_Call) Return(_a0 *IntCmd) *MockListCmdable_LInsert_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LInsert_Call) RunAndReturn(run func(context.Context, string, string, interface{}, interface{}) *IntCmd) *MockListCmdable_LInsert_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertAfter provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockListCmdable) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LInsertAfter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertAfter'
type MockListCmdable_LInsertAfter_Call struct {
	*mock.Call
}

// LInsertAfter is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockListCmdable_Expecter) LInsertAfter(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockListCmdable_LInsertAfter_Call {
	return &MockListCmdable_LInsertAfter_Call{Call: _e.mock.On("LInsertAfter", ctx, key, pivot, value)}
}

func (_c *MockListCmdable_LInsertAfter_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockListCmdable_LInsertAfter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockListCmdable_LInsertAfter_Call) Return(_a0 *IntCmd) *MockListCmdable_LInsertAfter_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LInsertAfter_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *IntCmd) *MockListCmdable_LInsertAfter_Call {
	_c.Call.Return(run)
	return _c
}

// LInsertBefore provides a mock function with given fields: ctx, key, pivot, value
func (_m *MockListCmdable) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LInsertBefore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LInsertBefore'
type MockListCmdable_LInsertBefore_Call struct {
	*mock.Call
}

// LInsertBefore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - pivot interface{}
//   - value interface{}
func (_e *MockListCmdable_Expecter) LInsertBefore(ctx interface{}, key interface{}, pivot interface{}, value interface{}) *MockListCmdable_LInsertBefore_Call {
	return &MockListCmdable_LInsertBefore_Call{Call: _e.mock.On("LInsertBefore", ctx, key, pivot, value)}
}

func (_c *MockListCmdable_LInsertBefore_Call) Run(run func(ctx context.Context, key string, pivot interface{}, value interface{})) *MockListCmdable_LInsertBefore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(interface{}))
	})
	return _c
}

func (_c *MockListCmdable_LInsertBefore_Call) Return(_a0 *IntCmd) *MockListCmdable_LInsertBefore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LInsertBefore_Call) RunAndReturn(run func(context.Context, string, interface{}, interface{}) *IntCmd) *MockListCmdable_LInsertBefore_Call {
	_c.Call.Return(run)
	return _c
}

// LLen provides a mock function with given fields: ctx, key
func (_m *MockListCmdable) LLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LLen'
type MockListCmdable_LLen_Call struct {
	*mock.Call
}

// LLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockListCmdable_Expecter) LLen(ctx interface{}, key interface{}) *MockListCmdable_LLen_Call {
	return &MockListCmdable_LLen_Call{Call: _e.mock.On("LLen", ctx, key)}
}

func (_c *MockListCmdable_LLen_Call) Run(run func(ctx context.Context, key string)) *MockListCmdable_LLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockListCmdable_LLen_Call) Return(_a0 *IntCmd) *MockListCmdable_LLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockListCmdable_LLen_Call {
	_c.Call.Return(run)
	return _c
}

// LMPop provides a mock function with given fields: ctx, direction, count, keys
func (_m *MockListCmdable) LMPop(ctx context.Context, direction string, count int64, keys ...string) *KeyValuesCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, direction, count)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LMPop")
	}

	var r0 *KeyValuesCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...string) *KeyValuesCmd); ok {
		r0 = rf(ctx, direction, count, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*KeyValuesCmd)
		}
	}

	return r0
}

// MockListCmdable_LMPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LMPop'
type MockListCmdable_LMPop_Call struct {
	*mock.Call
}

// LMPop is a helper method to define mock.On call
//   - ctx context.Context
//   - direction string
//   - count int64
//   - keys ...string
func (_e *MockListCmdable_Expecter) LMPop(ctx interface{}, direction interface{}, count interface{}, keys ...interface{}) *MockListCmdable_LMPop_Call {
	return &MockListCmdable_LMPop_Call{Call: _e.mock.On("LMPop",
		append([]interface{}{ctx, direction, count}, keys...)...)}
}

func (_c *MockListCmdable_LMPop_Call) Run(run func(ctx context.Context, direction string, count int64, keys ...string)) *MockListCmdable_LMPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_LMPop_Call) Return(_a0 *KeyValuesCmd) *MockListCmdable_LMPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LMPop_Call) RunAndReturn(run func(context.Context, string, int64, ...string) *KeyValuesCmd) *MockListCmdable_LMPop_Call {
	_c.Call.Return(run)
	return _c
}

// LMove provides a mock function with given fields: ctx, source, destination, srcpos, destpos
func (_m *MockListCmdable) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *StringCmd {
	ret := _m.Called(ctx, source, destination, srcpos, destpos)

	if len(ret) == 0 {
		panic("no return value specified for LMove")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *StringCmd); ok {
		r0 = rf(ctx, source, destination, srcpos, destpos)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_LMove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LMove'
type MockListCmdable_LMove_Call struct {
	*mock.Call
}

// LMove is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
//   - srcpos string
//   - destpos string
func (_e *MockListCmdable_Expecter) LMove(ctx interface{}, source interface{}, destination interface{}, srcpos interface{}, destpos interface{}) *MockListCmdable_LMove_Call {
	return &MockListCmdable_LMove_Call{Call: _e.mock.On("LMove", ctx, source, destination, srcpos, destpos)}
}

func (_c *MockListCmdable_LMove_Call) Run(run func(ctx context.Context, source string, destination string, srcpos string, destpos string)) *MockListCmdable_LMove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockListCmdable_LMove_Call) Return(_a0 *StringCmd) *MockListCmdable_LMove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LMove_Call) RunAndReturn(run func(context.Context, string, string, string, string) *StringCmd) *MockListCmdable_LMove_Call {
	_c.Call.Return(run)
	return _c
}

// LPop provides a mock function with given fields: ctx, key
func (_m *MockListCmdable) LPop(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_LPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPop'
type MockListCmdable_LPop_Call struct {
	*mock.Call
}

// LPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockListCmdable_Expecter) LPop(ctx interface{}, key interface{}) *MockListCmdable_LPop_Call {
	return &MockListCmdable_LPop_Call{Call: _e.mock.On("LPop", ctx, key)}
}

func (_c *MockListCmdable_LPop_Call) Run(run func(ctx context.Context, key string)) *MockListCmdable_LPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockListCmdable_LPop_Call) Return(_a0 *StringCmd) *MockListCmdable_LPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPop_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockListCmdable_LPop_Call {
	_c.Call.Return(run)
	return _c
}

// LPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockListCmdable) LPopCount(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for LPopCount")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_LPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPopCount'
type MockListCmdable_LPopCount_Call struct {
	*mock.Call
}

// LPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockListCmdable_Expecter) LPopCount(ctx interface{}, key interface{}, count interface{}) *MockListCmdable_LPopCount_Call {
	return &MockListCmdable_LPopCount_Call{Call: _e.mock.On("LPopCount", ctx, key, count)}
}

func (_c *MockListCmdable_LPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockListCmdable_LPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockListCmdable_LPopCount_Call) Return(_a0 *StringSliceCmd) *MockListCmdable_LPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPopCount_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockListCmdable_LPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPos provides a mock function with given fields: ctx, key, value, args
func (_m *MockListCmdable) LPos(ctx context.Context, key string, value string, args LPosArgs) *IntCmd {
	ret := _m.Called(ctx, key, value, args)

	if len(ret) == 0 {
		panic("no return value specified for LPos")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, LPosArgs) *IntCmd); ok {
		r0 = rf(ctx, key, value, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPos'
type MockListCmdable_LPos_Call struct {
	*mock.Call
}

// LPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - args LPosArgs
func (_e *MockListCmdable_Expecter) LPos(ctx interface{}, key interface{}, value interface{}, args interface{}) *MockListCmdable_LPos_Call {
	return &MockListCmdable_LPos_Call{Call: _e.mock.On("LPos", ctx, key, value, args)}
}

func (_c *MockListCmdable_LPos_Call) Run(run func(ctx context.Context, key string, value string, args LPosArgs)) *MockListCmdable_LPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(LPosArgs))
	})
	return _c
}

func (_c *MockListCmdable_LPos_Call) Return(_a0 *IntCmd) *MockListCmdable_LPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPos_Call) RunAndReturn(run func(context.Context, string, string, LPosArgs) *IntCmd) *MockListCmdable_LPos_Call {
	_c.Call.Return(run)
	return _c
}

// LPosCount provides a mock function with given fields: ctx, key, value, count, args
func (_m *MockListCmdable) LPosCount(ctx context.Context, key string, value string, count int64, args LPosArgs) *IntSliceCmd {
	ret := _m.Called(ctx, key, value, count, args)

	if len(ret) == 0 {
		panic("no return value specified for LPosCount")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int64, LPosArgs) *IntSliceCmd); ok {
		r0 = rf(ctx, key, value, count, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_LPosCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPosCount'
type MockListCmdable_LPosCount_Call struct {
	*mock.Call
}

// LPosCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - count int64
//   - args LPosArgs
func (_e *MockListCmdable_Expecter) LPosCount(ctx interface{}, key interface{}, value interface{}, count interface{}, args interface{}) *MockListCmdable_LPosCount_Call {
	return &MockListCmdable_LPosCount_Call{Call: _e.mock.On("LPosCount", ctx, key, value, count, args)}
}

func (_c *MockListCmdable_LPosCount_Call) Run(run func(ctx context.Context, key string, value string, count int64, args LPosArgs)) *MockListCmdable_LPosCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int64), args[4].(LPosArgs))
	})
	return _c
}

func (_c *MockListCmdable_LPosCount_Call) Return(_a0 *IntSliceCmd) *MockListCmdable_LPosCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPosCount_Call) RunAndReturn(run func(context.Context, string, string, int64, LPosArgs) *IntSliceCmd) *MockListCmdable_LPosCount_Call {
	_c.Call.Return(run)
	return _c
}

// LPush provides a mock function with given fields: ctx, key, values
func (_m *MockListCmdable) LPush(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPush'
type MockListCmdable_LPush_Call struct {
	*mock.Call
}

// LPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockListCmdable_Expecter) LPush(ctx interface{}, key interface{}, values ...interface{}) *MockListCmdable_LPush_Call {
	return &MockListCmdable_LPush_Call{Call: _e.mock.On("LPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockListCmdable_LPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockListCmdable_LPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_LPush_Call) Return(_a0 *IntCmd) *MockListCmdable_LPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockListCmdable_LPush_Call {
	_c.Call.Return(run)
	return _c
}

// LPushX provides a mock function with given fields: ctx, key, values
func (_m *MockListCmdable) LPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LPushX'
type MockListCmdable_LPushX_Call struct {
	*mock.Call
}

// LPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockListCmdable_Expecter) LPushX(ctx interface{}, key interface{}, values ...interface{}) *MockListCmdable_LPushX_Call {
	return &MockListCmdable_LPushX_Call{Call: _e.mock.On("LPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockListCmdable_LPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockListCmdable_LPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_LPushX_Call) Return(_a0 *IntCmd) *MockListCmdable_LPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockListCmdable_LPushX_Call {
	_c.Call.Return(run)
	return _c
}

// LRange provides a mock function with given fields: ctx, key, start, stop
func (_m *MockListCmdable) LRange(ctx context.Context, key string, start int64, stop int64) *StringSliceCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringSliceCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_LRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRange'
type MockListCmdable_LRange_Call struct {
	*mock.Call
}

// LRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockListCmdable_Expecter) LRange(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockListCmdable_LRange_Call {
	return &MockListCmdable_LRange_Call{Call: _e.mock.On("LRange", ctx, key, start, stop)}
}

func (_c *MockListCmdable_LRange_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockListCmdable_LRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockListCmdable_LRange_Call) Return(_a0 *StringSliceCmd) *MockListCmdable_LRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringSliceCmd) *MockListCmdable_LRange_Call {
	_c.Call.Return(run)
	return _c
}

// LRem provides a mock function with given fields: ctx, key, count, value
func (_m *MockListCmdable) LRem(ctx context.Context, key string, count int64, value interface{}) *IntCmd {
	ret := _m.Called(ctx, key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_LRem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LRem'
type MockListCmdable_LRem_Call struct {
	*mock.Call
}

// LRem is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int64
//   - value interface{}
func (_e *MockListCmdable_Expecter) LRem(ctx interface{}, key interface{}, count interface{}, value interface{}) *MockListCmdable_LRem_Call {
	return &MockListCmdable_LRem_Call{Call: _e.mock.On("LRem", ctx, key, count, value)}
}

func (_c *MockListCmdable_LRem_Call) Run(run func(ctx context.Context, key string, count int64, value interface{})) *MockListCmdable_LRem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockListCmdable_LRem_Call) Return(_a0 *IntCmd) *MockListCmdable_LRem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LRem_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *IntCmd) *MockListCmdable_LRem_Call {
	_c.Call.Return(run)
	return _c
}

// LSet provides a mock function with given fields: ctx, key, index, value
func (_m *MockListCmdable) LSet(ctx context.Context, key string, index int64, value interface{}) *StatusCmd {
	ret := _m.Called(ctx, key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, interface{}) *StatusCmd); ok {
		r0 = rf(ctx, key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockListCmdable_LSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LSet'
type MockListCmdable_LSet_Call struct {
	*mock.Call
}

// LSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - index int64
//   - value interface{}
func (_e *MockListCmdable_Expecter) LSet(ctx interface{}, key interface{}, index interface{}, value interface{}) *MockListCmdable_LSet_Call {
	return &MockListCmdable_LSet_Call{Call: _e.mock.On("LSet", ctx, key, index, value)}
}

func (_c *MockListCmdable_LSet_Call) Run(run func(ctx context.Context, key string, index int64, value interface{})) *MockListCmdable_LSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(interface{}))
	})
	return _c
}

func (_c *MockListCmdable_LSet_Call) Return(_a0 *StatusCmd) *MockListCmdable_LSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LSet_Call) RunAndReturn(run func(context.Context, string, int64, interface{}) *StatusCmd) *MockListCmdable_LSet_Call {
	_c.Call.Return(run)
	return _c
}

// LTrim provides a mock function with given fields: ctx, key, start, stop
func (_m *MockListCmdable) LTrim(ctx context.Context, key string, start int64, stop int64) *StatusCmd {
	ret := _m.Called(ctx, key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StatusCmd); ok {
		r0 = rf(ctx, key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockListCmdable_LTrim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LTrim'
type MockListCmdable_LTrim_Call struct {
	*mock.Call
}

// LTrim is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - stop int64
func (_e *MockListCmdable_Expecter) LTrim(ctx interface{}, key interface{}, start interface{}, stop interface{}) *MockListCmdable_LTrim_Call {
	return &MockListCmdable_LTrim_Call{Call: _e.mock.On("LTrim", ctx, key, start, stop)}
}

func (_c *MockListCmdable_LTrim_Call) Run(run func(ctx context.Context, key string, start int64, stop int64)) *MockListCmdable_LTrim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockListCmdable_LTrim_Call) Return(_a0 *StatusCmd) *MockListCmdable_LTrim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_LTrim_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StatusCmd) *MockListCmdable_LTrim_Call {
	_c.Call.Return(run)
	return _c
}

// RPop provides a mock function with given fields: ctx, key
func (_m *MockListCmdable) RPop(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_RPop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPop'
type MockListCmdable_RPop_Call struct {
	*mock.Call
}

// RPop is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockListCmdable_Expecter) RPop(ctx interface{}, key interface{}) *MockListCmdable_RPop_Call {
	return &MockListCmdable_RPop_Call{Call: _e.mock.On("RPop", ctx, key)}
}

func (_c *MockListCmdable_RPop_Call) Run(run func(ctx context.Context, key string)) *MockListCmdable_RPop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockListCmdable_RPop_Call) Return(_a0 *StringCmd) *MockListCmdable_RPop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_RPop_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockListCmdable_RPop_Call {
	_c.Call.Return(run)
	return _c
}

// RPopCount provides a mock function with given fields: ctx, key, count
func (_m *MockListCmdable) RPopCount(ctx context.Context, key string, count int) *StringSliceCmd {
	ret := _m.Called(ctx, key, count)

	if len(ret) == 0 {
		panic("no return value specified for RPopCount")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *StringSliceCmd); ok {
		r0 = rf(ctx, key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockListCmdable_RPopCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopCount'
type MockListCmdable_RPopCount_Call struct {
	*mock.Call
}

// RPopCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - count int
func (_e *MockListCmdable_Expecter) RPopCount(ctx interface{}, key interface{}, count interface{}) *MockListCmdable_RPopCount_Call {
	return &MockListCmdable_RPopCount_Call{Call: _e.mock.On("RPopCount", ctx, key, count)}
}

func (_c *MockListCmdable_RPopCount_Call) Run(run func(ctx context.Context, key string, count int)) *MockListCmdable_RPopCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockListCmdable_RPopCount_Call) Return(_a0 *StringSliceCmd) *MockListCmdable_RPopCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_RPopCount_Call) RunAndReturn(run func(context.Context, string, int) *StringSliceCmd) *MockListCmdable_RPopCount_Call {
	_c.Call.Return(run)
	return _c
}

// RPopLPush provides a mock function with given fields: ctx, source, destination
func (_m *MockListCmdable) RPopLPush(ctx context.Context, source string, destination string) *StringCmd {
	ret := _m.Called(ctx, source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StringCmd); ok {
		r0 = rf(ctx, source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockListCmdable_RPopLPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPopLPush'
type MockListCmdable_RPopLPush_Call struct {
	*mock.Call
}

// RPopLPush is a helper method to define mock.On call
//   - ctx context.Context
//   - source string
//   - destination string
func (_e *MockListCmdable_Expecter) RPopLPush(ctx interface{}, source interface{}, destination interface{}) *MockListCmdable_RPopLPush_Call {
	return &MockListCmdable_RPopLPush_Call{Call: _e.mock.On("RPopLPush", ctx, source, destination)}
}

func (_c *MockListCmdable_RPopLPush_Call) Run(run func(ctx context.Context, source string, destination string)) *MockListCmdable_RPopLPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockListCmdable_RPopLPush_Call) Return(_a0 *StringCmd) *MockListCmdable_RPopLPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_RPopLPush_Call) RunAndReturn(run func(context.Context, string, string) *StringCmd) *MockListCmdable_RPopLPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPush provides a mock function with given fields: ctx, key, values
func (_m *MockListCmdable) RPush(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_RPush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPush'
type MockListCmdable_RPush_Call struct {
	*mock.Call
}

// RPush is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockListCmdable_Expecter) RPush(ctx interface{}, key interface{}, values ...interface{}) *MockListCmdable_RPush_Call {
	return &MockListCmdable_RPush_Call{Call: _e.mock.On("RPush",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockListCmdable_RPush_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockListCmdable_RPush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_RPush_Call) Return(_a0 *IntCmd) *MockListCmdable_RPush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_RPush_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockListCmdable_RPush_Call {
	_c.Call.Return(run)
	return _c
}

// RPushX provides a mock function with given fields: ctx, key, values
func (_m *MockListCmdable) RPushX(ctx context.Context, key string, values ...interface{}) *IntCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockListCmdable_RPushX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RPushX'
type MockListCmdable_RPushX_Call struct {
	*mock.Call
}

// RPushX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockListCmdable_Expecter) RPushX(ctx interface{}, key interface{}, values ...interface{}) *MockListCmdable_RPushX_Call {
	return &MockListCmdable_RPushX_Call{Call: _e.mock.On("RPushX",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockListCmdable_RPushX_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockListCmdable_RPushX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockListCmdable_RPushX_Call) Return(_a0 *IntCmd) *MockListCmdable_RPushX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockListCmdable_RPushX_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntCmd) *MockListCmdable_RPushX_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockListCmdable creates a new instance of MockListCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockListCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockListCmdable {
	mock := &MockListCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
