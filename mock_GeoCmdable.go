// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockGeoCmdable is an autogenerated mock type for the GeoCmdable type
type MockGeoCmdable struct {
	mock.Mock
}

type MockGeoCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGeoCmdable) EXPECT() *MockGeoCmdable_Expecter {
	return &MockGeoCmdable_Expecter{mock: &_m.Mock}
}

// GeoAdd provides a mock function with given fields: ctx, key, geoLocation
func (_m *MockGeoCmdable) GeoAdd(ctx context.Context, key string, geoLocation ...*GeoLocation) *IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*GeoLocation) *IntCmd); ok {
		r0 = rf(ctx, key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoAdd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoAdd'
type MockGeoCmdable_GeoAdd_Call struct {
	*mock.Call
}

// GeoAdd is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - geoLocation ...*GeoLocation
func (_e *MockGeoCmdable_Expecter) GeoAdd(ctx interface{}, key interface{}, geoLocation ...interface{}) *MockGeoCmdable_GeoAdd_Call {
	return &MockGeoCmdable_GeoAdd_Call{Call: _e.mock.On("GeoAdd",
		append([]interface{}{ctx, key}, geoLocation...)...)}
}

func (_c *MockGeoCmdable_GeoAdd_Call) Run(run func(ctx context.Context, key string, geoLocation ...*GeoLocation)) *MockGeoCmdable_GeoAdd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]*GeoLocation, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(*GeoLocation)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGeoCmdable_GeoAdd_Call) Return(_a0 *IntCmd) *MockGeoCmdable_GeoAdd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoAdd_Call) RunAndReturn(run func(context.Context, string, ...*GeoLocation) *IntCmd) *MockGeoCmdable_GeoAdd_Call {
	_c.Call.Return(run)
	return _c
}

// GeoDist provides a mock function with given fields: ctx, key, member1, member2, unit
func (_m *MockGeoCmdable) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *FloatCmd {
	ret := _m.Called(ctx, key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) *FloatCmd); ok {
		r0 = rf(ctx, key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoDist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoDist'
type MockGeoCmdable_GeoDist_Call struct {
	*mock.Call
}

// GeoDist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member1 string
//   - member2 string
//   - unit string
func (_e *MockGeoCmdable_Expecter) GeoDist(ctx interface{}, key interface{}, member1 interface{}, member2 interface{}, unit interface{}) *MockGeoCmdable_GeoDist_Call {
	return &MockGeoCmdable_GeoDist_Call{Call: _e.mock.On("GeoDist", ctx, key, member1, member2, unit)}
}

func (_c *MockGeoCmdable_GeoDist_Call) Run(run func(ctx context.Context, key string, member1 string, member2 string, unit string)) *MockGeoCmdable_GeoDist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoDist_Call) Return(_a0 *FloatCmd) *MockGeoCmdable_GeoDist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoDist_Call) RunAndReturn(run func(context.Context, string, string, string, string) *FloatCmd) *MockGeoCmdable_GeoDist_Call {
	_c.Call.Return(run)
	return _c
}

// GeoHash provides a mock function with given fields: ctx, key, members
func (_m *MockGeoCmdable) GeoHash(ctx context.Context, key string, members ...string) *StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StringSliceCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoHash'
type MockGeoCmdable_GeoHash_Call struct {
	*mock.Call
}

// GeoHash is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockGeoCmdable_Expecter) GeoHash(ctx interface{}, key interface{}, members ...interface{}) *MockGeoCmdable_GeoHash_Call {
	return &MockGeoCmdable_GeoHash_Call{Call: _e.mock.On("GeoHash",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockGeoCmdable_GeoHash_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockGeoCmdable_GeoHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGeoCmdable_GeoHash_Call) Return(_a0 *StringSliceCmd) *MockGeoCmdable_GeoHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoHash_Call) RunAndReturn(run func(context.Context, string, ...string) *StringSliceCmd) *MockGeoCmdable_GeoHash_Call {
	_c.Call.Return(run)
	return _c
}

// GeoPos provides a mock function with given fields: ctx, key, members
func (_m *MockGeoCmdable) GeoPos(ctx context.Context, key string, members ...string) *GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *GeoPosCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *GeoPosCmd); ok {
		r0 = rf(ctx, key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoPosCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoPos'
type MockGeoCmdable_GeoPos_Call struct {
	*mock.Call
}

// GeoPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - members ...string
func (_e *MockGeoCmdable_Expecter) GeoPos(ctx interface{}, key interface{}, members ...interface{}) *MockGeoCmdable_GeoPos_Call {
	return &MockGeoCmdable_GeoPos_Call{Call: _e.mock.On("GeoPos",
		append([]interface{}{ctx, key}, members...)...)}
}

func (_c *MockGeoCmdable_GeoPos_Call) Run(run func(ctx context.Context, key string, members ...string)) *MockGeoCmdable_GeoPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockGeoCmdable_GeoPos_Call) Return(_a0 *GeoPosCmd) *MockGeoCmdable_GeoPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoPos_Call) RunAndReturn(run func(context.Context, string, ...string) *GeoPosCmd) *MockGeoCmdable_GeoPos_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadius provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockGeoCmdable) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery) *GeoLocationCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *GeoRadiusQuery) *GeoLocationCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoLocationCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoRadius_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadius'
type MockGeoCmdable_GeoRadius_Call struct {
	*mock.Call
}

// GeoRadius is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *GeoRadiusQuery
func (_e *MockGeoCmdable_Expecter) GeoRadius(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockGeoCmdable_GeoRadius_Call {
	return &MockGeoCmdable_GeoRadius_Call{Call: _e.mock.On("GeoRadius", ctx, key, longitude, latitude, query)}
}

func (_c *MockGeoCmdable_GeoRadius_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery)) *MockGeoCmdable_GeoRadius_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoRadius_Call) Return(_a0 *GeoLocationCmd) *MockGeoCmdable_GeoRadius_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoRadius_Call) RunAndReturn(run func(context.Context, string, float64, float64, *GeoRadiusQuery) *GeoLocationCmd) *MockGeoCmdable_GeoRadius_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMember provides a mock function with given fields: ctx, key, member, query
func (_m *MockGeoCmdable) GeoRadiusByMember(ctx context.Context, key string, member string, query *GeoRadiusQuery) *GeoLocationCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *GeoLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoRadiusQuery) *GeoLocationCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoLocationCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoRadiusByMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMember'
type MockGeoCmdable_GeoRadiusByMember_Call struct {
	*mock.Call
}

// GeoRadiusByMember is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *GeoRadiusQuery
func (_e *MockGeoCmdable_Expecter) GeoRadiusByMember(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockGeoCmdable_GeoRadiusByMember_Call {
	return &MockGeoCmdable_GeoRadiusByMember_Call{Call: _e.mock.On("GeoRadiusByMember", ctx, key, member, query)}
}

func (_c *MockGeoCmdable_GeoRadiusByMember_Call) Run(run func(ctx context.Context, key string, member string, query *GeoRadiusQuery)) *MockGeoCmdable_GeoRadiusByMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusByMember_Call) Return(_a0 *GeoLocationCmd) *MockGeoCmdable_GeoRadiusByMember_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusByMember_Call) RunAndReturn(run func(context.Context, string, string, *GeoRadiusQuery) *GeoLocationCmd) *MockGeoCmdable_GeoRadiusByMember_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusByMemberStore provides a mock function with given fields: ctx, key, member, query
func (_m *MockGeoCmdable) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *GeoRadiusQuery) *IntCmd {
	ret := _m.Called(ctx, key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoRadiusQuery) *IntCmd); ok {
		r0 = rf(ctx, key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoRadiusByMemberStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusByMemberStore'
type MockGeoCmdable_GeoRadiusByMemberStore_Call struct {
	*mock.Call
}

// GeoRadiusByMemberStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - member string
//   - query *GeoRadiusQuery
func (_e *MockGeoCmdable_Expecter) GeoRadiusByMemberStore(ctx interface{}, key interface{}, member interface{}, query interface{}) *MockGeoCmdable_GeoRadiusByMemberStore_Call {
	return &MockGeoCmdable_GeoRadiusByMemberStore_Call{Call: _e.mock.On("GeoRadiusByMemberStore", ctx, key, member, query)}
}

func (_c *MockGeoCmdable_GeoRadiusByMemberStore_Call) Run(run func(ctx context.Context, key string, member string, query *GeoRadiusQuery)) *MockGeoCmdable_GeoRadiusByMemberStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusByMemberStore_Call) Return(_a0 *IntCmd) *MockGeoCmdable_GeoRadiusByMemberStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusByMemberStore_Call) RunAndReturn(run func(context.Context, string, string, *GeoRadiusQuery) *IntCmd) *MockGeoCmdable_GeoRadiusByMemberStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoRadiusStore provides a mock function with given fields: ctx, key, longitude, latitude, query
func (_m *MockGeoCmdable) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery) *IntCmd {
	ret := _m.Called(ctx, key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64, float64, *GeoRadiusQuery) *IntCmd); ok {
		r0 = rf(ctx, key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoRadiusStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoRadiusStore'
type MockGeoCmdable_GeoRadiusStore_Call struct {
	*mock.Call
}

// GeoRadiusStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - longitude float64
//   - latitude float64
//   - query *GeoRadiusQuery
func (_e *MockGeoCmdable_Expecter) GeoRadiusStore(ctx interface{}, key interface{}, longitude interface{}, latitude interface{}, query interface{}) *MockGeoCmdable_GeoRadiusStore_Call {
	return &MockGeoCmdable_GeoRadiusStore_Call{Call: _e.mock.On("GeoRadiusStore", ctx, key, longitude, latitude, query)}
}

func (_c *MockGeoCmdable_GeoRadiusStore_Call) Run(run func(ctx context.Context, key string, longitude float64, latitude float64, query *GeoRadiusQuery)) *MockGeoCmdable_GeoRadiusStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64), args[3].(float64), args[4].(*GeoRadiusQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusStore_Call) Return(_a0 *IntCmd) *MockGeoCmdable_GeoRadiusStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoRadiusStore_Call) RunAndReturn(run func(context.Context, string, float64, float64, *GeoRadiusQuery) *IntCmd) *MockGeoCmdable_GeoRadiusStore_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearch provides a mock function with given fields: ctx, key, q
func (_m *MockGeoCmdable) GeoSearch(ctx context.Context, key string, q *GeoSearchQuery) *StringSliceCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *GeoSearchQuery) *StringSliceCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearch'
type MockGeoCmdable_GeoSearch_Call struct {
	*mock.Call
}

// GeoSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *GeoSearchQuery
func (_e *MockGeoCmdable_Expecter) GeoSearch(ctx interface{}, key interface{}, q interface{}) *MockGeoCmdable_GeoSearch_Call {
	return &MockGeoCmdable_GeoSearch_Call{Call: _e.mock.On("GeoSearch", ctx, key, q)}
}

func (_c *MockGeoCmdable_GeoSearch_Call) Run(run func(ctx context.Context, key string, q *GeoSearchQuery)) *MockGeoCmdable_GeoSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*GeoSearchQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoSearch_Call) Return(_a0 *StringSliceCmd) *MockGeoCmdable_GeoSearch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoSearch_Call) RunAndReturn(run func(context.Context, string, *GeoSearchQuery) *StringSliceCmd) *MockGeoCmdable_GeoSearch_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchLocation provides a mock function with given fields: ctx, key, q
func (_m *MockGeoCmdable) GeoSearchLocation(ctx context.Context, key string, q *GeoSearchLocationQuery) *GeoSearchLocationCmd {
	ret := _m.Called(ctx, key, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchLocation")
	}

	var r0 *GeoSearchLocationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *GeoSearchLocationQuery) *GeoSearchLocationCmd); ok {
		r0 = rf(ctx, key, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*GeoSearchLocationCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoSearchLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchLocation'
type MockGeoCmdable_GeoSearchLocation_Call struct {
	*mock.Call
}

// GeoSearchLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - q *GeoSearchLocationQuery
func (_e *MockGeoCmdable_Expecter) GeoSearchLocation(ctx interface{}, key interface{}, q interface{}) *MockGeoCmdable_GeoSearchLocation_Call {
	return &MockGeoCmdable_GeoSearchLocation_Call{Call: _e.mock.On("GeoSearchLocation", ctx, key, q)}
}

func (_c *MockGeoCmdable_GeoSearchLocation_Call) Run(run func(ctx context.Context, key string, q *GeoSearchLocationQuery)) *MockGeoCmdable_GeoSearchLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*GeoSearchLocationQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoSearchLocation_Call) Return(_a0 *GeoSearchLocationCmd) *MockGeoCmdable_GeoSearchLocation_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoSearchLocation_Call) RunAndReturn(run func(context.Context, string, *GeoSearchLocationQuery) *GeoSearchLocationCmd) *MockGeoCmdable_GeoSearchLocation_Call {
	_c.Call.Return(run)
	return _c
}

// GeoSearchStore provides a mock function with given fields: ctx, key, store, q
func (_m *MockGeoCmdable) GeoSearchStore(ctx context.Context, key string, store string, q *GeoSearchStoreQuery) *IntCmd {
	ret := _m.Called(ctx, key, store, q)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearchStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *GeoSearchStoreQuery) *IntCmd); ok {
		r0 = rf(ctx, key, store, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGeoCmdable_GeoSearchStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GeoSearchStore'
type MockGeoCmdable_GeoSearchStore_Call struct {
	*mock.Call
}

// GeoSearchStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - q *GeoSearchStoreQuery
func (_e *MockGeoCmdable_Expecter) GeoSearchStore(ctx interface{}, key interface{}, store interface{}, q interface{}) *MockGeoCmdable_GeoSearchStore_Call {
	return &MockGeoCmdable_GeoSearchStore_Call{Call: _e.mock.On("GeoSearchStore", ctx, key, store, q)}
}

func (_c *MockGeoCmdable_GeoSearchStore_Call) Run(run func(ctx context.Context, key string, store string, q *GeoSearchStoreQuery)) *MockGeoCmdable_GeoSearchStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*GeoSearchStoreQuery))
	})
	return _c
}

func (_c *MockGeoCmdable_GeoSearchStore_Call) Return(_a0 *IntCmd) *MockGeoCmdable_GeoSearchStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGeoCmdable_GeoSearchStore_Call) RunAndReturn(run func(context.Context, string, string, *GeoSearchStoreQuery) *IntCmd) *MockGeoCmdable_GeoSearchStore_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGeoCmdable creates a new instance of MockGeoCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGeoCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGeoCmdable {
	mock := &MockGeoCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
