// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockPubSubCmdable is an autogenerated mock type for the PubSubCmdable type
type MockPubSubCmdable struct {
	mock.Mock
}

type MockPubSubCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPubSubCmdable) EXPECT() *MockPubSubCmdable_Expecter {
	return &MockPubSubCmdable_Expecter{mock: &_m.Mock}
}

// PubSubChannels provides a mock function with given fields: ctx, pattern
func (_m *MockPubSubCmdable) PubSubChannels(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_PubSubChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubChannels'
type MockPubSubCmdable_PubSubChannels_Call struct {
	*mock.Call
}

// PubSubChannels is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockPubSubCmdable_Expecter) PubSubChannels(ctx interface{}, pattern interface{}) *MockPubSubCmdable_PubSubChannels_Call {
	return &MockPubSubCmdable_PubSubChannels_Call{Call: _e.mock.On("PubSubChannels", ctx, pattern)}
}

func (_c *MockPubSubCmdable_PubSubChannels_Call) Run(run func(ctx context.Context, pattern string)) *MockPubSubCmdable_PubSubChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPubSubCmdable_PubSubChannels_Call) Return(_a0 *StringSliceCmd) *MockPubSubCmdable_PubSubChannels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_PubSubChannels_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPubSubCmdable_PubSubChannels_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumPat provides a mock function with given fields: ctx
func (_m *MockPubSubCmdable) PubSubNumPat(ctx context.Context) *IntCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context) *IntCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_PubSubNumPat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumPat'
type MockPubSubCmdable_PubSubNumPat_Call struct {
	*mock.Call
}

// PubSubNumPat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockPubSubCmdable_Expecter) PubSubNumPat(ctx interface{}) *MockPubSubCmdable_PubSubNumPat_Call {
	return &MockPubSubCmdable_PubSubNumPat_Call{Call: _e.mock.On("PubSubNumPat", ctx)}
}

func (_c *MockPubSubCmdable_PubSubNumPat_Call) Run(run func(ctx context.Context)) *MockPubSubCmdable_PubSubNumPat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockPubSubCmdable_PubSubNumPat_Call) Return(_a0 *IntCmd) *MockPubSubCmdable_PubSubNumPat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_PubSubNumPat_Call) RunAndReturn(run func(context.Context) *IntCmd) *MockPubSubCmdable_PubSubNumPat_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubNumSub provides a mock function with given fields: ctx, channels
func (_m *MockPubSubCmdable) PubSubNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringIntCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_PubSubNumSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubNumSub'
type MockPubSubCmdable_PubSubNumSub_Call struct {
	*mock.Call
}

// PubSubNumSub is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockPubSubCmdable_Expecter) PubSubNumSub(ctx interface{}, channels ...interface{}) *MockPubSubCmdable_PubSubNumSub_Call {
	return &MockPubSubCmdable_PubSubNumSub_Call{Call: _e.mock.On("PubSubNumSub",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockPubSubCmdable_PubSubNumSub_Call) Run(run func(ctx context.Context, channels ...string)) *MockPubSubCmdable_PubSubNumSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPubSubCmdable_PubSubNumSub_Call) Return(_a0 *MapStringIntCmd) *MockPubSubCmdable_PubSubNumSub_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_PubSubNumSub_Call) RunAndReturn(run func(context.Context, ...string) *MapStringIntCmd) *MockPubSubCmdable_PubSubNumSub_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubShardChannels provides a mock function with given fields: ctx, pattern
func (_m *MockPubSubCmdable) PubSubShardChannels(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardChannels")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_PubSubShardChannels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubShardChannels'
type MockPubSubCmdable_PubSubShardChannels_Call struct {
	*mock.Call
}

// PubSubShardChannels is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockPubSubCmdable_Expecter) PubSubShardChannels(ctx interface{}, pattern interface{}) *MockPubSubCmdable_PubSubShardChannels_Call {
	return &MockPubSubCmdable_PubSubShardChannels_Call{Call: _e.mock.On("PubSubShardChannels", ctx, pattern)}
}

func (_c *MockPubSubCmdable_PubSubShardChannels_Call) Run(run func(ctx context.Context, pattern string)) *MockPubSubCmdable_PubSubShardChannels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockPubSubCmdable_PubSubShardChannels_Call) Return(_a0 *StringSliceCmd) *MockPubSubCmdable_PubSubShardChannels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_PubSubShardChannels_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockPubSubCmdable_PubSubShardChannels_Call {
	_c.Call.Return(run)
	return _c
}

// PubSubShardNumSub provides a mock function with given fields: ctx, channels
func (_m *MockPubSubCmdable) PubSubShardNumSub(ctx context.Context, channels ...string) *MapStringIntCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubShardNumSub")
	}

	var r0 *MapStringIntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *MapStringIntCmd); ok {
		r0 = rf(ctx, channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringIntCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_PubSubShardNumSub_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PubSubShardNumSub'
type MockPubSubCmdable_PubSubShardNumSub_Call struct {
	*mock.Call
}

// PubSubShardNumSub is a helper method to define mock.On call
//   - ctx context.Context
//   - channels ...string
func (_e *MockPubSubCmdable_Expecter) PubSubShardNumSub(ctx interface{}, channels ...interface{}) *MockPubSubCmdable_PubSubShardNumSub_Call {
	return &MockPubSubCmdable_PubSubShardNumSub_Call{Call: _e.mock.On("PubSubShardNumSub",
		append([]interface{}{ctx}, channels...)...)}
}

func (_c *MockPubSubCmdable_PubSubShardNumSub_Call) Run(run func(ctx context.Context, channels ...string)) *MockPubSubCmdable_PubSubShardNumSub_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockPubSubCmdable_PubSubShardNumSub_Call) Return(_a0 *MapStringIntCmd) *MockPubSubCmdable_PubSubShardNumSub_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_PubSubShardNumSub_Call) RunAndReturn(run func(context.Context, ...string) *MapStringIntCmd) *MockPubSubCmdable_PubSubShardNumSub_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, channel, message
func (_m *MockPubSubCmdable) Publish(ctx context.Context, channel string, message interface{}) *IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockPubSubCmdable_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - message interface{}
func (_e *MockPubSubCmdable_Expecter) Publish(ctx interface{}, channel interface{}, message interface{}) *MockPubSubCmdable_Publish_Call {
	return &MockPubSubCmdable_Publish_Call{Call: _e.mock.On("Publish", ctx, channel, message)}
}

func (_c *MockPubSubCmdable_Publish_Call) Run(run func(ctx context.Context, channel string, message interface{})) *MockPubSubCmdable_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPubSubCmdable_Publish_Call) Return(_a0 *IntCmd) *MockPubSubCmdable_Publish_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_Publish_Call) RunAndReturn(run func(context.Context, string, interface{}) *IntCmd) *MockPubSubCmdable_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// SPublish provides a mock function with given fields: ctx, channel, message
func (_m *MockPubSubCmdable) SPublish(ctx context.Context, channel string, message interface{}) *IntCmd {
	ret := _m.Called(ctx, channel, message)

	if len(ret) == 0 {
		panic("no return value specified for SPublish")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *IntCmd); ok {
		r0 = rf(ctx, channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockPubSubCmdable_SPublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SPublish'
type MockPubSubCmdable_SPublish_Call struct {
	*mock.Call
}

// SPublish is a helper method to define mock.On call
//   - ctx context.Context
//   - channel string
//   - message interface{}
func (_e *MockPubSubCmdable_Expecter) SPublish(ctx interface{}, channel interface{}, message interface{}) *MockPubSubCmdable_SPublish_Call {
	return &MockPubSubCmdable_SPublish_Call{Call: _e.mock.On("SPublish", ctx, channel, message)}
}

func (_c *MockPubSubCmdable_SPublish_Call) Run(run func(ctx context.Context, channel string, message interface{})) *MockPubSubCmdable_SPublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockPubSubCmdable_SPublish_Call) Return(_a0 *IntCmd) *MockPubSubCmdable_SPublish_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockPubSubCmdable_SPublish_Call) RunAndReturn(run func(context.Context, string, interface{}) *IntCmd) *MockPubSubCmdable_SPublish_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPubSubCmdable creates a new instance of MockPubSubCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPubSubCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPubSubCmdable {
	mock := &MockPubSubCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
