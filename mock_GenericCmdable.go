// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockGenericCmdable is an autogenerated mock type for the GenericCmdable type
type MockGenericCmdable struct {
	mock.Mock
}

type MockGenericCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGenericCmdable) EXPECT() *MockGenericCmdable_Expecter {
	return &MockGenericCmdable_Expecter{mock: &_m.Mock}
}

// Copy provides a mock function with given fields: ctx, sourceKey, destKey, db, replace
func (_m *MockGenericCmdable) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *IntCmd {
	ret := _m.Called(ctx, sourceKey, destKey, db, replace)

	if len(ret) == 0 {
		panic("no return value specified for Copy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, bool) *IntCmd); ok {
		r0 = rf(ctx, sourceKey, destKey, db, replace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Copy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Copy'
type MockGenericCmdable_Copy_Call struct {
	*mock.Call
}

// Copy is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceKey string
//   - destKey string
//   - db int
//   - replace bool
func (_e *MockGenericCmdable_Expecter) Copy(ctx interface{}, sourceKey interface{}, destKey interface{}, db interface{}, replace interface{}) *MockGenericCmdable_Copy_Call {
	return &MockGenericCmdable_Copy_Call{Call: _e.mock.On("Copy", ctx, sourceKey, destKey, db, replace)}
}

func (_c *MockGenericCmdable_Copy_Call) Run(run func(ctx context.Context, sourceKey string, destKey string, db int, replace bool)) *MockGenericCmdable_Copy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(bool))
	})
	return _c
}

func (_c *MockGenericCmdable_Copy_Call) Return(_a0 *IntCmd) *MockGenericCmdable_Copy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Copy_Call) RunAndReturn(run func(context.Context, string, string, int, bool) *IntCmd) *MockGenericCmdable_Copy_Call {
	_c.Call.Return(run)
	return _c
}

// Del provides a mock function with given fields: ctx, keys
func (_m *MockGenericCmdable) Del(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Del_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Del'
type MockGenericCmdable_Del_Call struct {
	*mock.Call
}

// Del is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockGenericCmdable_Expecter) Del(ctx interface{}, keys ...interface{}) *MockGenericCmdable_Del_Call {
	return &MockGenericCmdable_Del_Call{Call: _e.mock.On("Del",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockGenericCmdable_Del_Call) Run(run func(ctx context.Context, keys ...string)) *MockGenericCmdable_Del_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockGenericCmdable_Del_Call) Return(_a0 *IntCmd) *MockGenericCmdable_Del_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Del_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockGenericCmdable_Del_Call {
	_c.Call.Return(run)
	return _c
}

// Dump provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) Dump(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Dump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dump'
type MockGenericCmdable_Dump_Call struct {
	*mock.Call
}

// Dump is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) Dump(ctx interface{}, key interface{}) *MockGenericCmdable_Dump_Call {
	return &MockGenericCmdable_Dump_Call{Call: _e.mock.On("Dump", ctx, key)}
}

func (_c *MockGenericCmdable_Dump_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_Dump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Dump_Call) Return(_a0 *StringCmd) *MockGenericCmdable_Dump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Dump_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockGenericCmdable_Dump_Call {
	_c.Call.Return(run)
	return _c
}

// Exists provides a mock function with given fields: ctx, keys
func (_m *MockGenericCmdable) Exists(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Exists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exists'
type MockGenericCmdable_Exists_Call struct {
	*mock.Call
}

// Exists is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockGenericCmdable_Expecter) Exists(ctx interface{}, keys ...interface{}) *MockGenericCmdable_Exists_Call {
	return &MockGenericCmdable_Exists_Call{Call: _e.mock.On("Exists",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockGenericCmdable_Exists_Call) Run(run func(ctx context.Context, keys ...string)) *MockGenericCmdable_Exists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockGenericCmdable_Exists_Call) Return(_a0 *IntCmd) *MockGenericCmdable_Exists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Exists_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockGenericCmdable_Exists_Call {
	_c.Call.Return(run)
	return _c
}

// Expire provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) Expire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Expire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Expire'
type MockGenericCmdable_Expire_Call struct {
	*mock.Call
}

// Expire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) Expire(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_Expire_Call {
	return &MockGenericCmdable_Expire_Call{Call: _e.mock.On("Expire", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_Expire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_Expire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_Expire_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_Expire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Expire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_Expire_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockGenericCmdable) ExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireAt'
type MockGenericCmdable_ExpireAt_Call struct {
	*mock.Call
}

// ExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockGenericCmdable_Expecter) ExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockGenericCmdable_ExpireAt_Call {
	return &MockGenericCmdable_ExpireAt_Call{Call: _e.mock.On("ExpireAt", ctx, key, tm)}
}

func (_c *MockGenericCmdable_ExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockGenericCmdable_ExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireAt_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_ExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *BoolCmd) *MockGenericCmdable_ExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireGT provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) ExpireGT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireGT")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireGT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireGT'
type MockGenericCmdable_ExpireGT_Call struct {
	*mock.Call
}

// ExpireGT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) ExpireGT(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_ExpireGT_Call {
	return &MockGenericCmdable_ExpireGT_Call{Call: _e.mock.On("ExpireGT", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_ExpireGT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_ExpireGT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireGT_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_ExpireGT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireGT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_ExpireGT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireLT provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) ExpireLT(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireLT")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireLT_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireLT'
type MockGenericCmdable_ExpireLT_Call struct {
	*mock.Call
}

// ExpireLT is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) ExpireLT(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_ExpireLT_Call {
	return &MockGenericCmdable_ExpireLT_Call{Call: _e.mock.On("ExpireLT", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_ExpireLT_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_ExpireLT_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireLT_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_ExpireLT_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireLT_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_ExpireLT_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireNX provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) ExpireNX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireNX'
type MockGenericCmdable_ExpireNX_Call struct {
	*mock.Call
}

// ExpireNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) ExpireNX(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_ExpireNX_Call {
	return &MockGenericCmdable_ExpireNX_Call{Call: _e.mock.On("ExpireNX", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_ExpireNX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_ExpireNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireNX_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_ExpireNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireNX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_ExpireNX_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireTime provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) ExpireTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ExpireTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireTime'
type MockGenericCmdable_ExpireTime_Call struct {
	*mock.Call
}

// ExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) ExpireTime(ctx interface{}, key interface{}) *MockGenericCmdable_ExpireTime_Call {
	return &MockGenericCmdable_ExpireTime_Call{Call: _e.mock.On("ExpireTime", ctx, key)}
}

func (_c *MockGenericCmdable_ExpireTime_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_ExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireTime_Call) Return(_a0 *DurationCmd) *MockGenericCmdable_ExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockGenericCmdable_ExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// ExpireXX provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) ExpireXX(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for ExpireXX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ExpireXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExpireXX'
type MockGenericCmdable_ExpireXX_Call struct {
	*mock.Call
}

// ExpireXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) ExpireXX(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_ExpireXX_Call {
	return &MockGenericCmdable_ExpireXX_Call{Call: _e.mock.On("ExpireXX", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_ExpireXX_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_ExpireXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_ExpireXX_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_ExpireXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ExpireXX_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_ExpireXX_Call {
	_c.Call.Return(run)
	return _c
}

// Keys provides a mock function with given fields: ctx, pattern
func (_m *MockGenericCmdable) Keys(ctx context.Context, pattern string) *StringSliceCmd {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringSliceCmd); ok {
		r0 = rf(ctx, pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Keys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Keys'
type MockGenericCmdable_Keys_Call struct {
	*mock.Call
}

// Keys is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockGenericCmdable_Expecter) Keys(ctx interface{}, pattern interface{}) *MockGenericCmdable_Keys_Call {
	return &MockGenericCmdable_Keys_Call{Call: _e.mock.On("Keys", ctx, pattern)}
}

func (_c *MockGenericCmdable_Keys_Call) Run(run func(ctx context.Context, pattern string)) *MockGenericCmdable_Keys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Keys_Call) Return(_a0 *StringSliceCmd) *MockGenericCmdable_Keys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Keys_Call) RunAndReturn(run func(context.Context, string) *StringSliceCmd) *MockGenericCmdable_Keys_Call {
	_c.Call.Return(run)
	return _c
}

// Migrate provides a mock function with given fields: ctx, host, port, key, db, timeout
func (_m *MockGenericCmdable) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *StatusCmd {
	ret := _m.Called(ctx, host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, int, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Migrate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Migrate'
type MockGenericCmdable_Migrate_Call struct {
	*mock.Call
}

// Migrate is a helper method to define mock.On call
//   - ctx context.Context
//   - host string
//   - port string
//   - key string
//   - db int
//   - timeout time.Duration
func (_e *MockGenericCmdable_Expecter) Migrate(ctx interface{}, host interface{}, port interface{}, key interface{}, db interface{}, timeout interface{}) *MockGenericCmdable_Migrate_Call {
	return &MockGenericCmdable_Migrate_Call{Call: _e.mock.On("Migrate", ctx, host, port, key, db, timeout)}
}

func (_c *MockGenericCmdable_Migrate_Call) Run(run func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration)) *MockGenericCmdable_Migrate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(int), args[5].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_Migrate_Call) Return(_a0 *StatusCmd) *MockGenericCmdable_Migrate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Migrate_Call) RunAndReturn(run func(context.Context, string, string, string, int, time.Duration) *StatusCmd) *MockGenericCmdable_Migrate_Call {
	_c.Call.Return(run)
	return _c
}

// Move provides a mock function with given fields: ctx, key, db
func (_m *MockGenericCmdable) Move(ctx context.Context, key string, db int) *BoolCmd {
	ret := _m.Called(ctx, key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int) *BoolCmd); ok {
		r0 = rf(ctx, key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Move_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Move'
type MockGenericCmdable_Move_Call struct {
	*mock.Call
}

// Move is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - db int
func (_e *MockGenericCmdable_Expecter) Move(ctx interface{}, key interface{}, db interface{}) *MockGenericCmdable_Move_Call {
	return &MockGenericCmdable_Move_Call{Call: _e.mock.On("Move", ctx, key, db)}
}

func (_c *MockGenericCmdable_Move_Call) Run(run func(ctx context.Context, key string, db int)) *MockGenericCmdable_Move_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockGenericCmdable_Move_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_Move_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Move_Call) RunAndReturn(run func(context.Context, string, int) *BoolCmd) *MockGenericCmdable_Move_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectEncoding provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) ObjectEncoding(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ObjectEncoding_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectEncoding'
type MockGenericCmdable_ObjectEncoding_Call struct {
	*mock.Call
}

// ObjectEncoding is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) ObjectEncoding(ctx interface{}, key interface{}) *MockGenericCmdable_ObjectEncoding_Call {
	return &MockGenericCmdable_ObjectEncoding_Call{Call: _e.mock.On("ObjectEncoding", ctx, key)}
}

func (_c *MockGenericCmdable_ObjectEncoding_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_ObjectEncoding_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ObjectEncoding_Call) Return(_a0 *StringCmd) *MockGenericCmdable_ObjectEncoding_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ObjectEncoding_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockGenericCmdable_ObjectEncoding_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectFreq provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) ObjectFreq(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectFreq")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ObjectFreq_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectFreq'
type MockGenericCmdable_ObjectFreq_Call struct {
	*mock.Call
}

// ObjectFreq is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) ObjectFreq(ctx interface{}, key interface{}) *MockGenericCmdable_ObjectFreq_Call {
	return &MockGenericCmdable_ObjectFreq_Call{Call: _e.mock.On("ObjectFreq", ctx, key)}
}

func (_c *MockGenericCmdable_ObjectFreq_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_ObjectFreq_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ObjectFreq_Call) Return(_a0 *IntCmd) *MockGenericCmdable_ObjectFreq_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ObjectFreq_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockGenericCmdable_ObjectFreq_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectIdleTime provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) ObjectIdleTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ObjectIdleTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectIdleTime'
type MockGenericCmdable_ObjectIdleTime_Call struct {
	*mock.Call
}

// ObjectIdleTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) ObjectIdleTime(ctx interface{}, key interface{}) *MockGenericCmdable_ObjectIdleTime_Call {
	return &MockGenericCmdable_ObjectIdleTime_Call{Call: _e.mock.On("ObjectIdleTime", ctx, key)}
}

func (_c *MockGenericCmdable_ObjectIdleTime_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_ObjectIdleTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ObjectIdleTime_Call) Return(_a0 *DurationCmd) *MockGenericCmdable_ObjectIdleTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ObjectIdleTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockGenericCmdable_ObjectIdleTime_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectRefCount provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) ObjectRefCount(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ObjectRefCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectRefCount'
type MockGenericCmdable_ObjectRefCount_Call struct {
	*mock.Call
}

// ObjectRefCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) ObjectRefCount(ctx interface{}, key interface{}) *MockGenericCmdable_ObjectRefCount_Call {
	return &MockGenericCmdable_ObjectRefCount_Call{Call: _e.mock.On("ObjectRefCount", ctx, key)}
}

func (_c *MockGenericCmdable_ObjectRefCount_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_ObjectRefCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ObjectRefCount_Call) Return(_a0 *IntCmd) *MockGenericCmdable_ObjectRefCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ObjectRefCount_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockGenericCmdable_ObjectRefCount_Call {
	_c.Call.Return(run)
	return _c
}

// PExpire provides a mock function with given fields: ctx, key, expiration
func (_m *MockGenericCmdable) PExpire(ctx context.Context, key string, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_PExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpire'
type MockGenericCmdable_PExpire_Call struct {
	*mock.Call
}

// PExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockGenericCmdable_Expecter) PExpire(ctx interface{}, key interface{}, expiration interface{}) *MockGenericCmdable_PExpire_Call {
	return &MockGenericCmdable_PExpire_Call{Call: _e.mock.On("PExpire", ctx, key, expiration)}
}

func (_c *MockGenericCmdable_PExpire_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockGenericCmdable_PExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockGenericCmdable_PExpire_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_PExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_PExpire_Call) RunAndReturn(run func(context.Context, string, time.Duration) *BoolCmd) *MockGenericCmdable_PExpire_Call {
	_c.Call.Return(run)
	return _c
}

// PExpireAt provides a mock function with given fields: ctx, key, tm
func (_m *MockGenericCmdable) PExpireAt(ctx context.Context, key string, tm time.Time) *BoolCmd {
	ret := _m.Called(ctx, key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Time) *BoolCmd); ok {
		r0 = rf(ctx, key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_PExpireAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpireAt'
type MockGenericCmdable_PExpireAt_Call struct {
	*mock.Call
}

// PExpireAt is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - tm time.Time
func (_e *MockGenericCmdable_Expecter) PExpireAt(ctx interface{}, key interface{}, tm interface{}) *MockGenericCmdable_PExpireAt_Call {
	return &MockGenericCmdable_PExpireAt_Call{Call: _e.mock.On("PExpireAt", ctx, key, tm)}
}

func (_c *MockGenericCmdable_PExpireAt_Call) Run(run func(ctx context.Context, key string, tm time.Time)) *MockGenericCmdable_PExpireAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Time))
	})
	return _c
}

func (_c *MockGenericCmdable_PExpireAt_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_PExpireAt_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_PExpireAt_Call) RunAndReturn(run func(context.Context, string, time.Time) *BoolCmd) *MockGenericCmdable_PExpireAt_Call {
	_c.Call.Return(run)
	return _c
}

// PExpireTime provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) PExpireTime(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PExpireTime")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockGenericCmdable_PExpireTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PExpireTime'
type MockGenericCmdable_PExpireTime_Call struct {
	*mock.Call
}

// PExpireTime is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) PExpireTime(ctx interface{}, key interface{}) *MockGenericCmdable_PExpireTime_Call {
	return &MockGenericCmdable_PExpireTime_Call{Call: _e.mock.On("PExpireTime", ctx, key)}
}

func (_c *MockGenericCmdable_PExpireTime_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_PExpireTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_PExpireTime_Call) Return(_a0 *DurationCmd) *MockGenericCmdable_PExpireTime_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_PExpireTime_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockGenericCmdable_PExpireTime_Call {
	_c.Call.Return(run)
	return _c
}

// PTTL provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) PTTL(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockGenericCmdable_PTTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PTTL'
type MockGenericCmdable_PTTL_Call struct {
	*mock.Call
}

// PTTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) PTTL(ctx interface{}, key interface{}) *MockGenericCmdable_PTTL_Call {
	return &MockGenericCmdable_PTTL_Call{Call: _e.mock.On("PTTL", ctx, key)}
}

func (_c *MockGenericCmdable_PTTL_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_PTTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_PTTL_Call) Return(_a0 *DurationCmd) *MockGenericCmdable_PTTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_PTTL_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockGenericCmdable_PTTL_Call {
	_c.Call.Return(run)
	return _c
}

// Persist provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) Persist(ctx context.Context, key string) *BoolCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *BoolCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Persist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Persist'
type MockGenericCmdable_Persist_Call struct {
	*mock.Call
}

// Persist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) Persist(ctx interface{}, key interface{}) *MockGenericCmdable_Persist_Call {
	return &MockGenericCmdable_Persist_Call{Call: _e.mock.On("Persist", ctx, key)}
}

func (_c *MockGenericCmdable_Persist_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_Persist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Persist_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_Persist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Persist_Call) RunAndReturn(run func(context.Context, string) *BoolCmd) *MockGenericCmdable_Persist_Call {
	_c.Call.Return(run)
	return _c
}

// RandomKey provides a mock function with given fields: ctx
func (_m *MockGenericCmdable) RandomKey(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockGenericCmdable_RandomKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RandomKey'
type MockGenericCmdable_RandomKey_Call struct {
	*mock.Call
}

// RandomKey is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGenericCmdable_Expecter) RandomKey(ctx interface{}) *MockGenericCmdable_RandomKey_Call {
	return &MockGenericCmdable_RandomKey_Call{Call: _e.mock.On("RandomKey", ctx)}
}

func (_c *MockGenericCmdable_RandomKey_Call) Run(run func(ctx context.Context)) *MockGenericCmdable_RandomKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGenericCmdable_RandomKey_Call) Return(_a0 *StringCmd) *MockGenericCmdable_RandomKey_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_RandomKey_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockGenericCmdable_RandomKey_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: ctx, key, newkey
func (_m *MockGenericCmdable) Rename(ctx context.Context, key string, newkey string) *StatusCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *StatusCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type MockGenericCmdable_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockGenericCmdable_Expecter) Rename(ctx interface{}, key interface{}, newkey interface{}) *MockGenericCmdable_Rename_Call {
	return &MockGenericCmdable_Rename_Call{Call: _e.mock.On("Rename", ctx, key, newkey)}
}

func (_c *MockGenericCmdable_Rename_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockGenericCmdable_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Rename_Call) Return(_a0 *StatusCmd) *MockGenericCmdable_Rename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Rename_Call) RunAndReturn(run func(context.Context, string, string) *StatusCmd) *MockGenericCmdable_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// RenameNX provides a mock function with given fields: ctx, key, newkey
func (_m *MockGenericCmdable) RenameNX(ctx context.Context, key string, newkey string) *BoolCmd {
	ret := _m.Called(ctx, key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *BoolCmd); ok {
		r0 = rf(ctx, key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockGenericCmdable_RenameNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RenameNX'
type MockGenericCmdable_RenameNX_Call struct {
	*mock.Call
}

// RenameNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - newkey string
func (_e *MockGenericCmdable_Expecter) RenameNX(ctx interface{}, key interface{}, newkey interface{}) *MockGenericCmdable_RenameNX_Call {
	return &MockGenericCmdable_RenameNX_Call{Call: _e.mock.On("RenameNX", ctx, key, newkey)}
}

func (_c *MockGenericCmdable_RenameNX_Call) Run(run func(ctx context.Context, key string, newkey string)) *MockGenericCmdable_RenameNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_RenameNX_Call) Return(_a0 *BoolCmd) *MockGenericCmdable_RenameNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_RenameNX_Call) RunAndReturn(run func(context.Context, string, string) *BoolCmd) *MockGenericCmdable_RenameNX_Call {
	_c.Call.Return(run)
	return _c
}

// Restore provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockGenericCmdable) Restore(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Restore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Restore'
type MockGenericCmdable_Restore_Call struct {
	*mock.Call
}

// Restore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockGenericCmdable_Expecter) Restore(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockGenericCmdable_Restore_Call {
	return &MockGenericCmdable_Restore_Call{Call: _e.mock.On("Restore", ctx, key, ttl, value)}
}

func (_c *MockGenericCmdable_Restore_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockGenericCmdable_Restore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Restore_Call) Return(_a0 *StatusCmd) *MockGenericCmdable_Restore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Restore_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *StatusCmd) *MockGenericCmdable_Restore_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreReplace provides a mock function with given fields: ctx, key, ttl, value
func (_m *MockGenericCmdable) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *StatusCmd {
	ret := _m.Called(ctx, key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, string) *StatusCmd); ok {
		r0 = rf(ctx, key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGenericCmdable_RestoreReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreReplace'
type MockGenericCmdable_RestoreReplace_Call struct {
	*mock.Call
}

// RestoreReplace is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - ttl time.Duration
//   - value string
func (_e *MockGenericCmdable_Expecter) RestoreReplace(ctx interface{}, key interface{}, ttl interface{}, value interface{}) *MockGenericCmdable_RestoreReplace_Call {
	return &MockGenericCmdable_RestoreReplace_Call{Call: _e.mock.On("RestoreReplace", ctx, key, ttl, value)}
}

func (_c *MockGenericCmdable_RestoreReplace_Call) Run(run func(ctx context.Context, key string, ttl time.Duration, value string)) *MockGenericCmdable_RestoreReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_RestoreReplace_Call) Return(_a0 *StatusCmd) *MockGenericCmdable_RestoreReplace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_RestoreReplace_Call) RunAndReturn(run func(context.Context, string, time.Duration, string) *StatusCmd) *MockGenericCmdable_RestoreReplace_Call {
	_c.Call.Return(run)
	return _c
}

// Scan provides a mock function with given fields: ctx, cursor, match, count
func (_m *MockGenericCmdable) Scan(ctx context.Context, cursor uint64, match string, count int64) *ScanCmd {
	ret := _m.Called(ctx, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64) *ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Scan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Scan'
type MockGenericCmdable_Scan_Call struct {
	*mock.Call
}

// Scan is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
func (_e *MockGenericCmdable_Expecter) Scan(ctx interface{}, cursor interface{}, match interface{}, count interface{}) *MockGenericCmdable_Scan_Call {
	return &MockGenericCmdable_Scan_Call{Call: _e.mock.On("Scan", ctx, cursor, match, count)}
}

func (_c *MockGenericCmdable_Scan_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64)) *MockGenericCmdable_Scan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64))
	})
	return _c
}

func (_c *MockGenericCmdable_Scan_Call) Return(_a0 *ScanCmd) *MockGenericCmdable_Scan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Scan_Call) RunAndReturn(run func(context.Context, uint64, string, int64) *ScanCmd) *MockGenericCmdable_Scan_Call {
	_c.Call.Return(run)
	return _c
}

// ScanType provides a mock function with given fields: ctx, cursor, match, count, keyType
func (_m *MockGenericCmdable) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *ScanCmd {
	ret := _m.Called(ctx, cursor, match, count, keyType)

	if len(ret) == 0 {
		panic("no return value specified for ScanType")
	}

	var r0 *ScanCmd
	if rf, ok := ret.Get(0).(func(context.Context, uint64, string, int64, string) *ScanCmd); ok {
		r0 = rf(ctx, cursor, match, count, keyType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ScanCmd)
		}
	}

	return r0
}

// MockGenericCmdable_ScanType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScanType'
type MockGenericCmdable_ScanType_Call struct {
	*mock.Call
}

// ScanType is a helper method to define mock.On call
//   - ctx context.Context
//   - cursor uint64
//   - match string
//   - count int64
//   - keyType string
func (_e *MockGenericCmdable_Expecter) ScanType(ctx interface{}, cursor interface{}, match interface{}, count interface{}, keyType interface{}) *MockGenericCmdable_ScanType_Call {
	return &MockGenericCmdable_ScanType_Call{Call: _e.mock.On("ScanType", ctx, cursor, match, count, keyType)}
}

func (_c *MockGenericCmdable_ScanType_Call) Run(run func(ctx context.Context, cursor uint64, match string, count int64, keyType string)) *MockGenericCmdable_ScanType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64), args[2].(string), args[3].(int64), args[4].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_ScanType_Call) Return(_a0 *ScanCmd) *MockGenericCmdable_ScanType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_ScanType_Call) RunAndReturn(run func(context.Context, uint64, string, int64, string) *ScanCmd) *MockGenericCmdable_ScanType_Call {
	_c.Call.Return(run)
	return _c
}

// Sort provides a mock function with given fields: ctx, key, sort
func (_m *MockGenericCmdable) Sort(ctx context.Context, key string, sort *Sort) *StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Sort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Sort'
type MockGenericCmdable_Sort_Call struct {
	*mock.Call
}

// Sort is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockGenericCmdable_Expecter) Sort(ctx interface{}, key interface{}, sort interface{}) *MockGenericCmdable_Sort_Call {
	return &MockGenericCmdable_Sort_Call{Call: _e.mock.On("Sort", ctx, key, sort)}
}

func (_c *MockGenericCmdable_Sort_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockGenericCmdable_Sort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockGenericCmdable_Sort_Call) Return(_a0 *StringSliceCmd) *MockGenericCmdable_Sort_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Sort_Call) RunAndReturn(run func(context.Context, string, *Sort) *StringSliceCmd) *MockGenericCmdable_Sort_Call {
	_c.Call.Return(run)
	return _c
}

// SortInterfaces provides a mock function with given fields: ctx, key, sort
func (_m *MockGenericCmdable) SortInterfaces(ctx context.Context, key string, sort *Sort) *SliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *SliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockGenericCmdable_SortInterfaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortInterfaces'
type MockGenericCmdable_SortInterfaces_Call struct {
	*mock.Call
}

// SortInterfaces is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockGenericCmdable_Expecter) SortInterfaces(ctx interface{}, key interface{}, sort interface{}) *MockGenericCmdable_SortInterfaces_Call {
	return &MockGenericCmdable_SortInterfaces_Call{Call: _e.mock.On("SortInterfaces", ctx, key, sort)}
}

func (_c *MockGenericCmdable_SortInterfaces_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockGenericCmdable_SortInterfaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockGenericCmdable_SortInterfaces_Call) Return(_a0 *SliceCmd) *MockGenericCmdable_SortInterfaces_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_SortInterfaces_Call) RunAndReturn(run func(context.Context, string, *Sort) *SliceCmd) *MockGenericCmdable_SortInterfaces_Call {
	_c.Call.Return(run)
	return _c
}

// SortRO provides a mock function with given fields: ctx, key, sort
func (_m *MockGenericCmdable) SortRO(ctx context.Context, key string, sort *Sort) *StringSliceCmd {
	ret := _m.Called(ctx, key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortRO")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *Sort) *StringSliceCmd); ok {
		r0 = rf(ctx, key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockGenericCmdable_SortRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortRO'
type MockGenericCmdable_SortRO_Call struct {
	*mock.Call
}

// SortRO is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - sort *Sort
func (_e *MockGenericCmdable_Expecter) SortRO(ctx interface{}, key interface{}, sort interface{}) *MockGenericCmdable_SortRO_Call {
	return &MockGenericCmdable_SortRO_Call{Call: _e.mock.On("SortRO", ctx, key, sort)}
}

func (_c *MockGenericCmdable_SortRO_Call) Run(run func(ctx context.Context, key string, sort *Sort)) *MockGenericCmdable_SortRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*Sort))
	})
	return _c
}

func (_c *MockGenericCmdable_SortRO_Call) Return(_a0 *StringSliceCmd) *MockGenericCmdable_SortRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_SortRO_Call) RunAndReturn(run func(context.Context, string, *Sort) *StringSliceCmd) *MockGenericCmdable_SortRO_Call {
	_c.Call.Return(run)
	return _c
}

// SortStore provides a mock function with given fields: ctx, key, store, sort
func (_m *MockGenericCmdable) SortStore(ctx context.Context, key string, store string, sort *Sort) *IntCmd {
	ret := _m.Called(ctx, key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *Sort) *IntCmd); ok {
		r0 = rf(ctx, key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_SortStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SortStore'
type MockGenericCmdable_SortStore_Call struct {
	*mock.Call
}

// SortStore is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - store string
//   - sort *Sort
func (_e *MockGenericCmdable_Expecter) SortStore(ctx interface{}, key interface{}, store interface{}, sort interface{}) *MockGenericCmdable_SortStore_Call {
	return &MockGenericCmdable_SortStore_Call{Call: _e.mock.On("SortStore", ctx, key, store, sort)}
}

func (_c *MockGenericCmdable_SortStore_Call) Run(run func(ctx context.Context, key string, store string, sort *Sort)) *MockGenericCmdable_SortStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*Sort))
	})
	return _c
}

func (_c *MockGenericCmdable_SortStore_Call) Return(_a0 *IntCmd) *MockGenericCmdable_SortStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_SortStore_Call) RunAndReturn(run func(context.Context, string, string, *Sort) *IntCmd) *MockGenericCmdable_SortStore_Call {
	_c.Call.Return(run)
	return _c
}

// TTL provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) TTL(ctx context.Context, key string) *DurationCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *DurationCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *DurationCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DurationCmd)
		}
	}

	return r0
}

// MockGenericCmdable_TTL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TTL'
type MockGenericCmdable_TTL_Call struct {
	*mock.Call
}

// TTL is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) TTL(ctx interface{}, key interface{}) *MockGenericCmdable_TTL_Call {
	return &MockGenericCmdable_TTL_Call{Call: _e.mock.On("TTL", ctx, key)}
}

func (_c *MockGenericCmdable_TTL_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_TTL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_TTL_Call) Return(_a0 *DurationCmd) *MockGenericCmdable_TTL_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_TTL_Call) RunAndReturn(run func(context.Context, string) *DurationCmd) *MockGenericCmdable_TTL_Call {
	_c.Call.Return(run)
	return _c
}

// Touch provides a mock function with given fields: ctx, keys
func (_m *MockGenericCmdable) Touch(ctx context.Context, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *IntCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Touch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Touch'
type MockGenericCmdable_Touch_Call struct {
	*mock.Call
}

// Touch is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockGenericCmdable_Expecter) Touch(ctx interface{}, keys ...interface{}) *MockGenericCmdable_Touch_Call {
	return &MockGenericCmdable_Touch_Call{Call: _e.mock.On("Touch",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockGenericCmdable_Touch_Call) Run(run func(ctx context.Context, keys ...string)) *MockGenericCmdable_Touch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockGenericCmdable_Touch_Call) Return(_a0 *IntCmd) *MockGenericCmdable_Touch_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Touch_Call) RunAndReturn(run func(context.Context, ...string) *IntCmd) *MockGenericCmdable_Touch_Call {
	_c.Call.Return(run)
	return _c
}

// Type provides a mock function with given fields: ctx, key
func (_m *MockGenericCmdable) Type(ctx context.Context, key string) *StatusCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGenericCmdable_Type_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Type'
type MockGenericCmdable_Type_Call struct {
	*mock.Call
}

// Type is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockGenericCmdable_Expecter) Type(ctx interface{}, key interface{}) *MockGenericCmdable_Type_Call {
	return &MockGenericCmdable_Type_Call{Call: _e.mock.On("Type", ctx, key)}
}

func (_c *MockGenericCmdable_Type_Call) Run(run func(ctx context.Context, key string)) *MockGenericCmdable_Type_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGenericCmdable_Type_Call) Return(_a0 *StatusCmd) *MockGenericCmdable_Type_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGenericCmdable_Type_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockGenericCmdable_Type_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGenericCmdable creates a new instance of MockGenericCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGenericCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGenericCmdable {
	mock := &MockGenericCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
