// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockScriptingFunctionsCmdable is an autogenerated mock type for the ScriptingFunctionsCmdable type
type MockScriptingFunctionsCmdable struct {
	mock.Mock
}

type MockScriptingFunctionsCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockScriptingFunctionsCmdable) EXPECT() *MockScriptingFunctionsCmdable_Expecter {
	return &MockScriptingFunctionsCmdable_Expecter{mock: &_m.Mock}
}

// Eval provides a mock function with given fields: ctx, script, keys, args
func (_m *MockScriptingFunctionsCmdable) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_Eval_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Eval'
type MockScriptingFunctionsCmdable_Eval_Call struct {
	*mock.Call
}

// Eval is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) Eval(ctx interface{}, script interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_Eval_Call {
	return &MockScriptingFunctionsCmdable_Eval_Call{Call: _e.mock.On("Eval",
		append([]interface{}{ctx, script, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_Eval_Call) Run(run func(ctx context.Context, script string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_Eval_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_Eval_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_Eval_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_Eval_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_Eval_Call {
	_c.Call.Return(run)
	return _c
}

// EvalRO provides a mock function with given fields: ctx, script, keys, args
func (_m *MockScriptingFunctionsCmdable) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_EvalRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalRO'
type MockScriptingFunctionsCmdable_EvalRO_Call struct {
	*mock.Call
}

// EvalRO is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) EvalRO(ctx interface{}, script interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_EvalRO_Call {
	return &MockScriptingFunctionsCmdable_EvalRO_Call{Call: _e.mock.On("EvalRO",
		append([]interface{}{ctx, script, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_EvalRO_Call) Run(run func(ctx context.Context, script string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_EvalRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalRO_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_EvalRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_EvalRO_Call {
	_c.Call.Return(run)
	return _c
}

// EvalSha provides a mock function with given fields: ctx, sha1, keys, args
func (_m *MockScriptingFunctionsCmdable) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_EvalSha_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalSha'
type MockScriptingFunctionsCmdable_EvalSha_Call struct {
	*mock.Call
}

// EvalSha is a helper method to define mock.On call
//   - ctx context.Context
//   - sha1 string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) EvalSha(ctx interface{}, sha1 interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_EvalSha_Call {
	return &MockScriptingFunctionsCmdable_EvalSha_Call{Call: _e.mock.On("EvalSha",
		append([]interface{}{ctx, sha1, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_EvalSha_Call) Run(run func(ctx context.Context, sha1 string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_EvalSha_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalSha_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_EvalSha_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalSha_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_EvalSha_Call {
	_c.Call.Return(run)
	return _c
}

// EvalShaRO provides a mock function with given fields: ctx, sha1, keys, args
func (_m *MockScriptingFunctionsCmdable) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalShaRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_EvalShaRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EvalShaRO'
type MockScriptingFunctionsCmdable_EvalShaRO_Call struct {
	*mock.Call
}

// EvalShaRO is a helper method to define mock.On call
//   - ctx context.Context
//   - sha1 string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) EvalShaRO(ctx interface{}, sha1 interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_EvalShaRO_Call {
	return &MockScriptingFunctionsCmdable_EvalShaRO_Call{Call: _e.mock.On("EvalShaRO",
		append([]interface{}{ctx, sha1, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_EvalShaRO_Call) Run(run func(ctx context.Context, sha1 string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_EvalShaRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalShaRO_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_EvalShaRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_EvalShaRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_EvalShaRO_Call {
	_c.Call.Return(run)
	return _c
}

// FCall provides a mock function with given fields: ctx, function, keys, args
func (_m *MockScriptingFunctionsCmdable) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCall")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCall'
type MockScriptingFunctionsCmdable_FCall_Call struct {
	*mock.Call
}

// FCall is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) FCall(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_FCall_Call {
	return &MockScriptingFunctionsCmdable_FCall_Call{Call: _e.mock.On("FCall",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_FCall_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_FCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCall_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_FCall_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCall_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_FCall_Call {
	_c.Call.Return(run)
	return _c
}

// FCallRO provides a mock function with given fields: ctx, function, keys, args
func (_m *MockScriptingFunctionsCmdable) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRO")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FCallRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCallRO'
type MockScriptingFunctionsCmdable_FCallRO_Call struct {
	*mock.Call
}

// FCallRO is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) FCallRO(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_FCallRO_Call {
	return &MockScriptingFunctionsCmdable_FCallRO_Call{Call: _e.mock.On("FCallRO",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_FCallRO_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_FCallRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCallRO_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_FCallRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCallRO_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_FCallRO_Call {
	_c.Call.Return(run)
	return _c
}

// FCallRo provides a mock function with given fields: ctx, function, keys, args
func (_m *MockScriptingFunctionsCmdable) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *Cmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, function, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FCallRo")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, ...interface{}) *Cmd); ok {
		r0 = rf(ctx, function, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FCallRo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FCallRo'
type MockScriptingFunctionsCmdable_FCallRo_Call struct {
	*mock.Call
}

// FCallRo is a helper method to define mock.On call
//   - ctx context.Context
//   - function string
//   - keys []string
//   - args ...interface{}
func (_e *MockScriptingFunctionsCmdable_Expecter) FCallRo(ctx interface{}, function interface{}, keys interface{}, args ...interface{}) *MockScriptingFunctionsCmdable_FCallRo_Call {
	return &MockScriptingFunctionsCmdable_FCallRo_Call{Call: _e.mock.On("FCallRo",
		append([]interface{}{ctx, function, keys}, args...)...)}
}

func (_c *MockScriptingFunctionsCmdable_FCallRo_Call) Run(run func(ctx context.Context, function string, keys []string, args ...interface{})) *MockScriptingFunctionsCmdable_FCallRo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]string), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCallRo_Call) Return(_a0 *Cmd) *MockScriptingFunctionsCmdable_FCallRo_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FCallRo_Call) RunAndReturn(run func(context.Context, string, []string, ...interface{}) *Cmd) *MockScriptingFunctionsCmdable_FCallRo_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionDelete provides a mock function with given fields: ctx, libName
func (_m *MockScriptingFunctionsCmdable) FunctionDelete(ctx context.Context, libName string) *StringCmd {
	ret := _m.Called(ctx, libName)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDelete")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, libName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionDelete'
type MockScriptingFunctionsCmdable_FunctionDelete_Call struct {
	*mock.Call
}

// FunctionDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionDelete(ctx interface{}, libName interface{}) *MockScriptingFunctionsCmdable_FunctionDelete_Call {
	return &MockScriptingFunctionsCmdable_FunctionDelete_Call{Call: _e.mock.On("FunctionDelete", ctx, libName)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionDelete_Call) Run(run func(ctx context.Context, libName string)) *MockScriptingFunctionsCmdable_FunctionDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionDelete_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionDelete_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockScriptingFunctionsCmdable_FunctionDelete_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionDump provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) FunctionDump(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionDump")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionDump_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionDump'
type MockScriptingFunctionsCmdable_FunctionDump_Call struct {
	*mock.Call
}

// FunctionDump is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionDump(ctx interface{}) *MockScriptingFunctionsCmdable_FunctionDump_Call {
	return &MockScriptingFunctionsCmdable_FunctionDump_Call{Call: _e.mock.On("FunctionDump", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionDump_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_FunctionDump_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionDump_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionDump_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionDump_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockScriptingFunctionsCmdable_FunctionDump_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionFlush provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) FunctionFlush(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlush")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionFlush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionFlush'
type MockScriptingFunctionsCmdable_FunctionFlush_Call struct {
	*mock.Call
}

// FunctionFlush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionFlush(ctx interface{}) *MockScriptingFunctionsCmdable_FunctionFlush_Call {
	return &MockScriptingFunctionsCmdable_FunctionFlush_Call{Call: _e.mock.On("FunctionFlush", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlush_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_FunctionFlush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlush_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionFlush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlush_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockScriptingFunctionsCmdable_FunctionFlush_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionFlushAsync provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) FunctionFlushAsync(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionFlushAsync")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionFlushAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionFlushAsync'
type MockScriptingFunctionsCmdable_FunctionFlushAsync_Call struct {
	*mock.Call
}

// FunctionFlushAsync is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionFlushAsync(ctx interface{}) *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call {
	return &MockScriptingFunctionsCmdable_FunctionFlushAsync_Call{Call: _e.mock.On("FunctionFlushAsync", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockScriptingFunctionsCmdable_FunctionFlushAsync_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionKill provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) FunctionKill(ctx context.Context) *StringCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionKill")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionKill'
type MockScriptingFunctionsCmdable_FunctionKill_Call struct {
	*mock.Call
}

// FunctionKill is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionKill(ctx interface{}) *MockScriptingFunctionsCmdable_FunctionKill_Call {
	return &MockScriptingFunctionsCmdable_FunctionKill_Call{Call: _e.mock.On("FunctionKill", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionKill_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_FunctionKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionKill_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionKill_Call) RunAndReturn(run func(context.Context) *StringCmd) *MockScriptingFunctionsCmdable_FunctionKill_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionList provides a mock function with given fields: ctx, q
func (_m *MockScriptingFunctionsCmdable) FunctionList(ctx context.Context, q FunctionListQuery) *FunctionListCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for FunctionList")
	}

	var r0 *FunctionListCmd
	if rf, ok := ret.Get(0).(func(context.Context, FunctionListQuery) *FunctionListCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FunctionListCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionList'
type MockScriptingFunctionsCmdable_FunctionList_Call struct {
	*mock.Call
}

// FunctionList is a helper method to define mock.On call
//   - ctx context.Context
//   - q FunctionListQuery
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionList(ctx interface{}, q interface{}) *MockScriptingFunctionsCmdable_FunctionList_Call {
	return &MockScriptingFunctionsCmdable_FunctionList_Call{Call: _e.mock.On("FunctionList", ctx, q)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionList_Call) Run(run func(ctx context.Context, q FunctionListQuery)) *MockScriptingFunctionsCmdable_FunctionList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(FunctionListQuery))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionList_Call) Return(_a0 *FunctionListCmd) *MockScriptingFunctionsCmdable_FunctionList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionList_Call) RunAndReturn(run func(context.Context, FunctionListQuery) *FunctionListCmd) *MockScriptingFunctionsCmdable_FunctionList_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionLoad provides a mock function with given fields: ctx, code
func (_m *MockScriptingFunctionsCmdable) FunctionLoad(ctx context.Context, code string) *StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoad")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionLoad'
type MockScriptingFunctionsCmdable_FunctionLoad_Call struct {
	*mock.Call
}

// FunctionLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionLoad(ctx interface{}, code interface{}) *MockScriptingFunctionsCmdable_FunctionLoad_Call {
	return &MockScriptingFunctionsCmdable_FunctionLoad_Call{Call: _e.mock.On("FunctionLoad", ctx, code)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoad_Call) Run(run func(ctx context.Context, code string)) *MockScriptingFunctionsCmdable_FunctionLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoad_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoad_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockScriptingFunctionsCmdable_FunctionLoad_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionLoadReplace provides a mock function with given fields: ctx, code
func (_m *MockScriptingFunctionsCmdable) FunctionLoadReplace(ctx context.Context, code string) *StringCmd {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for FunctionLoadReplace")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionLoadReplace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionLoadReplace'
type MockScriptingFunctionsCmdable_FunctionLoadReplace_Call struct {
	*mock.Call
}

// FunctionLoadReplace is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionLoadReplace(ctx interface{}, code interface{}) *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call {
	return &MockScriptingFunctionsCmdable_FunctionLoadReplace_Call{Call: _e.mock.On("FunctionLoadReplace", ctx, code)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call) Run(run func(ctx context.Context, code string)) *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockScriptingFunctionsCmdable_FunctionLoadReplace_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionRestore provides a mock function with given fields: ctx, libDump
func (_m *MockScriptingFunctionsCmdable) FunctionRestore(ctx context.Context, libDump string) *StringCmd {
	ret := _m.Called(ctx, libDump)

	if len(ret) == 0 {
		panic("no return value specified for FunctionRestore")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, libDump)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionRestore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionRestore'
type MockScriptingFunctionsCmdable_FunctionRestore_Call struct {
	*mock.Call
}

// FunctionRestore is a helper method to define mock.On call
//   - ctx context.Context
//   - libDump string
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionRestore(ctx interface{}, libDump interface{}) *MockScriptingFunctionsCmdable_FunctionRestore_Call {
	return &MockScriptingFunctionsCmdable_FunctionRestore_Call{Call: _e.mock.On("FunctionRestore", ctx, libDump)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionRestore_Call) Run(run func(ctx context.Context, libDump string)) *MockScriptingFunctionsCmdable_FunctionRestore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionRestore_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_FunctionRestore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionRestore_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockScriptingFunctionsCmdable_FunctionRestore_Call {
	_c.Call.Return(run)
	return _c
}

// FunctionStats provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) FunctionStats(ctx context.Context) *FunctionStatsCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for FunctionStats")
	}

	var r0 *FunctionStatsCmd
	if rf, ok := ret.Get(0).(func(context.Context) *FunctionStatsCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FunctionStatsCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_FunctionStats_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FunctionStats'
type MockScriptingFunctionsCmdable_FunctionStats_Call struct {
	*mock.Call
}

// FunctionStats is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) FunctionStats(ctx interface{}) *MockScriptingFunctionsCmdable_FunctionStats_Call {
	return &MockScriptingFunctionsCmdable_FunctionStats_Call{Call: _e.mock.On("FunctionStats", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_FunctionStats_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_FunctionStats_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionStats_Call) Return(_a0 *FunctionStatsCmd) *MockScriptingFunctionsCmdable_FunctionStats_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_FunctionStats_Call) RunAndReturn(run func(context.Context) *FunctionStatsCmd) *MockScriptingFunctionsCmdable_FunctionStats_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptExists provides a mock function with given fields: ctx, hashes
func (_m *MockScriptingFunctionsCmdable) ScriptExists(ctx context.Context, hashes ...string) *BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *BoolSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *BoolSliceCmd); ok {
		r0 = rf(ctx, hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolSliceCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_ScriptExists_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptExists'
type MockScriptingFunctionsCmdable_ScriptExists_Call struct {
	*mock.Call
}

// ScriptExists is a helper method to define mock.On call
//   - ctx context.Context
//   - hashes ...string
func (_e *MockScriptingFunctionsCmdable_Expecter) ScriptExists(ctx interface{}, hashes ...interface{}) *MockScriptingFunctionsCmdable_ScriptExists_Call {
	return &MockScriptingFunctionsCmdable_ScriptExists_Call{Call: _e.mock.On("ScriptExists",
		append([]interface{}{ctx}, hashes...)...)}
}

func (_c *MockScriptingFunctionsCmdable_ScriptExists_Call) Run(run func(ctx context.Context, hashes ...string)) *MockScriptingFunctionsCmdable_ScriptExists_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptExists_Call) Return(_a0 *BoolSliceCmd) *MockScriptingFunctionsCmdable_ScriptExists_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptExists_Call) RunAndReturn(run func(context.Context, ...string) *BoolSliceCmd) *MockScriptingFunctionsCmdable_ScriptExists_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptFlush provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) ScriptFlush(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_ScriptFlush_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptFlush'
type MockScriptingFunctionsCmdable_ScriptFlush_Call struct {
	*mock.Call
}

// ScriptFlush is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) ScriptFlush(ctx interface{}) *MockScriptingFunctionsCmdable_ScriptFlush_Call {
	return &MockScriptingFunctionsCmdable_ScriptFlush_Call{Call: _e.mock.On("ScriptFlush", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_ScriptFlush_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_ScriptFlush_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptFlush_Call) Return(_a0 *StatusCmd) *MockScriptingFunctionsCmdable_ScriptFlush_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptFlush_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockScriptingFunctionsCmdable_ScriptFlush_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptKill provides a mock function with given fields: ctx
func (_m *MockScriptingFunctionsCmdable) ScriptKill(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_ScriptKill_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptKill'
type MockScriptingFunctionsCmdable_ScriptKill_Call struct {
	*mock.Call
}

// ScriptKill is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockScriptingFunctionsCmdable_Expecter) ScriptKill(ctx interface{}) *MockScriptingFunctionsCmdable_ScriptKill_Call {
	return &MockScriptingFunctionsCmdable_ScriptKill_Call{Call: _e.mock.On("ScriptKill", ctx)}
}

func (_c *MockScriptingFunctionsCmdable_ScriptKill_Call) Run(run func(ctx context.Context)) *MockScriptingFunctionsCmdable_ScriptKill_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptKill_Call) Return(_a0 *StatusCmd) *MockScriptingFunctionsCmdable_ScriptKill_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptKill_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockScriptingFunctionsCmdable_ScriptKill_Call {
	_c.Call.Return(run)
	return _c
}

// ScriptLoad provides a mock function with given fields: ctx, script
func (_m *MockScriptingFunctionsCmdable) ScriptLoad(ctx context.Context, script string) *StringCmd {
	ret := _m.Called(ctx, script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockScriptingFunctionsCmdable_ScriptLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ScriptLoad'
type MockScriptingFunctionsCmdable_ScriptLoad_Call struct {
	*mock.Call
}

// ScriptLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - script string
func (_e *MockScriptingFunctionsCmdable_Expecter) ScriptLoad(ctx interface{}, script interface{}) *MockScriptingFunctionsCmdable_ScriptLoad_Call {
	return &MockScriptingFunctionsCmdable_ScriptLoad_Call{Call: _e.mock.On("ScriptLoad", ctx, script)}
}

func (_c *MockScriptingFunctionsCmdable_ScriptLoad_Call) Run(run func(ctx context.Context, script string)) *MockScriptingFunctionsCmdable_ScriptLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptLoad_Call) Return(_a0 *StringCmd) *MockScriptingFunctionsCmdable_ScriptLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockScriptingFunctionsCmdable_ScriptLoad_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockScriptingFunctionsCmdable_ScriptLoad_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockScriptingFunctionsCmdable creates a new instance of MockScriptingFunctionsCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockScriptingFunctionsCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockScriptingFunctionsCmdable {
	mock := &MockScriptingFunctionsCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
