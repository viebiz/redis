// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"
	time "time"

	mock "github.com/stretchr/testify/mock"
)

// MockStringCmdable is an autogenerated mock type for the StringCmdable type
type MockStringCmdable struct {
	mock.Mock
}

type MockStringCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStringCmdable) EXPECT() *MockStringCmdable_Expecter {
	return &MockStringCmdable_Expecter{mock: &_m.Mock}
}

// Append provides a mock function with given fields: ctx, key, value
func (_m *MockStringCmdable) Append(ctx context.Context, key string, value string) *IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_Append_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Append'
type MockStringCmdable_Append_Call struct {
	*mock.Call
}

// Append is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
func (_e *MockStringCmdable_Expecter) Append(ctx interface{}, key interface{}, value interface{}) *MockStringCmdable_Append_Call {
	return &MockStringCmdable_Append_Call{Call: _e.mock.On("Append", ctx, key, value)}
}

func (_c *MockStringCmdable_Append_Call) Run(run func(ctx context.Context, key string, value string)) *MockStringCmdable_Append_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockStringCmdable_Append_Call) Return(_a0 *IntCmd) *MockStringCmdable_Append_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_Append_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockStringCmdable_Append_Call {
	_c.Call.Return(run)
	return _c
}

// Decr provides a mock function with given fields: ctx, key
func (_m *MockStringCmdable) Decr(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_Decr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Decr'
type MockStringCmdable_Decr_Call struct {
	*mock.Call
}

// Decr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStringCmdable_Expecter) Decr(ctx interface{}, key interface{}) *MockStringCmdable_Decr_Call {
	return &MockStringCmdable_Decr_Call{Call: _e.mock.On("Decr", ctx, key)}
}

func (_c *MockStringCmdable_Decr_Call) Run(run func(ctx context.Context, key string)) *MockStringCmdable_Decr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStringCmdable_Decr_Call) Return(_a0 *IntCmd) *MockStringCmdable_Decr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_Decr_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockStringCmdable_Decr_Call {
	_c.Call.Return(run)
	return _c
}

// DecrBy provides a mock function with given fields: ctx, key, decrement
func (_m *MockStringCmdable) DecrBy(ctx context.Context, key string, decrement int64) *IntCmd {
	ret := _m.Called(ctx, key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_DecrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DecrBy'
type MockStringCmdable_DecrBy_Call struct {
	*mock.Call
}

// DecrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - decrement int64
func (_e *MockStringCmdable_Expecter) DecrBy(ctx interface{}, key interface{}, decrement interface{}) *MockStringCmdable_DecrBy_Call {
	return &MockStringCmdable_DecrBy_Call{Call: _e.mock.On("DecrBy", ctx, key, decrement)}
}

func (_c *MockStringCmdable_DecrBy_Call) Run(run func(ctx context.Context, key string, decrement int64)) *MockStringCmdable_DecrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockStringCmdable_DecrBy_Call) Return(_a0 *IntCmd) *MockStringCmdable_DecrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_DecrBy_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockStringCmdable_DecrBy_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, key
func (_m *MockStringCmdable) Get(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockStringCmdable_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockStringCmdable_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStringCmdable_Expecter) Get(ctx interface{}, key interface{}) *MockStringCmdable_Get_Call {
	return &MockStringCmdable_Get_Call{Call: _e.mock.On("Get", ctx, key)}
}

func (_c *MockStringCmdable_Get_Call) Run(run func(ctx context.Context, key string)) *MockStringCmdable_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStringCmdable_Get_Call) Return(_a0 *StringCmd) *MockStringCmdable_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_Get_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockStringCmdable_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetDel provides a mock function with given fields: ctx, key
func (_m *MockStringCmdable) GetDel(ctx context.Context, key string) *StringCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetDel")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StringCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockStringCmdable_GetDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDel'
type MockStringCmdable_GetDel_Call struct {
	*mock.Call
}

// GetDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStringCmdable_Expecter) GetDel(ctx interface{}, key interface{}) *MockStringCmdable_GetDel_Call {
	return &MockStringCmdable_GetDel_Call{Call: _e.mock.On("GetDel", ctx, key)}
}

func (_c *MockStringCmdable_GetDel_Call) Run(run func(ctx context.Context, key string)) *MockStringCmdable_GetDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStringCmdable_GetDel_Call) Return(_a0 *StringCmd) *MockStringCmdable_GetDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_GetDel_Call) RunAndReturn(run func(context.Context, string) *StringCmd) *MockStringCmdable_GetDel_Call {
	_c.Call.Return(run)
	return _c
}

// GetEx provides a mock function with given fields: ctx, key, expiration
func (_m *MockStringCmdable) GetEx(ctx context.Context, key string, expiration time.Duration) *StringCmd {
	ret := _m.Called(ctx, key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for GetEx")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration) *StringCmd); ok {
		r0 = rf(ctx, key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockStringCmdable_GetEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEx'
type MockStringCmdable_GetEx_Call struct {
	*mock.Call
}

// GetEx is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - expiration time.Duration
func (_e *MockStringCmdable_Expecter) GetEx(ctx interface{}, key interface{}, expiration interface{}) *MockStringCmdable_GetEx_Call {
	return &MockStringCmdable_GetEx_Call{Call: _e.mock.On("GetEx", ctx, key, expiration)}
}

func (_c *MockStringCmdable_GetEx_Call) Run(run func(ctx context.Context, key string, expiration time.Duration)) *MockStringCmdable_GetEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration))
	})
	return _c
}

func (_c *MockStringCmdable_GetEx_Call) Return(_a0 *StringCmd) *MockStringCmdable_GetEx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_GetEx_Call) RunAndReturn(run func(context.Context, string, time.Duration) *StringCmd) *MockStringCmdable_GetEx_Call {
	_c.Call.Return(run)
	return _c
}

// GetRange provides a mock function with given fields: ctx, key, start, end
func (_m *MockStringCmdable) GetRange(ctx context.Context, key string, start int64, end int64) *StringCmd {
	ret := _m.Called(ctx, key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int64) *StringCmd); ok {
		r0 = rf(ctx, key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockStringCmdable_GetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRange'
type MockStringCmdable_GetRange_Call struct {
	*mock.Call
}

// GetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - start int64
//   - end int64
func (_e *MockStringCmdable_Expecter) GetRange(ctx interface{}, key interface{}, start interface{}, end interface{}) *MockStringCmdable_GetRange_Call {
	return &MockStringCmdable_GetRange_Call{Call: _e.mock.On("GetRange", ctx, key, start, end)}
}

func (_c *MockStringCmdable_GetRange_Call) Run(run func(ctx context.Context, key string, start int64, end int64)) *MockStringCmdable_GetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int64))
	})
	return _c
}

func (_c *MockStringCmdable_GetRange_Call) Return(_a0 *StringCmd) *MockStringCmdable_GetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_GetRange_Call) RunAndReturn(run func(context.Context, string, int64, int64) *StringCmd) *MockStringCmdable_GetRange_Call {
	_c.Call.Return(run)
	return _c
}

// GetSet provides a mock function with given fields: ctx, key, value
func (_m *MockStringCmdable) GetSet(ctx context.Context, key string, value interface{}) *StringCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) *StringCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockStringCmdable_GetSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSet'
type MockStringCmdable_GetSet_Call struct {
	*mock.Call
}

// GetSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *MockStringCmdable_Expecter) GetSet(ctx interface{}, key interface{}, value interface{}) *MockStringCmdable_GetSet_Call {
	return &MockStringCmdable_GetSet_Call{Call: _e.mock.On("GetSet", ctx, key, value)}
}

func (_c *MockStringCmdable_GetSet_Call) Run(run func(ctx context.Context, key string, value interface{})) *MockStringCmdable_GetSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *MockStringCmdable_GetSet_Call) Return(_a0 *StringCmd) *MockStringCmdable_GetSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_GetSet_Call) RunAndReturn(run func(context.Context, string, interface{}) *StringCmd) *MockStringCmdable_GetSet_Call {
	_c.Call.Return(run)
	return _c
}

// Incr provides a mock function with given fields: ctx, key
func (_m *MockStringCmdable) Incr(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_Incr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Incr'
type MockStringCmdable_Incr_Call struct {
	*mock.Call
}

// Incr is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStringCmdable_Expecter) Incr(ctx interface{}, key interface{}) *MockStringCmdable_Incr_Call {
	return &MockStringCmdable_Incr_Call{Call: _e.mock.On("Incr", ctx, key)}
}

func (_c *MockStringCmdable_Incr_Call) Run(run func(ctx context.Context, key string)) *MockStringCmdable_Incr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStringCmdable_Incr_Call) Return(_a0 *IntCmd) *MockStringCmdable_Incr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_Incr_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockStringCmdable_Incr_Call {
	_c.Call.Return(run)
	return _c
}

// IncrBy provides a mock function with given fields: ctx, key, value
func (_m *MockStringCmdable) IncrBy(ctx context.Context, key string, value int64) *IntCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_IncrBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrBy'
type MockStringCmdable_IncrBy_Call struct {
	*mock.Call
}

// IncrBy is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value int64
func (_e *MockStringCmdable_Expecter) IncrBy(ctx interface{}, key interface{}, value interface{}) *MockStringCmdable_IncrBy_Call {
	return &MockStringCmdable_IncrBy_Call{Call: _e.mock.On("IncrBy", ctx, key, value)}
}

func (_c *MockStringCmdable_IncrBy_Call) Run(run func(ctx context.Context, key string, value int64)) *MockStringCmdable_IncrBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockStringCmdable_IncrBy_Call) Return(_a0 *IntCmd) *MockStringCmdable_IncrBy_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_IncrBy_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockStringCmdable_IncrBy_Call {
	_c.Call.Return(run)
	return _c
}

// IncrByFloat provides a mock function with given fields: ctx, key, value
func (_m *MockStringCmdable) IncrByFloat(ctx context.Context, key string, value float64) *FloatCmd {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *FloatCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, float64) *FloatCmd); ok {
		r0 = rf(ctx, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*FloatCmd)
		}
	}

	return r0
}

// MockStringCmdable_IncrByFloat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrByFloat'
type MockStringCmdable_IncrByFloat_Call struct {
	*mock.Call
}

// IncrByFloat is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value float64
func (_e *MockStringCmdable_Expecter) IncrByFloat(ctx interface{}, key interface{}, value interface{}) *MockStringCmdable_IncrByFloat_Call {
	return &MockStringCmdable_IncrByFloat_Call{Call: _e.mock.On("IncrByFloat", ctx, key, value)}
}

func (_c *MockStringCmdable_IncrByFloat_Call) Run(run func(ctx context.Context, key string, value float64)) *MockStringCmdable_IncrByFloat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(float64))
	})
	return _c
}

func (_c *MockStringCmdable_IncrByFloat_Call) Return(_a0 *FloatCmd) *MockStringCmdable_IncrByFloat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_IncrByFloat_Call) RunAndReturn(run func(context.Context, string, float64) *FloatCmd) *MockStringCmdable_IncrByFloat_Call {
	_c.Call.Return(run)
	return _c
}

// LCS provides a mock function with given fields: ctx, q
func (_m *MockStringCmdable) LCS(ctx context.Context, q *LCSQuery) *LCSCmd {
	ret := _m.Called(ctx, q)

	if len(ret) == 0 {
		panic("no return value specified for LCS")
	}

	var r0 *LCSCmd
	if rf, ok := ret.Get(0).(func(context.Context, *LCSQuery) *LCSCmd); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*LCSCmd)
		}
	}

	return r0
}

// MockStringCmdable_LCS_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LCS'
type MockStringCmdable_LCS_Call struct {
	*mock.Call
}

// LCS is a helper method to define mock.On call
//   - ctx context.Context
//   - q *LCSQuery
func (_e *MockStringCmdable_Expecter) LCS(ctx interface{}, q interface{}) *MockStringCmdable_LCS_Call {
	return &MockStringCmdable_LCS_Call{Call: _e.mock.On("LCS", ctx, q)}
}

func (_c *MockStringCmdable_LCS_Call) Run(run func(ctx context.Context, q *LCSQuery)) *MockStringCmdable_LCS_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*LCSQuery))
	})
	return _c
}

func (_c *MockStringCmdable_LCS_Call) Return(_a0 *LCSCmd) *MockStringCmdable_LCS_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_LCS_Call) RunAndReturn(run func(context.Context, *LCSQuery) *LCSCmd) *MockStringCmdable_LCS_Call {
	_c.Call.Return(run)
	return _c
}

// MGet provides a mock function with given fields: ctx, keys
func (_m *MockStringCmdable) MGet(ctx context.Context, keys ...string) *SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *SliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...string) *SliceCmd); ok {
		r0 = rf(ctx, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*SliceCmd)
		}
	}

	return r0
}

// MockStringCmdable_MGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MGet'
type MockStringCmdable_MGet_Call struct {
	*mock.Call
}

// MGet is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *MockStringCmdable_Expecter) MGet(ctx interface{}, keys ...interface{}) *MockStringCmdable_MGet_Call {
	return &MockStringCmdable_MGet_Call{Call: _e.mock.On("MGet",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *MockStringCmdable_MGet_Call) Run(run func(ctx context.Context, keys ...string)) *MockStringCmdable_MGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockStringCmdable_MGet_Call) Return(_a0 *SliceCmd) *MockStringCmdable_MGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_MGet_Call) RunAndReturn(run func(context.Context, ...string) *SliceCmd) *MockStringCmdable_MGet_Call {
	_c.Call.Return(run)
	return _c
}

// MSet provides a mock function with given fields: ctx, values
func (_m *MockStringCmdable) MSet(ctx context.Context, values ...interface{}) *StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *StatusCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockStringCmdable_MSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSet'
type MockStringCmdable_MSet_Call struct {
	*mock.Call
}

// MSet is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockStringCmdable_Expecter) MSet(ctx interface{}, values ...interface{}) *MockStringCmdable_MSet_Call {
	return &MockStringCmdable_MSet_Call{Call: _e.mock.On("MSet",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockStringCmdable_MSet_Call) Run(run func(ctx context.Context, values ...interface{})) *MockStringCmdable_MSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockStringCmdable_MSet_Call) Return(_a0 *StatusCmd) *MockStringCmdable_MSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_MSet_Call) RunAndReturn(run func(context.Context, ...interface{}) *StatusCmd) *MockStringCmdable_MSet_Call {
	_c.Call.Return(run)
	return _c
}

// MSetNX provides a mock function with given fields: ctx, values
func (_m *MockStringCmdable) MSetNX(ctx context.Context, values ...interface{}) *BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, ...interface{}) *BoolCmd); ok {
		r0 = rf(ctx, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockStringCmdable_MSetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MSetNX'
type MockStringCmdable_MSetNX_Call struct {
	*mock.Call
}

// MSetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - values ...interface{}
func (_e *MockStringCmdable_Expecter) MSetNX(ctx interface{}, values ...interface{}) *MockStringCmdable_MSetNX_Call {
	return &MockStringCmdable_MSetNX_Call{Call: _e.mock.On("MSetNX",
		append([]interface{}{ctx}, values...)...)}
}

func (_c *MockStringCmdable_MSetNX_Call) Run(run func(ctx context.Context, values ...interface{})) *MockStringCmdable_MSetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockStringCmdable_MSetNX_Call) Return(_a0 *BoolCmd) *MockStringCmdable_MSetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_MSetNX_Call) RunAndReturn(run func(context.Context, ...interface{}) *BoolCmd) *MockStringCmdable_MSetNX_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockStringCmdable) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockStringCmdable_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type MockStringCmdable_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockStringCmdable_Expecter) Set(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockStringCmdable_Set_Call {
	return &MockStringCmdable_Set_Call{Call: _e.mock.On("Set", ctx, key, value, expiration)}
}

func (_c *MockStringCmdable_Set_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockStringCmdable_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStringCmdable_Set_Call) Return(_a0 *StatusCmd) *MockStringCmdable_Set_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_Set_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *StatusCmd) *MockStringCmdable_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetArgs provides a mock function with given fields: ctx, key, value, a
func (_m *MockStringCmdable) SetArgs(ctx context.Context, key string, value interface{}, a SetArgs) *StatusCmd {
	ret := _m.Called(ctx, key, value, a)

	if len(ret) == 0 {
		panic("no return value specified for SetArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, SetArgs) *StatusCmd); ok {
		r0 = rf(ctx, key, value, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockStringCmdable_SetArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetArgs'
type MockStringCmdable_SetArgs_Call struct {
	*mock.Call
}

// SetArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - a SetArgs
func (_e *MockStringCmdable_Expecter) SetArgs(ctx interface{}, key interface{}, value interface{}, a interface{}) *MockStringCmdable_SetArgs_Call {
	return &MockStringCmdable_SetArgs_Call{Call: _e.mock.On("SetArgs", ctx, key, value, a)}
}

func (_c *MockStringCmdable_SetArgs_Call) Run(run func(ctx context.Context, key string, value interface{}, a SetArgs)) *MockStringCmdable_SetArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(SetArgs))
	})
	return _c
}

func (_c *MockStringCmdable_SetArgs_Call) Return(_a0 *StatusCmd) *MockStringCmdable_SetArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_SetArgs_Call) RunAndReturn(run func(context.Context, string, interface{}, SetArgs) *StatusCmd) *MockStringCmdable_SetArgs_Call {
	_c.Call.Return(run)
	return _c
}

// SetEx provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockStringCmdable) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *StatusCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetEx")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *StatusCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockStringCmdable_SetEx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEx'
type MockStringCmdable_SetEx_Call struct {
	*mock.Call
}

// SetEx is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockStringCmdable_Expecter) SetEx(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockStringCmdable_SetEx_Call {
	return &MockStringCmdable_SetEx_Call{Call: _e.mock.On("SetEx", ctx, key, value, expiration)}
}

func (_c *MockStringCmdable_SetEx_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockStringCmdable_SetEx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStringCmdable_SetEx_Call) Return(_a0 *StatusCmd) *MockStringCmdable_SetEx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_SetEx_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *StatusCmd) *MockStringCmdable_SetEx_Call {
	_c.Call.Return(run)
	return _c
}

// SetNX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockStringCmdable) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockStringCmdable_SetNX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNX'
type MockStringCmdable_SetNX_Call struct {
	*mock.Call
}

// SetNX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockStringCmdable_Expecter) SetNX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockStringCmdable_SetNX_Call {
	return &MockStringCmdable_SetNX_Call{Call: _e.mock.On("SetNX", ctx, key, value, expiration)}
}

func (_c *MockStringCmdable_SetNX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockStringCmdable_SetNX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStringCmdable_SetNX_Call) Return(_a0 *BoolCmd) *MockStringCmdable_SetNX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_SetNX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *BoolCmd) *MockStringCmdable_SetNX_Call {
	_c.Call.Return(run)
	return _c
}

// SetRange provides a mock function with given fields: ctx, key, offset, value
func (_m *MockStringCmdable) SetRange(ctx context.Context, key string, offset int64, value string) *IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, string) *IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_SetRange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRange'
type MockStringCmdable_SetRange_Call struct {
	*mock.Call
}

// SetRange is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value string
func (_e *MockStringCmdable_Expecter) SetRange(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockStringCmdable_SetRange_Call {
	return &MockStringCmdable_SetRange_Call{Call: _e.mock.On("SetRange", ctx, key, offset, value)}
}

func (_c *MockStringCmdable_SetRange_Call) Run(run func(ctx context.Context, key string, offset int64, value string)) *MockStringCmdable_SetRange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *MockStringCmdable_SetRange_Call) Return(_a0 *IntCmd) *MockStringCmdable_SetRange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_SetRange_Call) RunAndReturn(run func(context.Context, string, int64, string) *IntCmd) *MockStringCmdable_SetRange_Call {
	_c.Call.Return(run)
	return _c
}

// SetXX provides a mock function with given fields: ctx, key, value, expiration
func (_m *MockStringCmdable) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd {
	ret := _m.Called(ctx, key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *BoolCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) *BoolCmd); ok {
		r0 = rf(ctx, key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*BoolCmd)
		}
	}

	return r0
}

// MockStringCmdable_SetXX_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetXX'
type MockStringCmdable_SetXX_Call struct {
	*mock.Call
}

// SetXX is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expiration time.Duration
func (_e *MockStringCmdable_Expecter) SetXX(ctx interface{}, key interface{}, value interface{}, expiration interface{}) *MockStringCmdable_SetXX_Call {
	return &MockStringCmdable_SetXX_Call{Call: _e.mock.On("SetXX", ctx, key, value, expiration)}
}

func (_c *MockStringCmdable_SetXX_Call) Run(run func(ctx context.Context, key string, value interface{}, expiration time.Duration)) *MockStringCmdable_SetXX_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *MockStringCmdable_SetXX_Call) Return(_a0 *BoolCmd) *MockStringCmdable_SetXX_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_SetXX_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) *BoolCmd) *MockStringCmdable_SetXX_Call {
	_c.Call.Return(run)
	return _c
}

// StrLen provides a mock function with given fields: ctx, key
func (_m *MockStringCmdable) StrLen(ctx context.Context, key string) *IntCmd {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockStringCmdable_StrLen_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StrLen'
type MockStringCmdable_StrLen_Call struct {
	*mock.Call
}

// StrLen is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *MockStringCmdable_Expecter) StrLen(ctx interface{}, key interface{}) *MockStringCmdable_StrLen_Call {
	return &MockStringCmdable_StrLen_Call{Call: _e.mock.On("StrLen", ctx, key)}
}

func (_c *MockStringCmdable_StrLen_Call) Run(run func(ctx context.Context, key string)) *MockStringCmdable_StrLen_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStringCmdable_StrLen_Call) Return(_a0 *IntCmd) *MockStringCmdable_StrLen_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStringCmdable_StrLen_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockStringCmdable_StrLen_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStringCmdable creates a new instance of MockStringCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStringCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStringCmdable {
	mock := &MockStringCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
