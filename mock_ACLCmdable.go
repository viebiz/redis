// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockACLCmdable is an autogenerated mock type for the ACLCmdable type
type MockACLCmdable struct {
	mock.Mock
}

type MockACLCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockACLCmdable) EXPECT() *MockACLCmdable_Expecter {
	return &MockACLCmdable_Expecter{mock: &_m.Mock}
}

// ACLCat provides a mock function with given fields: ctx
func (_m *MockACLCmdable) ACLCat(ctx context.Context) *StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLCat")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLCat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLCat'
type MockACLCmdable_ACLCat_Call struct {
	*mock.Call
}

// ACLCat is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockACLCmdable_Expecter) ACLCat(ctx interface{}) *MockACLCmdable_ACLCat_Call {
	return &MockACLCmdable_ACLCat_Call{Call: _e.mock.On("ACLCat", ctx)}
}

func (_c *MockACLCmdable_ACLCat_Call) Run(run func(ctx context.Context)) *MockACLCmdable_ACLCat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockACLCmdable_ACLCat_Call) Return(_a0 *StringSliceCmd) *MockACLCmdable_ACLCat_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLCat_Call) RunAndReturn(run func(context.Context) *StringSliceCmd) *MockACLCmdable_ACLCat_Call {
	_c.Call.Return(run)
	return _c
}

// ACLCatArgs provides a mock function with given fields: ctx, options
func (_m *MockACLCmdable) ACLCatArgs(ctx context.Context, options *ACLCatArgs) *StringSliceCmd {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for ACLCatArgs")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *ACLCatArgs) *StringSliceCmd); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLCatArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLCatArgs'
type MockACLCmdable_ACLCatArgs_Call struct {
	*mock.Call
}

// ACLCatArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - options *ACLCatArgs
func (_e *MockACLCmdable_Expecter) ACLCatArgs(ctx interface{}, options interface{}) *MockACLCmdable_ACLCatArgs_Call {
	return &MockACLCmdable_ACLCatArgs_Call{Call: _e.mock.On("ACLCatArgs", ctx, options)}
}

func (_c *MockACLCmdable_ACLCatArgs_Call) Run(run func(ctx context.Context, options *ACLCatArgs)) *MockACLCmdable_ACLCatArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ACLCatArgs))
	})
	return _c
}

func (_c *MockACLCmdable_ACLCatArgs_Call) Return(_a0 *StringSliceCmd) *MockACLCmdable_ACLCatArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLCatArgs_Call) RunAndReturn(run func(context.Context, *ACLCatArgs) *StringSliceCmd) *MockACLCmdable_ACLCatArgs_Call {
	_c.Call.Return(run)
	return _c
}

// ACLDelUser provides a mock function with given fields: ctx, username
func (_m *MockACLCmdable) ACLDelUser(ctx context.Context, username string) *IntCmd {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for ACLDelUser")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *IntCmd); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLDelUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLDelUser'
type MockACLCmdable_ACLDelUser_Call struct {
	*mock.Call
}

// ACLDelUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockACLCmdable_Expecter) ACLDelUser(ctx interface{}, username interface{}) *MockACLCmdable_ACLDelUser_Call {
	return &MockACLCmdable_ACLDelUser_Call{Call: _e.mock.On("ACLDelUser", ctx, username)}
}

func (_c *MockACLCmdable_ACLDelUser_Call) Run(run func(ctx context.Context, username string)) *MockACLCmdable_ACLDelUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockACLCmdable_ACLDelUser_Call) Return(_a0 *IntCmd) *MockACLCmdable_ACLDelUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLDelUser_Call) RunAndReturn(run func(context.Context, string) *IntCmd) *MockACLCmdable_ACLDelUser_Call {
	_c.Call.Return(run)
	return _c
}

// ACLDryRun provides a mock function with given fields: ctx, username, command
func (_m *MockACLCmdable) ACLDryRun(ctx context.Context, username string, command ...interface{}) *StringCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, command...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLDryRun")
	}

	var r0 *StringCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *StringCmd); ok {
		r0 = rf(ctx, username, command...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLDryRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLDryRun'
type MockACLCmdable_ACLDryRun_Call struct {
	*mock.Call
}

// ACLDryRun is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - command ...interface{}
func (_e *MockACLCmdable_Expecter) ACLDryRun(ctx interface{}, username interface{}, command ...interface{}) *MockACLCmdable_ACLDryRun_Call {
	return &MockACLCmdable_ACLDryRun_Call{Call: _e.mock.On("ACLDryRun",
		append([]interface{}{ctx, username}, command...)...)}
}

func (_c *MockACLCmdable_ACLDryRun_Call) Run(run func(ctx context.Context, username string, command ...interface{})) *MockACLCmdable_ACLDryRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockACLCmdable_ACLDryRun_Call) Return(_a0 *StringCmd) *MockACLCmdable_ACLDryRun_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLDryRun_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *StringCmd) *MockACLCmdable_ACLDryRun_Call {
	_c.Call.Return(run)
	return _c
}

// ACLList provides a mock function with given fields: ctx
func (_m *MockACLCmdable) ACLList(ctx context.Context) *StringSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLList")
	}

	var r0 *StringSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StringSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StringSliceCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLList'
type MockACLCmdable_ACLList_Call struct {
	*mock.Call
}

// ACLList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockACLCmdable_Expecter) ACLList(ctx interface{}) *MockACLCmdable_ACLList_Call {
	return &MockACLCmdable_ACLList_Call{Call: _e.mock.On("ACLList", ctx)}
}

func (_c *MockACLCmdable_ACLList_Call) Run(run func(ctx context.Context)) *MockACLCmdable_ACLList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockACLCmdable_ACLList_Call) Return(_a0 *StringSliceCmd) *MockACLCmdable_ACLList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLList_Call) RunAndReturn(run func(context.Context) *StringSliceCmd) *MockACLCmdable_ACLList_Call {
	_c.Call.Return(run)
	return _c
}

// ACLLog provides a mock function with given fields: ctx, count
func (_m *MockACLCmdable) ACLLog(ctx context.Context, count int64) *ACLLogCmd {
	ret := _m.Called(ctx, count)

	if len(ret) == 0 {
		panic("no return value specified for ACLLog")
	}

	var r0 *ACLLogCmd
	if rf, ok := ret.Get(0).(func(context.Context, int64) *ACLLogCmd); ok {
		r0 = rf(ctx, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ACLLogCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLLog'
type MockACLCmdable_ACLLog_Call struct {
	*mock.Call
}

// ACLLog is a helper method to define mock.On call
//   - ctx context.Context
//   - count int64
func (_e *MockACLCmdable_Expecter) ACLLog(ctx interface{}, count interface{}) *MockACLCmdable_ACLLog_Call {
	return &MockACLCmdable_ACLLog_Call{Call: _e.mock.On("ACLLog", ctx, count)}
}

func (_c *MockACLCmdable_ACLLog_Call) Run(run func(ctx context.Context, count int64)) *MockACLCmdable_ACLLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64))
	})
	return _c
}

func (_c *MockACLCmdable_ACLLog_Call) Return(_a0 *ACLLogCmd) *MockACLCmdable_ACLLog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLLog_Call) RunAndReturn(run func(context.Context, int64) *ACLLogCmd) *MockACLCmdable_ACLLog_Call {
	_c.Call.Return(run)
	return _c
}

// ACLLogReset provides a mock function with given fields: ctx
func (_m *MockACLCmdable) ACLLogReset(ctx context.Context) *StatusCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ACLLogReset")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context) *StatusCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLLogReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLLogReset'
type MockACLCmdable_ACLLogReset_Call struct {
	*mock.Call
}

// ACLLogReset is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockACLCmdable_Expecter) ACLLogReset(ctx interface{}) *MockACLCmdable_ACLLogReset_Call {
	return &MockACLCmdable_ACLLogReset_Call{Call: _e.mock.On("ACLLogReset", ctx)}
}

func (_c *MockACLCmdable_ACLLogReset_Call) Run(run func(ctx context.Context)) *MockACLCmdable_ACLLogReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockACLCmdable_ACLLogReset_Call) Return(_a0 *StatusCmd) *MockACLCmdable_ACLLogReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLLogReset_Call) RunAndReturn(run func(context.Context) *StatusCmd) *MockACLCmdable_ACLLogReset_Call {
	_c.Call.Return(run)
	return _c
}

// ACLSetUser provides a mock function with given fields: ctx, username, rules
func (_m *MockACLCmdable) ACLSetUser(ctx context.Context, username string, rules ...string) *StatusCmd {
	_va := make([]interface{}, len(rules))
	for _i := range rules {
		_va[_i] = rules[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, username)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ACLSetUser")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *StatusCmd); ok {
		r0 = rf(ctx, username, rules...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockACLCmdable_ACLSetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ACLSetUser'
type MockACLCmdable_ACLSetUser_Call struct {
	*mock.Call
}

// ACLSetUser is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
//   - rules ...string
func (_e *MockACLCmdable_Expecter) ACLSetUser(ctx interface{}, username interface{}, rules ...interface{}) *MockACLCmdable_ACLSetUser_Call {
	return &MockACLCmdable_ACLSetUser_Call{Call: _e.mock.On("ACLSetUser",
		append([]interface{}{ctx, username}, rules...)...)}
}

func (_c *MockACLCmdable_ACLSetUser_Call) Run(run func(ctx context.Context, username string, rules ...string)) *MockACLCmdable_ACLSetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockACLCmdable_ACLSetUser_Call) Return(_a0 *StatusCmd) *MockACLCmdable_ACLSetUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockACLCmdable_ACLSetUser_Call) RunAndReturn(run func(context.Context, string, ...string) *StatusCmd) *MockACLCmdable_ACLSetUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockACLCmdable creates a new instance of MockACLCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockACLCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockACLCmdable {
	mock := &MockACLCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
