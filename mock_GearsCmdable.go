// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockGearsCmdable is an autogenerated mock type for the GearsCmdable type
type MockGearsCmdable struct {
	mock.Mock
}

type MockGearsCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockGearsCmdable) EXPECT() *MockGearsCmdable_Expecter {
	return &MockGearsCmdable_Expecter{mock: &_m.Mock}
}

// TFCall provides a mock function with given fields: ctx, libName, funcName, numKeys
func (_m *MockGearsCmdable) TFCall(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys)

	if len(ret) == 0 {
		panic("no return value specified for TFCall")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFCall_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCall'
type MockGearsCmdable_TFCall_Call struct {
	*mock.Call
}

// TFCall is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
func (_e *MockGearsCmdable_Expecter) TFCall(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}) *MockGearsCmdable_TFCall_Call {
	return &MockGearsCmdable_TFCall_Call{Call: _e.mock.On("TFCall", ctx, libName, funcName, numKeys)}
}

func (_c *MockGearsCmdable_TFCall_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int)) *MockGearsCmdable_TFCall_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockGearsCmdable_TFCall_Call) Return(_a0 *Cmd) *MockGearsCmdable_TFCall_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFCall_Call) RunAndReturn(run func(context.Context, string, string, int) *Cmd) *MockGearsCmdable_TFCall_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallASYNC provides a mock function with given fields: ctx, libName, funcName, numKeys
func (_m *MockGearsCmdable) TFCallASYNC(ctx context.Context, libName string, funcName string, numKeys int) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys)

	if len(ret) == 0 {
		panic("no return value specified for TFCallASYNC")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFCallASYNC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallASYNC'
type MockGearsCmdable_TFCallASYNC_Call struct {
	*mock.Call
}

// TFCallASYNC is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
func (_e *MockGearsCmdable_Expecter) TFCallASYNC(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}) *MockGearsCmdable_TFCallASYNC_Call {
	return &MockGearsCmdable_TFCallASYNC_Call{Call: _e.mock.On("TFCallASYNC", ctx, libName, funcName, numKeys)}
}

func (_c *MockGearsCmdable_TFCallASYNC_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int)) *MockGearsCmdable_TFCallASYNC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int))
	})
	return _c
}

func (_c *MockGearsCmdable_TFCallASYNC_Call) Return(_a0 *Cmd) *MockGearsCmdable_TFCallASYNC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFCallASYNC_Call) RunAndReturn(run func(context.Context, string, string, int) *Cmd) *MockGearsCmdable_TFCallASYNC_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallASYNCArgs provides a mock function with given fields: ctx, libName, funcName, numKeys, options
func (_m *MockGearsCmdable) TFCallASYNCArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys, options)

	if len(ret) == 0 {
		panic("no return value specified for TFCallASYNCArgs")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, *TFCallOptions) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFCallASYNCArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallASYNCArgs'
type MockGearsCmdable_TFCallASYNCArgs_Call struct {
	*mock.Call
}

// TFCallASYNCArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
//   - options *TFCallOptions
func (_e *MockGearsCmdable_Expecter) TFCallASYNCArgs(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}, options interface{}) *MockGearsCmdable_TFCallASYNCArgs_Call {
	return &MockGearsCmdable_TFCallASYNCArgs_Call{Call: _e.mock.On("TFCallASYNCArgs", ctx, libName, funcName, numKeys, options)}
}

func (_c *MockGearsCmdable_TFCallASYNCArgs_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions)) *MockGearsCmdable_TFCallASYNCArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(*TFCallOptions))
	})
	return _c
}

func (_c *MockGearsCmdable_TFCallASYNCArgs_Call) Return(_a0 *Cmd) *MockGearsCmdable_TFCallASYNCArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFCallASYNCArgs_Call) RunAndReturn(run func(context.Context, string, string, int, *TFCallOptions) *Cmd) *MockGearsCmdable_TFCallASYNCArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFCallArgs provides a mock function with given fields: ctx, libName, funcName, numKeys, options
func (_m *MockGearsCmdable) TFCallArgs(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions) *Cmd {
	ret := _m.Called(ctx, libName, funcName, numKeys, options)

	if len(ret) == 0 {
		panic("no return value specified for TFCallArgs")
	}

	var r0 *Cmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string, int, *TFCallOptions) *Cmd); ok {
		r0 = rf(ctx, libName, funcName, numKeys, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*Cmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFCallArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFCallArgs'
type MockGearsCmdable_TFCallArgs_Call struct {
	*mock.Call
}

// TFCallArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
//   - funcName string
//   - numKeys int
//   - options *TFCallOptions
func (_e *MockGearsCmdable_Expecter) TFCallArgs(ctx interface{}, libName interface{}, funcName interface{}, numKeys interface{}, options interface{}) *MockGearsCmdable_TFCallArgs_Call {
	return &MockGearsCmdable_TFCallArgs_Call{Call: _e.mock.On("TFCallArgs", ctx, libName, funcName, numKeys, options)}
}

func (_c *MockGearsCmdable_TFCallArgs_Call) Run(run func(ctx context.Context, libName string, funcName string, numKeys int, options *TFCallOptions)) *MockGearsCmdable_TFCallArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(int), args[4].(*TFCallOptions))
	})
	return _c
}

func (_c *MockGearsCmdable_TFCallArgs_Call) Return(_a0 *Cmd) *MockGearsCmdable_TFCallArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFCallArgs_Call) RunAndReturn(run func(context.Context, string, string, int, *TFCallOptions) *Cmd) *MockGearsCmdable_TFCallArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionDelete provides a mock function with given fields: ctx, libName
func (_m *MockGearsCmdable) TFunctionDelete(ctx context.Context, libName string) *StatusCmd {
	ret := _m.Called(ctx, libName)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionDelete")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, libName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFunctionDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionDelete'
type MockGearsCmdable_TFunctionDelete_Call struct {
	*mock.Call
}

// TFunctionDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - libName string
func (_e *MockGearsCmdable_Expecter) TFunctionDelete(ctx interface{}, libName interface{}) *MockGearsCmdable_TFunctionDelete_Call {
	return &MockGearsCmdable_TFunctionDelete_Call{Call: _e.mock.On("TFunctionDelete", ctx, libName)}
}

func (_c *MockGearsCmdable_TFunctionDelete_Call) Run(run func(ctx context.Context, libName string)) *MockGearsCmdable_TFunctionDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGearsCmdable_TFunctionDelete_Call) Return(_a0 *StatusCmd) *MockGearsCmdable_TFunctionDelete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFunctionDelete_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockGearsCmdable_TFunctionDelete_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionList provides a mock function with given fields: ctx
func (_m *MockGearsCmdable) TFunctionList(ctx context.Context) *MapStringInterfaceSliceCmd {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionList")
	}

	var r0 *MapStringInterfaceSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context) *MapStringInterfaceSliceCmd); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceSliceCmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFunctionList_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionList'
type MockGearsCmdable_TFunctionList_Call struct {
	*mock.Call
}

// TFunctionList is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockGearsCmdable_Expecter) TFunctionList(ctx interface{}) *MockGearsCmdable_TFunctionList_Call {
	return &MockGearsCmdable_TFunctionList_Call{Call: _e.mock.On("TFunctionList", ctx)}
}

func (_c *MockGearsCmdable_TFunctionList_Call) Run(run func(ctx context.Context)) *MockGearsCmdable_TFunctionList_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockGearsCmdable_TFunctionList_Call) Return(_a0 *MapStringInterfaceSliceCmd) *MockGearsCmdable_TFunctionList_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFunctionList_Call) RunAndReturn(run func(context.Context) *MapStringInterfaceSliceCmd) *MockGearsCmdable_TFunctionList_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionListArgs provides a mock function with given fields: ctx, options
func (_m *MockGearsCmdable) TFunctionListArgs(ctx context.Context, options *TFunctionListOptions) *MapStringInterfaceSliceCmd {
	ret := _m.Called(ctx, options)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionListArgs")
	}

	var r0 *MapStringInterfaceSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, *TFunctionListOptions) *MapStringInterfaceSliceCmd); ok {
		r0 = rf(ctx, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*MapStringInterfaceSliceCmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFunctionListArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionListArgs'
type MockGearsCmdable_TFunctionListArgs_Call struct {
	*mock.Call
}

// TFunctionListArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - options *TFunctionListOptions
func (_e *MockGearsCmdable_Expecter) TFunctionListArgs(ctx interface{}, options interface{}) *MockGearsCmdable_TFunctionListArgs_Call {
	return &MockGearsCmdable_TFunctionListArgs_Call{Call: _e.mock.On("TFunctionListArgs", ctx, options)}
}

func (_c *MockGearsCmdable_TFunctionListArgs_Call) Run(run func(ctx context.Context, options *TFunctionListOptions)) *MockGearsCmdable_TFunctionListArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*TFunctionListOptions))
	})
	return _c
}

func (_c *MockGearsCmdable_TFunctionListArgs_Call) Return(_a0 *MapStringInterfaceSliceCmd) *MockGearsCmdable_TFunctionListArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFunctionListArgs_Call) RunAndReturn(run func(context.Context, *TFunctionListOptions) *MapStringInterfaceSliceCmd) *MockGearsCmdable_TFunctionListArgs_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionLoad provides a mock function with given fields: ctx, lib
func (_m *MockGearsCmdable) TFunctionLoad(ctx context.Context, lib string) *StatusCmd {
	ret := _m.Called(ctx, lib)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionLoad")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string) *StatusCmd); ok {
		r0 = rf(ctx, lib)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFunctionLoad_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionLoad'
type MockGearsCmdable_TFunctionLoad_Call struct {
	*mock.Call
}

// TFunctionLoad is a helper method to define mock.On call
//   - ctx context.Context
//   - lib string
func (_e *MockGearsCmdable_Expecter) TFunctionLoad(ctx interface{}, lib interface{}) *MockGearsCmdable_TFunctionLoad_Call {
	return &MockGearsCmdable_TFunctionLoad_Call{Call: _e.mock.On("TFunctionLoad", ctx, lib)}
}

func (_c *MockGearsCmdable_TFunctionLoad_Call) Run(run func(ctx context.Context, lib string)) *MockGearsCmdable_TFunctionLoad_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockGearsCmdable_TFunctionLoad_Call) Return(_a0 *StatusCmd) *MockGearsCmdable_TFunctionLoad_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFunctionLoad_Call) RunAndReturn(run func(context.Context, string) *StatusCmd) *MockGearsCmdable_TFunctionLoad_Call {
	_c.Call.Return(run)
	return _c
}

// TFunctionLoadArgs provides a mock function with given fields: ctx, lib, options
func (_m *MockGearsCmdable) TFunctionLoadArgs(ctx context.Context, lib string, options *TFunctionLoadOptions) *StatusCmd {
	ret := _m.Called(ctx, lib, options)

	if len(ret) == 0 {
		panic("no return value specified for TFunctionLoadArgs")
	}

	var r0 *StatusCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *TFunctionLoadOptions) *StatusCmd); ok {
		r0 = rf(ctx, lib, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*StatusCmd)
		}
	}

	return r0
}

// MockGearsCmdable_TFunctionLoadArgs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TFunctionLoadArgs'
type MockGearsCmdable_TFunctionLoadArgs_Call struct {
	*mock.Call
}

// TFunctionLoadArgs is a helper method to define mock.On call
//   - ctx context.Context
//   - lib string
//   - options *TFunctionLoadOptions
func (_e *MockGearsCmdable_Expecter) TFunctionLoadArgs(ctx interface{}, lib interface{}, options interface{}) *MockGearsCmdable_TFunctionLoadArgs_Call {
	return &MockGearsCmdable_TFunctionLoadArgs_Call{Call: _e.mock.On("TFunctionLoadArgs", ctx, lib, options)}
}

func (_c *MockGearsCmdable_TFunctionLoadArgs_Call) Run(run func(ctx context.Context, lib string, options *TFunctionLoadOptions)) *MockGearsCmdable_TFunctionLoadArgs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*TFunctionLoadOptions))
	})
	return _c
}

func (_c *MockGearsCmdable_TFunctionLoadArgs_Call) Return(_a0 *StatusCmd) *MockGearsCmdable_TFunctionLoadArgs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockGearsCmdable_TFunctionLoadArgs_Call) RunAndReturn(run func(context.Context, string, *TFunctionLoadOptions) *StatusCmd) *MockGearsCmdable_TFunctionLoadArgs_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockGearsCmdable creates a new instance of MockGearsCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockGearsCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockGearsCmdable {
	mock := &MockGearsCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
