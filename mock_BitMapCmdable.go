// Code generated by mockery. DO NOT EDIT.

package redis

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
)

// MockBitMapCmdable is an autogenerated mock type for the BitMapCmdable type
type MockBitMapCmdable struct {
	mock.Mock
}

type MockBitMapCmdable_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBitMapCmdable) EXPECT() *MockBitMapCmdable_Expecter {
	return &MockBitMapCmdable_Expecter{mock: &_m.Mock}
}

// BitCount provides a mock function with given fields: ctx, key, bitCount
func (_m *MockBitMapCmdable) BitCount(ctx context.Context, key string, bitCount *BitCount) *IntCmd {
	ret := _m.Called(ctx, key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, *BitCount) *IntCmd); ok {
		r0 = rf(ctx, key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitCount'
type MockBitMapCmdable_BitCount_Call struct {
	*mock.Call
}

// BitCount is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bitCount *BitCount
func (_e *MockBitMapCmdable_Expecter) BitCount(ctx interface{}, key interface{}, bitCount interface{}) *MockBitMapCmdable_BitCount_Call {
	return &MockBitMapCmdable_BitCount_Call{Call: _e.mock.On("BitCount", ctx, key, bitCount)}
}

func (_c *MockBitMapCmdable_BitCount_Call) Run(run func(ctx context.Context, key string, bitCount *BitCount)) *MockBitMapCmdable_BitCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*BitCount))
	})
	return _c
}

func (_c *MockBitMapCmdable_BitCount_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitCount_Call) RunAndReturn(run func(context.Context, string, *BitCount) *IntCmd) *MockBitMapCmdable_BitCount_Call {
	_c.Call.Return(run)
	return _c
}

// BitField provides a mock function with given fields: ctx, key, values
func (_m *MockBitMapCmdable) BitField(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitField")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitField_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitField'
type MockBitMapCmdable_BitField_Call struct {
	*mock.Call
}

// BitField is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockBitMapCmdable_Expecter) BitField(ctx interface{}, key interface{}, values ...interface{}) *MockBitMapCmdable_BitField_Call {
	return &MockBitMapCmdable_BitField_Call{Call: _e.mock.On("BitField",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockBitMapCmdable_BitField_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockBitMapCmdable_BitField_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitField_Call) Return(_a0 *IntSliceCmd) *MockBitMapCmdable_BitField_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitField_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockBitMapCmdable_BitField_Call {
	_c.Call.Return(run)
	return _c
}

// BitFieldRO provides a mock function with given fields: ctx, key, values
func (_m *MockBitMapCmdable) BitFieldRO(ctx context.Context, key string, values ...interface{}) *IntSliceCmd {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitFieldRO")
	}

	var r0 *IntSliceCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) *IntSliceCmd); ok {
		r0 = rf(ctx, key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntSliceCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitFieldRO_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitFieldRO'
type MockBitMapCmdable_BitFieldRO_Call struct {
	*mock.Call
}

// BitFieldRO is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *MockBitMapCmdable_Expecter) BitFieldRO(ctx interface{}, key interface{}, values ...interface{}) *MockBitMapCmdable_BitFieldRO_Call {
	return &MockBitMapCmdable_BitFieldRO_Call{Call: _e.mock.On("BitFieldRO",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *MockBitMapCmdable_BitFieldRO_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *MockBitMapCmdable_BitFieldRO_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitFieldRO_Call) Return(_a0 *IntSliceCmd) *MockBitMapCmdable_BitFieldRO_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitFieldRO_Call) RunAndReturn(run func(context.Context, string, ...interface{}) *IntSliceCmd) *MockBitMapCmdable_BitFieldRO_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpAnd provides a mock function with given fields: ctx, destKey, keys
func (_m *MockBitMapCmdable) BitOpAnd(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitOpAnd_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpAnd'
type MockBitMapCmdable_BitOpAnd_Call struct {
	*mock.Call
}

// BitOpAnd is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockBitMapCmdable_Expecter) BitOpAnd(ctx interface{}, destKey interface{}, keys ...interface{}) *MockBitMapCmdable_BitOpAnd_Call {
	return &MockBitMapCmdable_BitOpAnd_Call{Call: _e.mock.On("BitOpAnd",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockBitMapCmdable_BitOpAnd_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockBitMapCmdable_BitOpAnd_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitOpAnd_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitOpAnd_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitOpAnd_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockBitMapCmdable_BitOpAnd_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpNot provides a mock function with given fields: ctx, destKey, key
func (_m *MockBitMapCmdable) BitOpNot(ctx context.Context, destKey string, key string) *IntCmd {
	ret := _m.Called(ctx, destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *IntCmd); ok {
		r0 = rf(ctx, destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitOpNot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpNot'
type MockBitMapCmdable_BitOpNot_Call struct {
	*mock.Call
}

// BitOpNot is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - key string
func (_e *MockBitMapCmdable_Expecter) BitOpNot(ctx interface{}, destKey interface{}, key interface{}) *MockBitMapCmdable_BitOpNot_Call {
	return &MockBitMapCmdable_BitOpNot_Call{Call: _e.mock.On("BitOpNot", ctx, destKey, key)}
}

func (_c *MockBitMapCmdable_BitOpNot_Call) Run(run func(ctx context.Context, destKey string, key string)) *MockBitMapCmdable_BitOpNot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockBitMapCmdable_BitOpNot_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitOpNot_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitOpNot_Call) RunAndReturn(run func(context.Context, string, string) *IntCmd) *MockBitMapCmdable_BitOpNot_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpOr provides a mock function with given fields: ctx, destKey, keys
func (_m *MockBitMapCmdable) BitOpOr(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitOpOr_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpOr'
type MockBitMapCmdable_BitOpOr_Call struct {
	*mock.Call
}

// BitOpOr is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockBitMapCmdable_Expecter) BitOpOr(ctx interface{}, destKey interface{}, keys ...interface{}) *MockBitMapCmdable_BitOpOr_Call {
	return &MockBitMapCmdable_BitOpOr_Call{Call: _e.mock.On("BitOpOr",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockBitMapCmdable_BitOpOr_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockBitMapCmdable_BitOpOr_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitOpOr_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitOpOr_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitOpOr_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockBitMapCmdable_BitOpOr_Call {
	_c.Call.Return(run)
	return _c
}

// BitOpXor provides a mock function with given fields: ctx, destKey, keys
func (_m *MockBitMapCmdable) BitOpXor(ctx context.Context, destKey string, keys ...string) *IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) *IntCmd); ok {
		r0 = rf(ctx, destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitOpXor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitOpXor'
type MockBitMapCmdable_BitOpXor_Call struct {
	*mock.Call
}

// BitOpXor is a helper method to define mock.On call
//   - ctx context.Context
//   - destKey string
//   - keys ...string
func (_e *MockBitMapCmdable_Expecter) BitOpXor(ctx interface{}, destKey interface{}, keys ...interface{}) *MockBitMapCmdable_BitOpXor_Call {
	return &MockBitMapCmdable_BitOpXor_Call{Call: _e.mock.On("BitOpXor",
		append([]interface{}{ctx, destKey}, keys...)...)}
}

func (_c *MockBitMapCmdable_BitOpXor_Call) Run(run func(ctx context.Context, destKey string, keys ...string)) *MockBitMapCmdable_BitOpXor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitOpXor_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitOpXor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitOpXor_Call) RunAndReturn(run func(context.Context, string, ...string) *IntCmd) *MockBitMapCmdable_BitOpXor_Call {
	_c.Call.Return(run)
	return _c
}

// BitPos provides a mock function with given fields: ctx, key, bit, pos
func (_m *MockBitMapCmdable) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ...int64) *IntCmd); ok {
		r0 = rf(ctx, key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitPos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitPos'
type MockBitMapCmdable_BitPos_Call struct {
	*mock.Call
}

// BitPos is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bit int64
//   - pos ...int64
func (_e *MockBitMapCmdable_Expecter) BitPos(ctx interface{}, key interface{}, bit interface{}, pos ...interface{}) *MockBitMapCmdable_BitPos_Call {
	return &MockBitMapCmdable_BitPos_Call{Call: _e.mock.On("BitPos",
		append([]interface{}{ctx, key, bit}, pos...)...)}
}

func (_c *MockBitMapCmdable_BitPos_Call) Run(run func(ctx context.Context, key string, bit int64, pos ...int64)) *MockBitMapCmdable_BitPos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int64, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int64)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(int64), variadicArgs...)
	})
	return _c
}

func (_c *MockBitMapCmdable_BitPos_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitPos_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitPos_Call) RunAndReturn(run func(context.Context, string, int64, ...int64) *IntCmd) *MockBitMapCmdable_BitPos_Call {
	_c.Call.Return(run)
	return _c
}

// BitPosSpan provides a mock function with given fields: ctx, key, bit, start, end, span
func (_m *MockBitMapCmdable) BitPosSpan(ctx context.Context, key string, bit int8, start int64, end int64, span string) *IntCmd {
	ret := _m.Called(ctx, key, bit, start, end, span)

	if len(ret) == 0 {
		panic("no return value specified for BitPosSpan")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int8, int64, int64, string) *IntCmd); ok {
		r0 = rf(ctx, key, bit, start, end, span)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_BitPosSpan_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BitPosSpan'
type MockBitMapCmdable_BitPosSpan_Call struct {
	*mock.Call
}

// BitPosSpan is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bit int8
//   - start int64
//   - end int64
//   - span string
func (_e *MockBitMapCmdable_Expecter) BitPosSpan(ctx interface{}, key interface{}, bit interface{}, start interface{}, end interface{}, span interface{}) *MockBitMapCmdable_BitPosSpan_Call {
	return &MockBitMapCmdable_BitPosSpan_Call{Call: _e.mock.On("BitPosSpan", ctx, key, bit, start, end, span)}
}

func (_c *MockBitMapCmdable_BitPosSpan_Call) Run(run func(ctx context.Context, key string, bit int8, start int64, end int64, span string)) *MockBitMapCmdable_BitPosSpan_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int8), args[3].(int64), args[4].(int64), args[5].(string))
	})
	return _c
}

func (_c *MockBitMapCmdable_BitPosSpan_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_BitPosSpan_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_BitPosSpan_Call) RunAndReturn(run func(context.Context, string, int8, int64, int64, string) *IntCmd) *MockBitMapCmdable_BitPosSpan_Call {
	_c.Call.Return(run)
	return _c
}

// GetBit provides a mock function with given fields: ctx, key, offset
func (_m *MockBitMapCmdable) GetBit(ctx context.Context, key string, offset int64) *IntCmd {
	ret := _m.Called(ctx, key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64) *IntCmd); ok {
		r0 = rf(ctx, key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_GetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBit'
type MockBitMapCmdable_GetBit_Call struct {
	*mock.Call
}

// GetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
func (_e *MockBitMapCmdable_Expecter) GetBit(ctx interface{}, key interface{}, offset interface{}) *MockBitMapCmdable_GetBit_Call {
	return &MockBitMapCmdable_GetBit_Call{Call: _e.mock.On("GetBit", ctx, key, offset)}
}

func (_c *MockBitMapCmdable_GetBit_Call) Run(run func(ctx context.Context, key string, offset int64)) *MockBitMapCmdable_GetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64))
	})
	return _c
}

func (_c *MockBitMapCmdable_GetBit_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_GetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_GetBit_Call) RunAndReturn(run func(context.Context, string, int64) *IntCmd) *MockBitMapCmdable_GetBit_Call {
	_c.Call.Return(run)
	return _c
}

// SetBit provides a mock function with given fields: ctx, key, offset, value
func (_m *MockBitMapCmdable) SetBit(ctx context.Context, key string, offset int64, value int) *IntCmd {
	ret := _m.Called(ctx, key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *IntCmd
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, int) *IntCmd); ok {
		r0 = rf(ctx, key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*IntCmd)
		}
	}

	return r0
}

// MockBitMapCmdable_SetBit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetBit'
type MockBitMapCmdable_SetBit_Call struct {
	*mock.Call
}

// SetBit is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - offset int64
//   - value int
func (_e *MockBitMapCmdable_Expecter) SetBit(ctx interface{}, key interface{}, offset interface{}, value interface{}) *MockBitMapCmdable_SetBit_Call {
	return &MockBitMapCmdable_SetBit_Call{Call: _e.mock.On("SetBit", ctx, key, offset, value)}
}

func (_c *MockBitMapCmdable_SetBit_Call) Run(run func(ctx context.Context, key string, offset int64, value int)) *MockBitMapCmdable_SetBit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int64), args[3].(int))
	})
	return _c
}

func (_c *MockBitMapCmdable_SetBit_Call) Return(_a0 *IntCmd) *MockBitMapCmdable_SetBit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitMapCmdable_SetBit_Call) RunAndReturn(run func(context.Context, string, int64, int) *IntCmd) *MockBitMapCmdable_SetBit_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBitMapCmdable creates a new instance of MockBitMapCmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBitMapCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBitMapCmdable {
	mock := &MockBitMapCmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
